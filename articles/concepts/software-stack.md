---
title: 軟體堆疊 |Microsoft Docs
description: Software stack
author: QuantumWriter
uid: microsoft.quantum.concepts.software-stack
ms.author: nawiebe@microsoft.com
ms.date: 12/11/2017
ms.topic: article
ms.openlocfilehash: f97dfacf6cde5fa92e1f368efaae36554a5c944d
ms.sourcegitcommit: 8becfb03eb60ba205c670a634ff4daa8071bcd06
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 10/28/2019
ms.locfileid: "73184724"
---
# <a name="software-stack-for-quantum-computing"></a><span data-ttu-id="ce70a-103">用於量子運算的軟體堆疊</span><span class="sxs-lookup"><span data-stu-id="ce70a-103">Software stack for quantum computing</span></span>
<span data-ttu-id="ce70a-104">通常當我們想到電腦時，我們想像到一個執行應用程式的裝置，但是現代化的運算環境更複雜且更先進。</span><span class="sxs-lookup"><span data-stu-id="ce70a-104">Normally when we think of a computer we envision a single device running an application, but modern computing environments are much more complex and advanced.</span></span> <span data-ttu-id="ce70a-105">我們與互動的應用程式通常會在多層的軟體上提供，讓應用程式的執行向下到硬體層級。</span><span class="sxs-lookup"><span data-stu-id="ce70a-105">The application we interact with typically rests on multiple layers of software that provide for the application's execution down to the hardware level.</span></span> <span data-ttu-id="ce70a-106">這些軟體層是將應用程式解決方案的開發從完整計算系統的基礎複雜度抽象化的必要步驟。</span><span class="sxs-lookup"><span data-stu-id="ce70a-106">These software layers are necessary to abstract the development of an application solution from the underlying complexity of the complete computing system.</span></span> <span data-ttu-id="ce70a-107">如果開發人員在撰寫簡單的 smartphone 應用程式時，必須考慮匯流排、快取架構、通訊協定等，則工作會變得更複雜。</span><span class="sxs-lookup"><span data-stu-id="ce70a-107">If a developer had to think about bus, cache architectures, communication protocols, and more while writing a simple smartphone app, the task would become much more complex.</span></span>  <span data-ttu-id="ce70a-108">*軟體堆疊*的概念是在傳統計算中開發，以解決這些問題。</span><span class="sxs-lookup"><span data-stu-id="ce70a-108">The concept of a *software stack* was developed in classical computing to address these issues.</span></span>  <span data-ttu-id="ce70a-109">從傳統概念來借用，軟體堆疊也是使用 Q # 進行配量運算的重要部分。</span><span class="sxs-lookup"><span data-stu-id="ce70a-109">Borrowing from the classical concept, a software stack is also a key part of the vision behind quantum computing with Q#.</span></span>

## <a name="conventional-stack"></a><span data-ttu-id="ce70a-110">傳統堆疊</span><span class="sxs-lookup"><span data-stu-id="ce70a-110">Conventional stack</span></span>
<span data-ttu-id="ce70a-111">軟體堆疊背後的主要概念是遞迴。</span><span class="sxs-lookup"><span data-stu-id="ce70a-111">The key idea behind a software stack is recursion.</span></span>  <span data-ttu-id="ce70a-112">它是由數個嵌套的介面層所組成，可將裝置較低層級的詳細資料，從開發人員中抽象化出來。</span><span class="sxs-lookup"><span data-stu-id="ce70a-112">It consists of several nested layers of interfaces that abstract the details of the lower levels of the device away from the developer.</span></span>  <span data-ttu-id="ce70a-113">For example, a commonly used software stack involves running ASP.NET (a programming language), on top of SQL server (a relational database management system), which runs on top of Internet Information Services (a web server), which runs on top of Windows server (an operating system), which drives the computer hardware.</span><span class="sxs-lookup"><span data-stu-id="ce70a-113">For example, a commonly used software stack involves running ASP.NET (a programming language), on top of SQL server (a relational database management system), which runs on top of Internet Information Services (a web server), which runs on top of Windows server (an operating system), which drives the computer hardware.</span></span>  <span data-ttu-id="ce70a-114">By looking at software as a hierarchy, one can write software in ASP.NET without needing to understand the low-level details of all the software below it.</span><span class="sxs-lookup"><span data-stu-id="ce70a-114">By looking at software as a hierarchy, one can write software in ASP.NET without needing to understand the low-level details of all the software below it.</span></span>

## <a name="quantum-stack"></a><span data-ttu-id="ce70a-115">Quantum stack</span><span class="sxs-lookup"><span data-stu-id="ce70a-115">Quantum stack</span></span>

<span data-ttu-id="ce70a-116">The software stack in quantum computing is no different in principle, and in practice operates at a lower level than traditional stacks.</span><span class="sxs-lookup"><span data-stu-id="ce70a-116">The software stack in quantum computing is no different in principle, and in practice operates at a lower level than traditional stacks.</span></span>  <span data-ttu-id="ce70a-117">What does a quantum stack look like?</span><span class="sxs-lookup"><span data-stu-id="ce70a-117">What does a quantum stack look like?</span></span>  <span data-ttu-id="ce70a-118">A quantum computer is not a replacement for traditional (often called classical) computers.</span><span class="sxs-lookup"><span data-stu-id="ce70a-118">A quantum computer is not a replacement for traditional (often called classical) computers.</span></span>  <span data-ttu-id="ce70a-119">In fact, quantum computers will almost certainly work in tandem with classical computers to solve computational problems.</span><span class="sxs-lookup"><span data-stu-id="ce70a-119">In fact, quantum computers will almost certainly work in tandem with classical computers to solve computational problems.</span></span>  <span data-ttu-id="ce70a-120">In part, this arises because of the fragility of quantum data.</span><span class="sxs-lookup"><span data-stu-id="ce70a-120">In part, this arises because of the fragility of quantum data.</span></span>  <span data-ttu-id="ce70a-121">Quantum data is so fragile that if you even look at it you almost certainly damage the information being observed.</span><span class="sxs-lookup"><span data-stu-id="ce70a-121">Quantum data is so fragile that if you even look at it you almost certainly damage the information being observed.</span></span>  <span data-ttu-id="ce70a-122">Quantum computers will thus need to be designed with quantum error correction in mind so that stray interactions from its physical environment do not inadvertently damage the information and computation.</span><span class="sxs-lookup"><span data-stu-id="ce70a-122">Quantum computers will thus need to be designed with quantum error correction in mind so that stray interactions from its physical environment do not inadvertently damage the information and computation.</span></span> <span data-ttu-id="ce70a-123">For this reason, a natural target for Q# is an error-corrected quantum computer (often called a *fault-tolerant* quantum computer) that accepts a list of quantum instructions (called gates or gate operations) and applies those instructions to the quantum data stored within it.</span><span class="sxs-lookup"><span data-stu-id="ce70a-123">For this reason, a natural target for Q# is an error-corrected quantum computer (often called a *fault-tolerant* quantum computer) that accepts a list of quantum instructions (called gates or gate operations) and applies those instructions to the quantum data stored within it.</span></span>  <span data-ttu-id="ce70a-124">Note that if the number of qubits and gate operations in a quantum algorithm or program is small enough, error correction may not be absolutely necessary.</span><span class="sxs-lookup"><span data-stu-id="ce70a-124">Note that if the number of qubits and gate operations in a quantum algorithm or program is small enough, error correction may not be absolutely necessary.</span></span>  <span data-ttu-id="ce70a-125">However as the number of qubits and gate operations grow, it will more certainly be a requirement, thus we architect our software stack and Q# to aptly and efficiently handle error correction and enable scalable, fault-tolerant quantum computing.</span><span class="sxs-lookup"><span data-stu-id="ce70a-125">However as the number of qubits and gate operations grow, it will more certainly be a requirement, thus we architect our software stack and Q# to aptly and efficiently handle error correction and enable scalable, fault-tolerant quantum computing.</span></span>

### <a name="error-correction"></a><span data-ttu-id="ce70a-126">Error correction</span><span class="sxs-lookup"><span data-stu-id="ce70a-126">Error correction</span></span>
<span data-ttu-id="ce70a-127">Error correction requires a fast and reliable classical computer to be run in concert with the quantum computer to correct errors as they appear in the quantum computation.</span><span class="sxs-lookup"><span data-stu-id="ce70a-127">Error correction requires a fast and reliable classical computer to be run in concert with the quantum computer to correct errors as they appear in the quantum computation.</span></span>  <span data-ttu-id="ce70a-128">In practice, components such as field-programmable gate arrays (FPGAs) or fast cryogenic processors may be needed to identify and correct the errors faster than they naturally accumulate in the quantum computer.</span><span class="sxs-lookup"><span data-stu-id="ce70a-128">In practice, components such as field-programmable gate arrays (FPGAs) or fast cryogenic processors may be needed to identify and correct the errors faster than they naturally accumulate in the quantum computer.</span></span>  <span data-ttu-id="ce70a-129">As a result, a quantum computer is a hybrid machine comprised of several different computational devices that operate over a wide range of temperatures.</span><span class="sxs-lookup"><span data-stu-id="ce70a-129">As a result, a quantum computer is a hybrid machine comprised of several different computational devices that operate over a wide range of temperatures.</span></span>  <span data-ttu-id="ce70a-130">For this reason, it is much more helpful to think about programming a quantum computer through the lens of a software stack, as there are many layers of hardware and software (classical and quantum) required to ultimately achieve the implementation of a quantum algorithm on a quantum computer.</span><span class="sxs-lookup"><span data-stu-id="ce70a-130">For this reason, it is much more helpful to think about programming a quantum computer through the lens of a software stack, as there are many layers of hardware and software (classical and quantum) required to ultimately achieve the implementation of a quantum algorithm on a quantum computer.</span></span>

### <a name="quantum-conceptual-stack"></a><span data-ttu-id="ce70a-131">Quantum conceptual stack</span><span class="sxs-lookup"><span data-stu-id="ce70a-131">Quantum conceptual stack</span></span>
<span data-ttu-id="ce70a-132">A conceptual stack that illustrates the functional flow of factoring 8704143553785700723 in a quantum computing environment is shown below:</span><span class="sxs-lookup"><span data-stu-id="ce70a-132">A conceptual stack that illustrates the functional flow of factoring 8704143553785700723 in a quantum computing environment is shown below:</span></span>

![Software stack](~/media/concepts_stack.png)

### <a name="specification-and-algorithm"></a><span data-ttu-id="ce70a-134">Specification and algorithm</span><span class="sxs-lookup"><span data-stu-id="ce70a-134">Specification and algorithm</span></span>
<span data-ttu-id="ce70a-135">There are several broad stages of programming such a quantum computation.</span><span class="sxs-lookup"><span data-stu-id="ce70a-135">There are several broad stages of programming such a quantum computation.</span></span>  <span data-ttu-id="ce70a-136">The first, and arguably most challenging phase, is specifying the problem that one wishes to solve.</span><span class="sxs-lookup"><span data-stu-id="ce70a-136">The first, and arguably most challenging phase, is specifying the problem that one wishes to solve.</span></span>  <span data-ttu-id="ce70a-137">In this case, the problem is to factor the number 8704143553785700723  into a product of two prime numbers.</span><span class="sxs-lookup"><span data-stu-id="ce70a-137">In this case, the problem is to factor the number 8704143553785700723  into a product of two prime numbers.</span></span>  <span data-ttu-id="ce70a-138">The next step involves designing an algorithm for solving this computational problem.</span><span class="sxs-lookup"><span data-stu-id="ce70a-138">The next step involves designing an algorithm for solving this computational problem.</span></span>  <span data-ttu-id="ce70a-139">In this case, Shor's famous quantum factoring algorithm can be used to find the factors.</span><span class="sxs-lookup"><span data-stu-id="ce70a-139">In this case, Shor's famous quantum factoring algorithm can be used to find the factors.</span></span>  <span data-ttu-id="ce70a-140">This algorithm is expressed in Q# and then a sequence of quantum operations is output that could be run on an idealized error-free quantum computer.</span><span class="sxs-lookup"><span data-stu-id="ce70a-140">This algorithm is expressed in Q# and then a sequence of quantum operations is output that could be run on an idealized error-free quantum computer.</span></span>  

### <a name="physical-gates"></a><span data-ttu-id="ce70a-141">Physical gates</span><span class="sxs-lookup"><span data-stu-id="ce70a-141">Physical gates</span></span>
<span data-ttu-id="ce70a-142">In this example, assume nature is not so kind as to provide an error-free quantum computer so the subsequent step takes the operations emitted by Q# and translates them using templates specified by the quantum error correction method chosen into physical gates that the basic hardware can execute.</span><span class="sxs-lookup"><span data-stu-id="ce70a-142">In this example, assume nature is not so kind as to provide an error-free quantum computer so the subsequent step takes the operations emitted by Q# and translates them using templates specified by the quantum error correction method chosen into physical gates that the basic hardware can execute.</span></span>  <span data-ttu-id="ce70a-143">This process involves replacing every logical qubit described in the previous model with a host of physical qubits that are used to store and protect the information within a single qubit in a redundant fashion that can resist local errors on the constituent physical qubits long enough for such errors to be detected and corrected.</span><span class="sxs-lookup"><span data-stu-id="ce70a-143">This process involves replacing every logical qubit described in the previous model with a host of physical qubits that are used to store and protect the information within a single qubit in a redundant fashion that can resist local errors on the constituent physical qubits long enough for such errors to be detected and corrected.</span></span>  <span data-ttu-id="ce70a-144">Just as the logical qubits described by the Q# code need to be replaced with many physical qubits, similarly each quantum gate described in the output needs to be translated into a sequence of physical gates that act upon the physical qubits.</span><span class="sxs-lookup"><span data-stu-id="ce70a-144">Just as the logical qubits described by the Q# code need to be replaced with many physical qubits, similarly each quantum gate described in the output needs to be translated into a sequence of physical gates that act upon the physical qubits.</span></span>  <span data-ttu-id="ce70a-145">For this reason, the output of Q# is seldom the final target for quantum computing and further levels of abstraction are needed to execute the code on hardware in an oblivious fashion.</span><span class="sxs-lookup"><span data-stu-id="ce70a-145">For this reason, the output of Q# is seldom the final target for quantum computing and further levels of abstraction are needed to execute the code on hardware in an oblivious fashion.</span></span>

### <a name="control-computer"></a><span data-ttu-id="ce70a-146">Control computer</span><span class="sxs-lookup"><span data-stu-id="ce70a-146">Control computer</span></span>
<span data-ttu-id="ce70a-147">The physical gate sequence is then loaded into an ordinary computer that sends these instructions down to a control computer that interfaces directly with the quantum computer.</span><span class="sxs-lookup"><span data-stu-id="ce70a-147">The physical gate sequence is then loaded into an ordinary computer that sends these instructions down to a control computer that interfaces directly with the quantum computer.</span></span>  <span data-ttu-id="ce70a-148">This layer within the software stack is often handled by experimental control software such as [QCoDeS](http://qcodes.github.io/Qcodes/).</span><span class="sxs-lookup"><span data-stu-id="ce70a-148">This layer within the software stack is often handled by experimental control software such as [QCoDeS](http://qcodes.github.io/Qcodes/).</span></span>

### <a name="interface-computer"></a><span data-ttu-id="ce70a-149">介面電腦</span><span class="sxs-lookup"><span data-stu-id="ce70a-149">Interface computer</span></span>
<span data-ttu-id="ce70a-150">此程式的最後一個步驟包括介面電腦先視需要將閘道串流至快速控制電腦。</span><span class="sxs-lookup"><span data-stu-id="ce70a-150">The final step in this process involves the interface computer first streaming the gates as needed to a fast control computer.</span></span> <span data-ttu-id="ce70a-151">然後，快速控制電腦會套用所需的電壓（通常稱為「脈衝」），以在 qubits 上執行所需的閘道。</span><span class="sxs-lookup"><span data-stu-id="ce70a-151">Then the fast control computer applies the voltages needed (commonly called pulses) to implement the required gates on qubits.</span></span> <span data-ttu-id="ce70a-152">這必須在更正透過量子錯誤更正所觀察到的任何錯誤時完成。</span><span class="sxs-lookup"><span data-stu-id="ce70a-152">This has to be done while correcting any errors that are observed through quantum error correction.</span></span>  <span data-ttu-id="ce70a-153">可能需要 Cryogenic Fpga 或其他外來硬體，才能在量子電腦出現錯誤的速率所強加的嚴格時間需求內執行這些步驟。</span><span class="sxs-lookup"><span data-stu-id="ce70a-153">Cryogenic FPGAs or other exotic hardware may be needed to perform these steps within the stringent time requirements imposed by the rate at which errors appear in the quantum computer.</span></span>  <span data-ttu-id="ce70a-154">此層級上的目的語言通常是[VHDL](https://en.wikipedia.org/wiki/VHDL)，這需要不同的思考方式，在堆疊的頂端端用來剖析量子演算法的描述。</span><span class="sxs-lookup"><span data-stu-id="ce70a-154">The target language on this level is often [VHDL](https://en.wikipedia.org/wiki/VHDL), which requires a distinct way of thinking from that which is used at the top end of the stack to parse a description of a quantum algorithm.</span></span>

### <a name="the-q-quantum-programming-language"></a><span data-ttu-id="ce70a-155">Q # 量副程式設計語言</span><span class="sxs-lookup"><span data-stu-id="ce70a-155">The Q# quantum programming language</span></span>
<span data-ttu-id="ce70a-156">問 # 的目的是要提供一種簡單的語言，讓開發人員能夠撰寫以眾多量子運算平臺為目標的程式碼，以及與使用者和量子裝置之間的仲介層軟體互動的介面。</span><span class="sxs-lookup"><span data-stu-id="ce70a-156">The aim of Q# is to provide a simple language that allows developers to write code that targets a wealth of quantum computing platforms and interface with the intervening layers of software that stand between the user and the quantum device.</span></span>  <span data-ttu-id="ce70a-157">語言藉由採用軟體堆疊的概念，並抽象化基礎量子電腦的許多詳細資料，並允許其他堆疊層級（例如C#，透過之類的語言公開）以執行必要的從 Q # 程式碼到基本作業的翻譯。</span><span class="sxs-lookup"><span data-stu-id="ce70a-157">The language facilitates this by embracing the notion of a software stack and abstracting many of the details of the underlying quantum computer while allowing other levels of the stack, exposed through a language such as C#, to perform the necessary translations from Q# code to fundamental operations.</span></span>  <span data-ttu-id="ce70a-158">這可讓開發人員專注于他們的最佳做法：設計演算法和解決問題。</span><span class="sxs-lookup"><span data-stu-id="ce70a-158">This allows the developer to focus on what they do best: designing algorithms and solving problems.</span></span>
