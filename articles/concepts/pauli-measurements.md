---
title: Pauli 測量標準 |Microsoft Docs
description: Pauli 測量
author: QuantumWriter
uid: microsoft.quantum.concepts.pauli
ms.author: nawiebe@microsoft.com
ms.date: 12/11/2017
ms.topic: article
ms.openlocfilehash: 7bea821be7e26e72f2860278486d35be676ca63d
ms.sourcegitcommit: 8becfb03eb60ba205c670a634ff4daa8071bcd06
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 10/26/2019
ms.locfileid: "73183704"
---
# <a name="pauli-measurements"></a><span data-ttu-id="91da9-103">Pauli 測量</span><span class="sxs-lookup"><span data-stu-id="91da9-103">Pauli Measurements</span></span>

<span data-ttu-id="91da9-104">在先前的討論中，我們著重于計算基礎測量。</span><span class="sxs-lookup"><span data-stu-id="91da9-104">In the previous discussions, we have focused on computational basis measurements.</span></span>  <span data-ttu-id="91da9-105">事實上，從標記的角度來看，在計量運算中所發生的其他常見測量，在計算基礎測量方面很方便表達。</span><span class="sxs-lookup"><span data-stu-id="91da9-105">In fact there are other common measurements that occur in quantum computing that, from a notational perspective, are convenient to express in terms of computational basis measurements.</span></span>  <span data-ttu-id="91da9-106">這些測量最常見的一組是*Pauli 測量*。</span><span class="sxs-lookup"><span data-stu-id="91da9-106">The most common set of these measurements are *Pauli measurements*.</span></span>  <span data-ttu-id="91da9-107">在這種情況下，通常會討論測量 Pauli 運算子，通常是 $X、Y、Z $ 或 $Z \otimes Z、X\otimes X、X\otimes Y $ 等等的運算子。</span><span class="sxs-lookup"><span data-stu-id="91da9-107">In such cases, it is common to discuss measuring a Pauli operator, in general an operator such as $X,Y,Z$ or $Z\otimes Z, X\otimes X, X\otimes Y$ and so forth.</span></span>  <span data-ttu-id="91da9-108">討論 Pauli 運算子方面的測量，特別是在量子錯誤更正的子欄位中。</span><span class="sxs-lookup"><span data-stu-id="91da9-108">Discussing measurement in terms of Pauli operators is especially common in the subfield of quantum error correction.</span></span> <span data-ttu-id="91da9-109">在 Q # 中，我們遵循類似的慣例;我們現在會說明這種替代的度量觀點。</span><span class="sxs-lookup"><span data-stu-id="91da9-109">In Q# we follow a similar convention; we now explain this alternative view of measurements.</span></span>

<span data-ttu-id="91da9-110">在探究到如何思考 Pauli 測量的詳細資料之前，請考慮測量量子電腦內的單一 qubit 對量子狀態的作用。</span><span class="sxs-lookup"><span data-stu-id="91da9-110">Before delving into the details of how to think of a Pauli measurement, it is useful to think about what measuring a single qubit inside a quantum computer does to the quantum state.</span></span>  <span data-ttu-id="91da9-111">假設我們有一個 $n $-qubit 量子狀態;然後，測量一個 qubit 會立即將該狀態所可能處於 $ 2 ^ n $ 可能性的一半。</span><span class="sxs-lookup"><span data-stu-id="91da9-111">Imagine that we have an $n$-qubit quantum state; then measuring one qubit immediately rules out half of the $2^n$ possibilities that state could be in.</span></span>  <span data-ttu-id="91da9-112">換句話說，測量會將量子狀態投射到兩個半形的其中一個。</span><span class="sxs-lookup"><span data-stu-id="91da9-112">In other words, the measurement projects the quantum state onto one of two half-spaces.</span></span>  <span data-ttu-id="91da9-113">我們可以將我們認為測量的方式一般化，以反映這種情況。</span><span class="sxs-lookup"><span data-stu-id="91da9-113">We can generalize the way we think about measurement to reflect this.</span></span>

<span data-ttu-id="91da9-114">為了簡潔地識別這些 subspaces，我們需要用來描述它們的語言。</span><span class="sxs-lookup"><span data-stu-id="91da9-114">In order to concisely identify these subspaces, we need a language for describing them.</span></span>  <span data-ttu-id="91da9-115">執行這項操作的方法之一，是透過僅具有兩個唯一特徵值的矩陣來指定兩個 subspaces，慣例是 $ \pm $1。</span><span class="sxs-lookup"><span data-stu-id="91da9-115">One way to do this is to describe the two subspaces by specifying them through a matrix that just has two unique eigenvalues, taken by convention to be $\pm 1$.</span></span>  <span data-ttu-id="91da9-116">最簡單的範例是：</span><span class="sxs-lookup"><span data-stu-id="91da9-116">The simplest example of this is:</span></span>

<span data-ttu-id="91da9-117">$ $ Z = \begin{bmatrix} 1 & 0 \\\\ 0 &-1 \end{bmatrix}。</span><span class="sxs-lookup"><span data-stu-id="91da9-117">$$ Z = \begin{bmatrix} 1 & 0 \\\\ 0 & -1 \end{bmatrix}.</span></span>
$$

<span data-ttu-id="91da9-118">$Z Pauli $ 矩陣清楚地有兩個特徵向量 $ \ket{0}$ 和 $ \ket{1}$ with 特徵值 $ \pm $1。</span><span class="sxs-lookup"><span data-stu-id="91da9-118">The Pauli-$Z$ matrix clearly has two eigenvectors $\ket{0}$ and $\ket{1}$ with eigenvalues $\pm 1$.</span></span>  <span data-ttu-id="91da9-119">因此，如果我們測量 qubit，並取得 $ \ket{0}$ 我們在 $ + $1 eigenspace 中（所有向量的集合，其組成的特徵向量總和只有正值或唯一的負特徵值），而且如果我們測量 $ \ket{1}$，我們是在 $-$1 ei 中$Z $ 的 genspace。</span><span class="sxs-lookup"><span data-stu-id="91da9-119">Thus if we measure the qubit and obtain $\ket{0}$ we are in the $+1$ eigenspace (the set of all vectors that are formed of sums of  eigenvectors with only positive or only negative eigenvalues) of the operator and if we measure $\ket{1}$ we are in the $-1$ eigenspace of $Z$.</span></span>  <span data-ttu-id="91da9-120">此程式在 Pauli 測量的語言中稱為「測量 Pauli $Z $」，完全等同于執行計算基礎測量。</span><span class="sxs-lookup"><span data-stu-id="91da9-120">This process is referred to in the language of Pauli measurements as "measuring Pauli $Z$" and is entirely equivalent to performing a computational basis measurement.</span></span>

<span data-ttu-id="91da9-121">當然，任何 $ 2 \ 1 倍的 $2 矩陣，都是 $Z $ 的單一轉換，也符合此準則。</span><span class="sxs-lookup"><span data-stu-id="91da9-121">Of course any $2\times 2$ matrix that is a unitary transformation of $Z$ also satisfies this criteria.</span></span>  <span data-ttu-id="91da9-122">這表示我們也可以考慮將矩陣 $A = U ^ \dagger Z U $ （針對任何單一矩陣 $U $）提供一個矩陣，在其 $ \pm $1 特徵向量中定義度量的兩個結果。</span><span class="sxs-lookup"><span data-stu-id="91da9-122">This is to say that we could also consider matrix $A=U^\dagger Z U$, for any unitary matrix $U$, to give a matrix that defines the two outcomes of a measurement in its $\pm 1$ eigenvectors.</span></span>  <span data-ttu-id="91da9-123">Pauli 量值的標記法會藉由將 $X、Y、Z $ 測量值識別為對等的測量，以取得 qubit 中的資訊。</span><span class="sxs-lookup"><span data-stu-id="91da9-123">The notation of Pauli measurements references this by identifying $X,Y,Z$ measurements as equivalent measurements that one could do to gain information from a qubit.</span></span>  <span data-ttu-id="91da9-124">為了方便起見，以下提供這些測量。</span><span class="sxs-lookup"><span data-stu-id="91da9-124">These measurements are given below for convenience.</span></span>

<span data-ttu-id="91da9-125">$ $ \begin{array}{| c | c |} \text{Pauli 量測} & U\\\\ Z & \boldone\\\\ X & H\\\\ Y & HS ^ \dagger\\\\ \end{array} $ $</span><span class="sxs-lookup"><span data-stu-id="91da9-125">$$ \begin{array}{|c|c|} \text{Pauli Measurement} & U\\\\ Z & \boldone\\\\ X & H\\\\ Y & HS^\dagger\\\\ \end{array} $$</span></span>

<span data-ttu-id="91da9-126">也就是說，使用這種語言，「量值 $Y $」等同于套用 $HS ^ \dagger $，然後以計算為基礎來測量，其中 $S $ 是所謂的階段閘道，由</span><span class="sxs-lookup"><span data-stu-id="91da9-126">That is, using this language, "measure $Y$" is equivalent to applying $HS^\dagger$ and then measuring in the computational basis, where $S$ is the so-called phase gate given by</span></span>

<span data-ttu-id="91da9-127">$ $ \begin{bmatrix}1 & 0\\\\ 0 & i\end {bmatrix}。</span><span class="sxs-lookup"><span data-stu-id="91da9-127">$$ \begin{bmatrix}1 &0\\\\  0&i\end{bmatrix}.</span></span>
$$

<span data-ttu-id="91da9-128">這也相當於將 $HS ^ \dagger $ 套用至量子狀態向量，然後測量 $Z $。</span><span class="sxs-lookup"><span data-stu-id="91da9-128">It is also equivalent to applying $HS^\dagger$ to the quantum state vector and then measuring $Z$.</span></span>  <span data-ttu-id="91da9-129">接著，轉換回計算基礎，即可找到正確的狀態，這是將 $SH $ 套用至量子狀態向量的數量。</span><span class="sxs-lookup"><span data-stu-id="91da9-129">The correct state would then be found by transforming back to the computational basis, which amounts to applying $SH$ to the quantum state vector.</span></span>

## <a name="q-outcome-classical-information-obtained-from-quantum-state"></a><span data-ttu-id="91da9-130">從量子狀態取得的 Q # 結果傳統資訊</span><span class="sxs-lookup"><span data-stu-id="91da9-130">Q# outcome classical information obtained from quantum state</span></span>
<span data-ttu-id="91da9-131">在 Q # 中，我們假設結果（也就是從與狀態互動時所解壓縮的傳統資訊）是 $j $ （如果是在 Pauli 運算子的 $ （-1） ^ j $ eigenspace 中），而這是在設定 $\{0，1\}$ 中。</span><span class="sxs-lookup"><span data-stu-id="91da9-131">In Q# we say the outcome, i.e., the classical information extracted from interacting with the state, is $j$ which is in the set $\{0,1\}$ if the result is in the $(-1)^j$ eigenspace of the Pauli operator measured.</span></span>

<span data-ttu-id="91da9-132">多 qubit Pauli 運算子的度量定義類似，如下所示：</span><span class="sxs-lookup"><span data-stu-id="91da9-132">Measurements of multi-qubit Pauli operators are defined similarly, as seen from:</span></span>

<span data-ttu-id="91da9-133">$ $ Z\otimes Z = \begin{bmatrix}1 & 0 & 0 & 0\\\\ 0 &-1 & 0 & 0\\\\ 0 & 0 &-1 & 0\\\\ 0 & 0 & 0 & 1 \ end {bmatrix}。</span><span class="sxs-lookup"><span data-stu-id="91da9-133">$$ Z\otimes Z = \begin{bmatrix}1 &0 &0&0\\\\  0&-1&0&0\\\\ 0&0&-1&0\\\\ 0&0&0&1\end{bmatrix}.</span></span>
$$

<span data-ttu-id="91da9-134">因此，兩個 Pauli $Z $ 運算子的張量產品會形成一個矩陣，其中包含由 $ + $1 和 $-$1 特徵值組成的兩個空格。</span><span class="sxs-lookup"><span data-stu-id="91da9-134">Thus the tensor products of two Pauli-$Z$ operators forms a matrix composed of two spaces consisting of $+1$ and $-1$ eigenvalues.</span></span>  <span data-ttu-id="91da9-135">就像單一 qubit 的情況一樣，兩者都構成一半空間，這表示可存取的兩個向量空間一半屬於 $ + $1 eigenspace，而其餘一半則是 $-$1 eigenspace。</span><span class="sxs-lookup"><span data-stu-id="91da9-135">As with the single-qubit case, both constitute a half-space meaning that half of the accessible vector space belongs to the $+1$ eigenspace and the remaining half to the $-1$ eigenspace.</span></span>  <span data-ttu-id="91da9-136">一般來說，您可以從張量產品的定義中查看 Pauli-$Z $ operators 的任何張量產品，以及身分識別也會遵守這項功能。</span><span class="sxs-lookup"><span data-stu-id="91da9-136">In general, it is easy to see from the definition of the tensor product that any tensor product of Pauli-$Z$ operators and the identity also obeys this.</span></span>  <span data-ttu-id="91da9-137">例如，</span><span class="sxs-lookup"><span data-stu-id="91da9-137">For example,</span></span>

<span data-ttu-id="91da9-138">$ $ Z\otimes\boldone = \begin{bmatrix} 1 & 0 & 0 & 0\\\\ 0 & 1 & 0 & 0\\\\ 0 & 0 &-1 & 0\\\\ 0 & 0 & 0 &-1 \ end {bmatrix}。</span><span class="sxs-lookup"><span data-stu-id="91da9-138">$$ Z\otimes\boldone=\begin{bmatrix} 1&0&0&0\\\\  0&1&0&0\\\\  0&0&-1&0\\\\ 0&0&0&-1\end{bmatrix}.</span></span>
$$

<span data-ttu-id="91da9-139">如前所述，這類矩陣的任何單一轉換也會描述由 $ \pm $1 特徵值標記的兩個半形。</span><span class="sxs-lookup"><span data-stu-id="91da9-139">As before, any unitary transformation of such matrices also describes two half-spaces labeled by $\pm 1$ eigenvalues.</span></span>  <span data-ttu-id="91da9-140">例如，從 $Z = HXH $ 的身分識別 $X \otimes X = H\otimes H （Z\otimes Z） H\otimes H $。</span><span class="sxs-lookup"><span data-stu-id="91da9-140">For example, $X\otimes X = H\otimes H(Z\otimes Z)H\otimes H$  from the identity that $Z=HXH$.</span></span>  <span data-ttu-id="91da9-141">與一個 qubit 的案例類似，所有的雙 qubit Pauli 量值都可以撰寫為 $U ^ \dagger （Z\otimes \id） U $ （適用于 $ 4 \ 次 $4 單一矩陣 $U $）。</span><span class="sxs-lookup"><span data-stu-id="91da9-141">Similar to the one-qubit case, all two-qubit Pauli-measurements can be written as $U^\dagger (Z\otimes \id) U$ for $4\times 4$ unitary matrices $U$.</span></span>  <span data-ttu-id="91da9-142">我們會列舉下表中的轉換，為方便起見，交換閘道會交換 qubits $0 $ 和 $1 $： $ \operatorname{SWAP} = \operatorname{CNOT}\_{01}\operatorname{CNOT}\_{10}\operatorname{CNOT-CONTAINS}\_{01}$：</span><span class="sxs-lookup"><span data-stu-id="91da9-142">We enumerate the transformations in the following table where we introduce for convenience the swap gate which swaps qubits $0$ and $1$: $\operatorname{SWAP}=\operatorname{CNOT}\_{01}\operatorname{CNOT}\_{10}\operatorname{CNOT}\_{01}$:</span></span>

<span data-ttu-id="91da9-143">$ $ \begin{array}{| c | c |} \text{Pauli 測量} & U\\\\ \hline Z\otimes \boldone & \boldone\otimes \boldone\\\\ X\otimes \boldone & H\otimes \boldone\\\\ Y\otimes \boldone & HS ^ \dagger\otimes \boldone\\\\ \boldone \otimes Z & \operatorname{SWAP}\\\\ \boldone \otimes X & （H\otimes \boldone） \operatorname{SWAP}\\\\ \boldone \otimes Y & （HS ^ \dagger\otimes \boldone） \運算子名稱 {SWAP}\\\\ Z\otimes Z & \operatorname{CNOT}\_{10}\\\\ X\otimes Z & \operatorname{CNOT}\_{10}（H\otimes \boldone）\\\\ Y\otimes Z & \運算子名稱 {CNOT-CONTAINS}\_{10}（HS ^ \dagger\otimes \boldone）\\\\ Z\otimes X & \operatorname{CNOT}\_{10}（\boldone\otimes H）\\\\ X\otimes X & \operatorname{CNOT}\_{10}（H\otimes H）\\\\ Y\otimes X & \operatorname{CNOT}\_{10}（HS ^ \dagger\otimes H）\\\\ Z\otimes Y & \operatorname{CNOT}\_{10}（\boldone \otimes HS ^ \dagger）\\\\ X\otimes Y & \operatorname{CNOT}\_{10}（H\otimes HS ^ \dagger）\\\\ Y\otimes Y & \operatorname{CNOT}\_{10}（HS ^ \dagger\otimes HS ^ \dagger）\\\\ \end{array} $ $</span><span class="sxs-lookup"><span data-stu-id="91da9-143">$$ \begin{array}{|c|c|} \text{Pauli Measurement} & U\\\\ \hline Z\otimes \boldone & \boldone\otimes \boldone\\\\ X\otimes \boldone & H\otimes \boldone\\\\ Y\otimes \boldone & HS^\dagger\otimes \boldone\\\\ \boldone \otimes Z & \operatorname{SWAP}\\\\ \boldone \otimes X & (H\otimes \boldone)\operatorname{SWAP}\\\\ \boldone \otimes Y & (HS^\dagger\otimes \boldone)\operatorname{SWAP}\\\\ Z\otimes Z & \operatorname{CNOT}\_{10}\\\\ X\otimes Z & \operatorname{CNOT}\_{10}(H\otimes \boldone)\\\\ Y\otimes Z & \operatorname{CNOT}\_{10}(HS^\dagger\otimes \boldone)\\\\ Z\otimes X & \operatorname{CNOT}\_{10}(\boldone\otimes H)\\\\ X\otimes X & \operatorname{CNOT}\_{10}(H\otimes H)\\\\ Y\otimes X & \operatorname{CNOT}\_{10}(HS^\dagger\otimes H)\\\\ Z\otimes Y & \operatorname{CNOT}\_{10}(\boldone \otimes HS^\dagger)\\\\ X\otimes Y & \operatorname{CNOT}\_{10}(H\otimes HS^\dagger)\\\\ Y\otimes Y & \operatorname{CNOT}\_{10}(HS^\dagger\otimes HS^\dagger)\\\\ \end{array} $$</span></span>

<span data-ttu-id="91da9-144">這裡會出現閘道 $ \operatorname{CNOT}\_{10}$，原因如下。</span><span class="sxs-lookup"><span data-stu-id="91da9-144">Here the gate $\operatorname{CNOT}\_{10}$ appears for the following reason.</span></span>  <span data-ttu-id="91da9-145">不包含 $ \boldone $ 矩陣的每個 Pauli 量值，都相當於單一的，以由上述推理 $Z \otimes Z $。</span><span class="sxs-lookup"><span data-stu-id="91da9-145">Each Pauli measurement that does not include the $\boldone$ matrix is equivalent up to a unitary to $Z\otimes Z$ by the above reasoning.</span></span>  <span data-ttu-id="91da9-146">$Z \otimes Z $ 的特徵值僅取決於組成每個計算基礎向量的 qubits 同位檢查，而此清單中所顯示的受控制-非作業則是用來計算此同位，並將其儲存在第一位。</span><span class="sxs-lookup"><span data-stu-id="91da9-146">The eigenvalues of $Z\otimes Z$ only depend on the parity of the qubits that comprise each computational basis vector and the controlled-not operations that appear in this list serve to compute this parity and store it in the first bit.</span></span>  <span data-ttu-id="91da9-147">然後在測量第一個位之後，我們就可以復原所產生的半空間識別，這相當於測量 Pauli 運算子。</span><span class="sxs-lookup"><span data-stu-id="91da9-147">Then once the first bit is measured, we can recover the identity of the resultant half-space which is equivalent to measuring the Pauli operator.</span></span>

<span data-ttu-id="91da9-148">另外還有一點要注意的是，假設測量 $Z \otimes Z $ 的量值與測量 $Z \otimes \id $ 和 $ \id \otimes Z $ 相同，這項假設會是 false。</span><span class="sxs-lookup"><span data-stu-id="91da9-148">One additional note, while it may be tempting to assume that measuring $Z\otimes Z$ is the same as measuring $Z\otimes \id$ and then $\id \otimes Z$, this assumption would be false.</span></span>  <span data-ttu-id="91da9-149">原因是測量 $Z \otimes Z $ 將量子狀態投射到這些運算子的 $ + $1 或 $-$1 eigenstate 中。</span><span class="sxs-lookup"><span data-stu-id="91da9-149">The reason is that measuring $Z\otimes Z$ projects the quantum state into either the $+1$ or $-1$ eigenstate of these operators.</span></span>  <span data-ttu-id="91da9-150">測量 $Z \otimes \id $ 然後 $ \id \otimes Z $ 會先將量子狀態向量投射到 $Z \otimes \id $ 的一半空間，然後再到 $ \id \otimes Z $ 的半形。</span><span class="sxs-lookup"><span data-stu-id="91da9-150">Measuring $Z\otimes \id$ and then $\id \otimes Z$ projects the quantum state vector first onto a half space of $Z\otimes \id$ and then onto a half space of $\id \otimes Z$.</span></span>  <span data-ttu-id="91da9-151">因為有四個計算基礎的向量，同時執行這兩個度量會將狀態縮減為四分之一空間，因而減少為單一計算基礎向量。</span><span class="sxs-lookup"><span data-stu-id="91da9-151">As there are four computational basis vectors, performing both measurements reduces the state to a quarter-space and hence reduces it to a single computational basis vector.</span></span>


## <a name="correlations-between-qubits"></a><span data-ttu-id="91da9-152">Qubits 之間的相互關聯</span><span class="sxs-lookup"><span data-stu-id="91da9-152">Correlations between qubits</span></span>
<span data-ttu-id="91da9-153">另一個查看 Paulis 張量產品（例如 $X \otimes X $ 或 $Z \otimes Z $）的方法，就是這些測量可讓您查看儲存在兩個 qubits 之間關聯性的資訊。</span><span class="sxs-lookup"><span data-stu-id="91da9-153">Another way of looking at measuring tensor products of Paulis such as $X\otimes X$ or $Z\otimes Z$ is that these measurements let you look at information stored in the correlations between the two qubits.</span></span>  <span data-ttu-id="91da9-154">測量 $X \otimes \id $，可讓您查看本機儲存在第一個 qubit 中的資訊。</span><span class="sxs-lookup"><span data-stu-id="91da9-154">Measuring $X\otimes \id$ lets you look at information that is locally stored in the first qubit.</span></span>  <span data-ttu-id="91da9-155">雖然這兩種類型的測量在量子運算中也同樣有價值，但前者也會照亮量子運算的威力。</span><span class="sxs-lookup"><span data-stu-id="91da9-155">While both types of measurements are equally valuable in quantum computing, the former illuminates the power of quantum computing.</span></span> <span data-ttu-id="91da9-156">它會發現，在量子運算中，您想要學習的資訊通常不會儲存在任何單一 qubit 中，而是會一次儲存在所有 qubits 中，而只是透過搭配 $Z \otimes Z $ 的結合測量來進行，這項資訊會變成清單.</span><span class="sxs-lookup"><span data-stu-id="91da9-156">It reveals that in quantum computing often the information you wish to learn is not stored in any single qubit but rather stored non-locally in all the qubits at once, and only by looking at it through a joint measurement with $Z\otimes Z$ does this information become manifest.</span></span>

<span data-ttu-id="91da9-157">您也可以測量任意的 Pauli 運算子，例如 $X \otimes Y \otimes Z \otimes \boldone $。</span><span class="sxs-lookup"><span data-stu-id="91da9-157">Arbitrary Pauli operators such as $X\otimes Y \otimes Z \otimes \boldone$ can also be measured.</span></span>  <span data-ttu-id="91da9-158">Pauli 運算子的所有這類張量產品只有兩個特徵值 $ \pm $1，而這兩個 eigenspaces 構成整個向量空間的半個空格。</span><span class="sxs-lookup"><span data-stu-id="91da9-158">All such tensor products of Pauli operators have only two eigenvalues $\pm 1$ and both eigenspaces constitute half-spaces of the entire vector space.</span></span>  <span data-ttu-id="91da9-159">因此，它們會符合上面所述的需求。</span><span class="sxs-lookup"><span data-stu-id="91da9-159">Thus they coincide with the requirements stated above.</span></span>

<span data-ttu-id="91da9-160">在 Q # 中，這類測量結果會在 eigenspace 中產生正負號 $ （-1） ^ j $ 的值時，傳回 $j $。</span><span class="sxs-lookup"><span data-stu-id="91da9-160">In Q#, such measurements return $j$ if the measurement yields a result in the eigenspace of sign $(-1)^j$.</span></span>  <span data-ttu-id="91da9-161">將此項當做 Q # 內建功能很有説明，因為測量這類運算子時，需要長鏈的受控制（而非閘道和基礎轉換）來描述將作業當做 $Z $ 和 $ \id $ 的張量產品來表達作業所需的 diagonalizing $U $ 閘道。</span><span class="sxs-lookup"><span data-stu-id="91da9-161">Having this as a built-in feature in Q# is helpful because measuring such operators requires long chains of controlled-NOT gates and basis transformations to describe the diagonalizing $U$ gate needed to express the operation as a tensor product of $Z$ and $\id$.</span></span>  <span data-ttu-id="91da9-162">只要能夠指定您想要執行其中一項預先定義的測量，就不需要擔心如何轉換基礎，讓計算基礎測量提供必要的資訊。</span><span class="sxs-lookup"><span data-stu-id="91da9-162">By simply being able to specify that you wish to do one of these pre-defined measurements, you don't need to worry about how to transform your basis such that a computational basis measurement provides the necessary information.</span></span>  <span data-ttu-id="91da9-163">問 # 會自動為您處理所有必要的基礎轉換。</span><span class="sxs-lookup"><span data-stu-id="91da9-163">Q# handles all the necessary basis transformations for you automatically.</span></span> <span data-ttu-id="91da9-164">請參閱[Pauli 測量的 Q # 程式庫參考](/qsharp/api/canon/microsoft.quantum.canon.measurepaulis)</span><span class="sxs-lookup"><span data-stu-id="91da9-164">See [Q# library reference for Pauli measurements](/qsharp/api/canon/microsoft.quantum.canon.measurepaulis)</span></span>

## <a name="the-no-cloning-theorem"></a><span data-ttu-id="91da9-165">無複製定理</span><span class="sxs-lookup"><span data-stu-id="91da9-165">The No-Cloning Theorem</span></span>
<span data-ttu-id="91da9-166">量子資訊功能強大。</span><span class="sxs-lookup"><span data-stu-id="91da9-166">Quantum information is powerful.</span></span>  <span data-ttu-id="91da9-167">這讓我們能夠執行令人驚奇的事，像是以指數方式比最佳的傳統演算法更快，或有效率地模擬傳統方式需要指數成本才能正確模擬的相互關聯 electron 系統。</span><span class="sxs-lookup"><span data-stu-id="91da9-167">It enables us to do amazing things such as factor numbers exponentially faster than the best known classical algorithms, or efficiently simulate correlated electron systems that classically require exponential cost to simulate accurately.</span></span>  <span data-ttu-id="91da9-168">不過，配量運算的功能有一些限制。</span><span class="sxs-lookup"><span data-stu-id="91da9-168">However, there are limitations to the power of quantum computing.</span></span>  <span data-ttu-id="91da9-169">其中一項限制是由*無複製定理*所提供。</span><span class="sxs-lookup"><span data-stu-id="91da9-169">One such limitation is given by the *No-Cloning Theorem*.</span></span>

<span data-ttu-id="91da9-170">未複製的定理是名為的恰如其。</span><span class="sxs-lookup"><span data-stu-id="91da9-170">The No-Cloning Theorem is aptly named.</span></span>
<span data-ttu-id="91da9-171">它不允許由量子電腦複製一般量子狀態。</span><span class="sxs-lookup"><span data-stu-id="91da9-171">It disallows cloning of generic quantum states by a quantum computer.</span></span>
<span data-ttu-id="91da9-172">定理證明十分簡單。</span><span class="sxs-lookup"><span data-stu-id="91da9-172">The proof of the theorem is remarkably straightforward.</span></span>
<span data-ttu-id="91da9-173">雖然不復制定理的完整證明在本文的討論方面有點技術性，但在有問題的量子電腦沒有其他 ancilla qubits 的情況下，定理的證明也在我們的範圍內（ancilla qubits 是用於全新 qubits計算期間的空間，並可在 Q # 中輕鬆使用和管理，請參閱 <xref:microsoft.quantum.techniques.qubits>）。</span><span class="sxs-lookup"><span data-stu-id="91da9-173">While a full proof of the no-cloning theorem is a little too technical for our discussion here, the proof of the theorem in the case where the quantum computer in question has no additional ancilla qubits is within our scope (ancilla qubits are qubits used for scratch space during a computation and are easily used and managed in Q#, see <xref:microsoft.quantum.techniques.qubits>).</span></span>
<span data-ttu-id="91da9-174">對於這類的量子電腦，複製作業必須是單一矩陣。</span><span class="sxs-lookup"><span data-stu-id="91da9-174">For such a quantum computer, the cloning operation must be a unitary matrix.</span></span> <span data-ttu-id="91da9-175">我們不允許測量，因為它會損毀我們嘗試要複製的量子狀態。</span><span class="sxs-lookup"><span data-stu-id="91da9-175">We disallow measurement, since it would corrupt the quantum state we are trying to clone.</span></span> <span data-ttu-id="91da9-176">我們想要的單一矩陣必須有 $ $ U \ket{\psi} \ket 的屬性，{0} = \ket{\psi} \ket{\psi}，$ $ 適用于任何 state $ \ket{\psi} $。</span><span class="sxs-lookup"><span data-stu-id="91da9-176">The unitary matrix we want must have the property that $$ U \ket{\psi} \ket{0} = \ket{\psi} \ket{\psi}, $$ for any state $\ket{\psi}$.</span></span>
<span data-ttu-id="91da9-177">矩陣乘法的線性屬性會暗示任何第二個配量狀態 $ \ket{\phi} $，</span><span class="sxs-lookup"><span data-stu-id="91da9-177">The linearity property of matrix multiplication then implies that for any second quantum state $\ket{\phi}$,</span></span>

<span data-ttu-id="91da9-178">\begin{align} & U\left [\frac{1}{\sqrt{2}} \left （\ket{\phi} + \ket{\psi} \right） \right] \ket{0}= \frac{1}{\sqrt{2}} U\ket {\ phi} \ ket{0}+ \frac{1}{\sqrt{2}} U\ket {\ psi} \ ket{0}\\\\ & \qquad\qquad = \frac{1}{\sqrt{2}} \left （\ket{\phi}\ket{\phi} + \ket{\psi}\ket{\psi}\right）\\\\ & \qquad\qquad\ne \left （\frac{1}{\sqrt{2}} \left （\ket{\phi} + \ket{\psi} \right） \right） \otimes\left （\frac{1}{\sqrt{2}} \left （\ket{\phi} + \ket{\psi} \right） \right）。</span><span class="sxs-lookup"><span data-stu-id="91da9-178">\begin{align} &U\left[\frac{1}{\sqrt{2}}\left(\ket{\phi}+\ket{\psi} \right)\right]\ket{0}=\frac{1}{\sqrt{2}}U\ket{\phi}\ket{0}+\frac{1}{\sqrt{2}}U\ket{\psi}\ket{0}\\\\ &\qquad\qquad=\frac{1}{\sqrt{2}}\left(\ket{\phi}\ket{\phi}+\ket{\psi}\ket{\psi}\right)\\\\ &\qquad\qquad\ne \left(\frac{1}{\sqrt{2}}\left(\ket{\phi}+\ket{\psi} \right)\right)\otimes\left(\frac{1}{\sqrt{2}}\left(\ket{\phi}+\ket{\psi} \right)\right).</span></span>
<span data-ttu-id="91da9-179">\end{align}</span><span class="sxs-lookup"><span data-stu-id="91da9-179">\end{align}</span></span>

<span data-ttu-id="91da9-180">這提供了不復制定理背後的基礎直覺：任何複製不明量子狀態的裝置，都必須在其複製的至少部分狀態中引發錯誤。</span><span class="sxs-lookup"><span data-stu-id="91da9-180">This provides the fundamental intuition behind the No-Cloning Theorem: any device that copies an unknown quantum state must induce errors on at least some of the states it copies.</span></span>  <span data-ttu-id="91da9-181">雖然 cloner 的關鍵假設是透過新增 ancilla qubits 的 ancilla 和測量，因而違反了輸入狀態，但這類互動也會透過測量統計資料來流失系統的相關資訊，並防止在這種情況下也會進行精確的複製。</span><span class="sxs-lookup"><span data-stu-id="91da9-181">While the key assumption that the cloner acts linearly on the input state can be violated through the addition of ancilla and measurement of the ancilla qubits, such interactions also leak information about the system through the measurement statistics and prevent exact cloning in such cases as well.</span></span>  <span data-ttu-id="91da9-182">如需更完整的無複製定理證明，請參閱[以取得詳細資訊](xref:microsoft.quantum.more-information)。</span><span class="sxs-lookup"><span data-stu-id="91da9-182">For a more complete proof of the No-Cloning Theorem see [For more information](xref:microsoft.quantum.more-information).</span></span>

<span data-ttu-id="91da9-183">無複製定理對於區分量子運算而言非常重要，因為如果您可以在較低的情況中複製配量狀態，則會被授與從配量狀態學習的近乎神奇功能。</span><span class="sxs-lookup"><span data-stu-id="91da9-183">The No-Cloning Theorem is important for qualitative understanding of quantum computing because if you could clone quantum states inexpensively then you would be granted a near-magical ability to learn from quantum states.</span></span>  <span data-ttu-id="91da9-184">事實上，您可能違反了海森堡的 vaunted 不確定性原則。</span><span class="sxs-lookup"><span data-stu-id="91da9-184">Indeed, you could violate Heisenberg's vaunted uncertainty principle.</span></span>  <span data-ttu-id="91da9-185">或者，您可以使用最佳的 cloner 從複雜的配量散發取得單一範例，並瞭解您可能會從一個範例中瞭解該散發的所有資訊。</span><span class="sxs-lookup"><span data-stu-id="91da9-185">Alternatively, you could use an optimal cloner to take a single sample from a complex quantum distribution and learn everything you could possibly learn about that distribution from just one sample.</span></span>  <span data-ttu-id="91da9-186">這就像是您翻轉一硬幣和觀察列印頭，然後告訴朋友有關結果的回應「，該硬幣的散佈必須以 $p = 0.512643 \ ldots $！</span><span class="sxs-lookup"><span data-stu-id="91da9-186">This would be like you flipping a coin and observing heads and then upon telling a friend about the result having them respond "Ah the distribution of that coin must be Bernoulli with $p=0.512643\ldots$!"</span></span>  <span data-ttu-id="91da9-187">這類語句不會 sensical，因為有一小部分的資訊（列印頭結果）無法提供編碼散發所需的許多資訊，而不需要大量的先前資訊。</span><span class="sxs-lookup"><span data-stu-id="91da9-187">Such a statement would be non-sensical because one bit of information (the heads outcome) simply cannot provide the many bits of information needed to encode the distribution without substantial prior information.</span></span>  <span data-ttu-id="91da9-188">同樣地，如果沒有先前的資訊，我們就無法完全複製配量狀態，因為我們無法準備集團這類的硬幣，而不需要知道 $p $。</span><span class="sxs-lookup"><span data-stu-id="91da9-188">Similarly, without prior information we cannot perfectly clone a quantum state just as we cannot prepare an ensemble of such coins without knowing $p$.</span></span>

<span data-ttu-id="91da9-189">在量子運算中，資訊不是免費的。</span><span class="sxs-lookup"><span data-stu-id="91da9-189">Information is not free in quantum computing.</span></span>  <span data-ttu-id="91da9-190">每個 qubit 都有提供一項資訊，而不復制定理顯示沒有任何後門可被利用，來解決系統與在其上叫用之騒之間的基本取捨。</span><span class="sxs-lookup"><span data-stu-id="91da9-190">Each qubit measured gives a single bit of information, and the No-Cloning Theorem shows that there is no backdoor that can be exploited to get around the fundamental tradeoff between information gained about the system and the disturbance invoked upon it.</span></span>

