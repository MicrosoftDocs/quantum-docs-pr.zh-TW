---
title: QDK 0.3 語言審查與遷移指南
description: '說明 Microsoft Quantum Development Kit 0.3 中的新功能，以及如何遷移現有的 Q # 程式。'
author: beheim
uid: microsoft.quantum.relnotes.migration-0-3
ms.author: bettina.heim@microsoft.com
ms.date: 10/29/2018
ms.topic: article
ms.openlocfilehash: df86bf163a300c1ce55d3959bd40aea3d8b8a973
ms.sourcegitcommit: 6ccea4a2006a47569c4e2c2cb37001e132f17476
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 02/28/2020
ms.locfileid: "77907727"
---
# <a name="qdk-03-language-release-notes-and-migration-guide"></a>QDK 0.3 語言版本資訊和遷移指南

我們很興奮地引進了最新的量子開發工具組更新。  本頁概述新的 Q # 語言功能，並說明如何將現有的 Q # 程式[遷移](#Migration)至新的語法。  如需 Q [# 語言的](xref:microsoft.quantum.language.intro)完整說明，請參閱我們的完整檔。


## <a name="whats-new"></a>新功能 

0\.3 更新隨附一系列的新語言和編輯器功能。

### <a name="overview-of-features"></a>功能總覽

- Visual Studio 和 Visual Studio Code 的增強型開發工具整合，包括：
    - 即時編譯和輸入意見反應（*也稱為* 波浪底線）。
    - 暫留資訊，包括檔摘要和類型簽章。
    - [移至定義] 的支援。
    - 輕鬆流覽命名空間、作業、函數和類型宣告。
    - 改善的診斷訊息。
- 語言改進
    - 使用和借用中的單一 qubit 和元組初始化
    - 所有指派的元組解構
    - 針對陣列的反復專案
    - 條件運算式
    - 預設值-作業的特製化縮寫
    - 自動產生的型別構造函式
    - 運算式修飾詞


## <a name="editor-features"></a>編輯器功能

量子開發工具組現在包含適用于 Q # 的語言伺服器，以及 Visual Studio 和 Visual Studio Code 的用戶端整合。
這會啟用一組新的 IntelliSense 功能，以及以波狀底線的形式輸入錯誤和警告的即時反饋。
特別的是，現在支援 [移至定義]，並顯示包含類型資訊的暫留資訊，以及記錄批註的資訊。 此外，已定義的命名空間、作業、函數和類型的符號資訊可供使用，並可讓您快速流覽至宣告。    
整體而言，這項更新可讓您輕鬆瀏覽至精確的診斷範圍，並且在顯示的暫留資訊中提供其他詳細資料，而大幅改善了診斷訊息。 

在此0.3 版本中，配量開發工具組所包含的語言伺服器不支援多個工作區。
為了在 VS Code 中使用專案，請開啟包含專案本身和所有參考專案的根資料夾。
若要在 Visual Studio 中使用解決方案，解決方案中包含的所有專案必須位於與解決方案相同的資料夾中，或解決方案的其中一個子資料夾中。

## <a name="language-features"></a>語言功能

就語言功能而言，此更新會將各種語言模式的處理方式統一。
例如，會針對每個使用者定義型別產生型別構造函式，而且可以部分套用，就像任何其他函數一樣。
另一個範例是元組解構，其現在已在所有指派中受到完整支援。 這不僅包含 let、mutable 和 set 語句，也包括 for 迴圈中的反復專案變數，以及使用-和借用-配置。 此外，使用0.3 更新時，會新支援部分解構;解構中的底線表示要忽略的值部分。 

下列程式碼說明一些新功能：
```qsharp
    let tuples = [(1, 0), (0, 1)];
    mutable res = (0, 0, 0);

    // For-loops can iterate over arrays, and can destructure tuples.
    for ((i1, i2) in tuples) {

        // Mutable assignments can now destructure and ignore parts of tuples,
        // using the same syntax as let-bindings.
        mutable (r1, r2, _) = res;
        set (r1, r2) = (r1 ||| i1, r2 &&& i2);

        let (_, _, s) = res;
        // The new conditional operator can be used inside expressions, avoiding
        // the need for extraneous if-statements.
        set res = (r1, r2, r1 == r2 ? s | s + 1);
    }
```
最後一個 set 語句使用0.3 更新引進的新三元運算子，以支援條件運算式。
條件運算式是 `condition ? caseTrue | caseFalse`格式的運算式。
如上述範例所示，現在也支援透過陣列的反復專案。

`using` 和 `borrowing` 內的配置是針對單一 qubits、qubit 陣列和下列兩者的嵌套元組提供新的：
```qsharp
    using (qubit = Qubit()) {
        // qubit contains a single qubit
    }

    borrowing ((qubits, qubit) = (Qubit[3], Qubit())) {
        // qubits contains an array of three qubits, and qubit contains a single qubit
    }
```

除了引進 `auto` 之外，還有兩個新的特製化產生器指示詞 `invert` 和 `distribute`，以提高控制仿函數特製化的產生方式。
作業中預設 `body` 特製化的明確宣告已不再是強制性的。
與函式類似，如果在作業中未宣告任何其他特製化，語句可能會直接加入作業宣告本身。
發行中包含一個遷移腳本，可協助您遷移現有的程式碼，並利用新的語言功能（請參閱[有關遷移腳本的一節](#MigrationScript)）。

如何處理使用者自訂類型的重大變更會隨附于0.3 更新。 雖然先前的版本會將使用者定義型別視為其基礎類型的子類型，但這不再是未來的情況（另請參閱[有關重大變更的一節](#BreakingChanges)）。  
在這項變更中，我們引進了可套用至特定運算式的運算式修飾詞。 修飾詞可以套用至的「不可部分完成」運算式包括識別碼、陣列專案運算式和 arity-1 元組。
修飾詞的系結比其他任何運算式結合更緊密，特別是比呼叫運算式結合 `(` `)`更緊密。 
`Adjoint`、`Controlled`和新的「解除包裝」後置運算子 `!` 會被視為運算式修飾詞。 將 `Adjoint` 和 `Controlled` 視為運算式修飾詞，就不需要括弧來進行許多案例。 例如，下列運算式適用于 `Op`、單一作業、`opArr` 單一作業的陣列，以及 `arg` 適當的引數： 
```qsharp
    Adjoint Op (arg);
    Controlled opArr[i] (arg);
```
遷移腳本會捨棄大部分不必要的括弧，並充分利用新功能。 不過，請注意，腳本不會解讀程式碼，而且不會考慮在罕見的情況下，`Controlled` 仿函數的不同轉譯（僅與部分應用程式相關）。

New 修飾詞 `!` 會將使用者定義型別轉換成其基礎型別。 這項轉換已被視為先前版本中的向上轉型，而且已自動執行。 有了使用者定義型別的新解讀之後，就不再是這種情況，而且必須明確地進行轉換。    
下列範例說明如何使用新的修飾詞： 
```qsharp
    newtype Unitary = (Qubit => Unit: Adjoint, Controlled);

    operation Foo (unitaries : Unitary[], qubit : Qubit) : Unit {

        for (unitary in unitaries[1 .. Length(unitaries)-1]) {
            // Each element of unitaries is an instance of the user-defined
            // type Unitary, so unitary! unwraps each element to an operation
            // type that we can call.
            unitary! (qubit);
            // The unwrap operator can also be used as a part of functor
            // expressions and when indexing into arrays.
            Adjoint unitary! (qubit);
            Adjoint unitaries[0]! (qubit);
        }
    }
```
如範例所示，`!` 系結比前置詞修飾詞更緊密，例如 `Controlled` 和 `Adjoint`。

## <a name="BreakingChanges"></a>重大變更 

0\.3 更新隨附新的編譯器，並包含一些重大變更。
為了方便更新現有的程式碼，編譯器也會提供格式設定選項，以編譯有效或不正確程式碼，並根據建立的編譯發出格式化的 Q # 程式碼。
所有語法變更都會由提供的工具自動處理。 不過，可能需要手動進行有效程式碼的轉譯方式變更（語義變更）。 

除了下面所列的變更以外，模式 `__*__`，其中 * 是任何非空白字元序列都會保留供內部使用，而且不能當做符號名稱使用。  

## <a name="syntax-changes"></a>語法變更 

- 從0.3 版開始，陣列專案不再以分號分隔，而是以逗號分隔。
- 另一方面，在特製化宣告的自動產生指示詞之後，則需要分號。
- If-、elif-和 until 子句中的條件必須封裝在括弧中。 

針對所有其他語法變更，如果使用舊的語法，編譯器只會產生警告。     
這類變更的其中一個範例是使用者定義特殊化中的符號元組。 在先前的版本中，當受控制或受控制的 adjoint 特製化宣告指定了單一符號引數時，從0.3 開始，建議您為所有特製化提供這類符號元組，以 `...` 表示編譯器應該視需要從可呼叫的宣告中遷移符號。 

## <a name="semantic-changes"></a>語義變更 

0\.3 版本的最影響力中斷是如何將使用者定義型別整合到型別系統中。 在先前的版本中，使用者定義類型被視為其基礎類型的子類型。 在此版本中，我們已不再是這種情況。 使用者定義型別現在會視為自己的相異型別，而且使用者定義類型與其基礎類型之間並不會自動轉換。 所有轉型都必須透過「解除包裝」運算子 `!`進行明確的轉換，而且需要進行轉型，才能存取使用者定義型別之物件的內容。  

對型別系統所做的修改也包括陣列的變異數行為，以及型別參數化物件的處理。 從0.3 開始，可變與不可變的陣列都不變。 此外，傳遞至可呼叫的引數不能是參數化型別。 在這些情況下，類型引數必須與識別碼一起傳遞。

如果函式值具有正確的輸入和輸出類型，則先前版本的 Q # 編譯器允許提供函數值，其中應為作業值。 這是不會在 Q # 語言規格中指定的非預期行為。
在0.3 編譯器中，我們已移除此行為，因此不會再將函數值視為作業值。
為了儘量減少依賴此 bug 的現有程式碼中斷，我們已在 Canon 命名空間中新增 ToOperation 函式，以明確地將函數轉換成具有相同輸入和輸出類型的作業。

下列範例說明如何使用 `ToOperation` 函式，將函數 `Square` 變更為作業 `op`： 
```qsharp
namespace Microsoft.Quantum.Tests {
    open Microsoft.Quantum.Primitive;
    open Microsoft.Quantum.Canon;

    function Square(x : Int) : Int {
        return x * x;
    }

    operation ApplyOp<'T, 'U>(op : ('T => 'U), input : 'T) : 'U {
        return op(input);
    }

    operation ToOperationTest() : Unit {
        let op = ToOperation(Square);
        AssertIntEqual(ApplyOp(op, 3), 9, "ToOperation failed with Square.");
    }
}
```

## <a name="requirements"></a>需求 

適用于 Windows 10 的 Visual Studio 2017 15.8 版或更新版本，以及適用于 Windows 10、macOS 和 Linux 的 Visual Studio Code 版1.27.2 或更新版本都支援此版本。

量子開發工具組會使用 .NET Core SDK （2.0 或更新版本）。

## <a name="installation"></a>安裝  

請遵循[這裡](../install-guide/index.md)的安裝指示。

如果您目前的 .NET Core SDK 版本不是最新的，您可能會看到警告（「在不同版本的「system.string 中繼資料」之間發現的衝突無法解析。」）。  不過，如果您使用 .NET Core SDK （2.0 或更新版本），則可能會忽略這些警告。


- 發行會連同一些不同的範例一起提供，說明如何使用「量子開發工具組」的現有功能，以及此版本提供的新功能。 您可以在 GitHub 的[Microsoft/量子](https://github.com/Microsoft/Quantum)存放庫中找到這些範例。


## <a name="Migration"></a>將現有的專案遷移至 Q # 0。3 

如果您有來自0.2 版「配量開發工具組」的現有 Q # 專案，以下是將這些專案遷移至最新版本的步驟。 我們也會提供[遷移腳本](#MigrationScript)，協助您進行此程式。

> [!NOTE]
> 專案必須依序升級。 如果您的方案包含多個專案，則會依參考的順序更新每個專案。


1. 從命令列執行 `dotnet clean`，以移除所有現有的二進位檔和中繼檔案。
2. 在文字編輯器中，編輯 .csproj 檔案，將所有「`PackageReference`」的版本變更為 0.3.1811.2802-preview 版本，例如：
```xml
    <PackageReference Include="Microsoft.Quantum.Canon" Version="0.3.1811.2802" />
    <PackageReference Include="Microsoft.Quantum.Development.Kit" Version="0.3.1811.2802" />
```
4. 從命令列中，使用整合到命令列編譯器的格式工具，藉由執行下列命令來解決所有語法變更： `dotnet msbuild /t:qsharpformat`  
    - 您的檔案將會就地遷移。 所有原始檔案的備份都會複製到 `obj\qsharp\.backup`
    - 格式化工具會編譯忽略所有編譯錯誤的專案，並根據組建編譯產生格式化的 Q # 程式碼。 
       任何無法辨識的符號（例如未定義的變數名稱）都會由預留位置文字取代，必須在格式化之後以手動方式取代。 在此情況下，在產生受影響檔案的警告時，格式會成功。     
    - 在發出的程式碼中，將會變更檔案中的格式，特別是檔案中的任何空白字元。 批註將會保留。   
5. 執行此程式碼之後，您可能還是需要在程式碼的語義轉譯已變更時，手動解決語義上的變更。 IntelliSense 會在 Visual Studio 或 Visual Studio Code 中報告這些錯誤。
    - 在 Visual Studio 2017 或 Visual Studio Code 中開啟專案的根資料夾或包含的方案。
    - 在編輯器中開啟 .qs 檔案後，您應該會在輸出視窗中看到 Q# 語言延伸模組的輸出。
    - 成功載入專案後 (會在輸出視窗中指出)，請開啟每個檔案，並手動解決其餘的所有問題。


> [!NOTE]
> * 在0.3 版本中，配量開發工具組所包含的語言伺服器不支援多個工作區。
> * 若要在 Visual Studio Code 中使用專案，請開啟包含專案本身和所有參考專案的根資料夾。   
> * 若要在 Visual Studio 中使用解決方案，解決方案中包含的所有專案必須位於與解決方案相同的資料夾中，或解決方案的其中一個子資料夾中。  
> * **不**支援遷移至0.3 和更新版本的專案與使用舊版套件的專案之間的參考。




## <a name="MigrationScript"></a>遷移腳本 

為了加速專案遷移，提供了 PowerShell 腳本，可以在[這裡](https://raw.githubusercontent.com/Microsoft/Quantum/release/v0.3.1810/utilities/qdk-migrate.ps1)下載。
此腳本可協助您將專案從0.2 版的量子開發工具組遷移到使用0.3 版。

> [!NOTE]
> 遷移腳本需要 Windows PowerShell 或 PowerShell Core 才能執行。
> Windows PowerShell 已預先安裝 Windows 10。
> 在 https://github.com/PowerShell/PowerShell下載適用于 Windows、macOS 或 Linux 的 PowerShell Core。

腳本會執行下列四個步驟：

- 此專案是使用舊版的量子開發工具組所建立，以確保可能會成功進行遷移。 您可以使用腳本的 `-Force` 參數來略過這個步驟。
- 已安裝新的專案範本。
- 專案會更新為使用目前版本的「量子開發工具組」。
- 已套用0.3 版的配量開發工具組所提供的格式化工具，以自動解決上面記載的大部分重大變更。

完成這四個步驟之後，可能會有一些必須手動處理的剩餘遷移問題。
針對 Visual Studio 2017 和 Visual Studio Code 使用最新版的量子開發工具組延伸模組，可協助您輕鬆找到這些問題。

您可以在腳本所在的資料夾中執行下列其中一個命令，以取得腳本的檔：

```powershell
Get-Help ./qdk-migrate.ps1
Get-Help -Online ./qdk-migrate.ps1
```

> [!NOTE]
> 根據預設，Windows 會防止執行任何腳本做為安全性措施。
> 若要允許在 Windows 上執行 `qdk-migrate.ps1` 之類的腳本，您可能需要變更執行原則。
> 若要這麼做，請執行 `Set-ExecutionPolicy` 命令：
> ```powershell
> Set-ExecutionPolicy RemoteSigned -Scope Process
> ```
> 然後，當您結束 PowerShell 時，就會還原執行原則。
> 如果您想要儲存執行原則，請針對 `-Scope`使用不同的值：
> ```powershell
> Set-ExecutionPolicy RemoteSigned -Scope CurrentUser
> ```

