---
title: '問 # 標準程式庫-應用程式 |Microsoft Docs'
description: 'Q # 標準程式庫'
author: QuantumWriter
uid: microsoft.quantum.libraries.applications
ms.author: martinro@microsoft.com
ms.date: 12/11/2017
ms.topic: article
ms.openlocfilehash: e6eca45dd67b3566340c2a2a4fded0f6e7c3c5c3
ms.sourcegitcommit: 8becfb03eb60ba205c670a634ff4daa8071bcd06
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 10/29/2019
ms.locfileid: "73185166"
---
# <a name="applications"></a><span data-ttu-id="e7296-103">應用程式</span><span class="sxs-lookup"><span data-stu-id="e7296-103">Applications</span></span> #

## <a name="hamiltonian-simulation"></a><span data-ttu-id="e7296-104">Hamiltonian 模擬</span><span class="sxs-lookup"><span data-stu-id="e7296-104">Hamiltonian Simulation</span></span> ##

<span data-ttu-id="e7296-105">模擬量子系統是最令人興奮的量子計算應用程式之一。</span><span class="sxs-lookup"><span data-stu-id="e7296-105">The simulation of quantum systems is one of the most exciting applications of quantum computation.</span></span>
<span data-ttu-id="e7296-106">在傳統電腦上，模擬配量機制的困難在於，通常會以其狀態向量表示的維度 $N $ 來調整。</span><span class="sxs-lookup"><span data-stu-id="e7296-106">On a classical computer, the difficulty of simulating quantum mechanics, in general, scales with the dimension $N$ of its state-vector representation.</span></span>
<span data-ttu-id="e7296-107">由於這種表示方式會與 $n $ qubits $N = 2 ^ n $ 的數目呈指數成長，因此所謂的特性（也稱為[維度詛咒](xref:microsoft.quantum.concepts.multiple-qubits)）是棘手，而傳統硬體上的量子模擬。</span><span class="sxs-lookup"><span data-stu-id="e7296-107">As this representation grows exponentially with the number of $n$ qubits $N=2^n$, a trait known also known as the [curse of dimensionality](xref:microsoft.quantum.concepts.multiple-qubits), quantum simulation on classical hardware is intractable.</span></span>

<span data-ttu-id="e7296-108">不過，這種情況在量子硬體上可能會有非常不同的情況。</span><span class="sxs-lookup"><span data-stu-id="e7296-108">However, the situation can be very different on quantum hardware.</span></span> <span data-ttu-id="e7296-109">最常見的量子模擬變體稱為與時間無關的 Hamiltonian 模擬問題。</span><span class="sxs-lookup"><span data-stu-id="e7296-109">The most common variation of quantum simulation is called the time-independent Hamiltonian simulation problem.</span></span> <span data-ttu-id="e7296-110">其中會提供系統 Hamiltonian $H $ 的描述，也就是 Hermitian 的矩陣，而某些初始的量子狀態 $ \ket{\psi （0）} $ 是以某種基礎，在量子電腦上 $n $ qubits 進行編碼。</span><span class="sxs-lookup"><span data-stu-id="e7296-110">There, one is provided with a description of the system Hamiltonian $H$, which is a Hermitian matrix, and some initial quantum state $\ket{\psi(0)}$ that is encoded in some basis on $n$ qubits on a quantum computer.</span></span> <span data-ttu-id="e7296-111">當封閉式系統中的配量狀態在 Schrödinger 方程式 $ $ \begin{align} i\frac {d \ket{\psi （t）}} {d t} & = H \ket{\psi （t）} 下演進時，\end{align} $ $ 的目標是要在某些固定時間執行單一時間進化運算子 $U （t） = e ^ {-iHt} $，$t $，其中 $ \ket{\psi （t）} = U （t） \ket{\psi （0）} $ 會解決 Schrödinger 方程式。</span><span class="sxs-lookup"><span data-stu-id="e7296-111">As quantum states in closed systems evolve under the Schrödinger equation $$ \begin{align} i\frac{d \ket{\psi(t)}}{d t} & = H \ket{\psi(t)}, \end{align} $$ the goal is to implement the unitary time-evolution operator $U(t)=e^{-iHt}$ at some fixed time $t$, where $\ket{\psi(t)}=U(t)\ket{\psi(0)}$ solves the Schrödinger equation.</span></span>
<span data-ttu-id="e7296-112">類似，時間相依的 Hamiltonian 模擬問題可解決相同的方程式，但 $H （t） $ 現在是一項功能。</span><span class="sxs-lookup"><span data-stu-id="e7296-112">Analogously, the time-dependent Hamiltonian simulation problem solves the same equation, but with $H(t)$ now a function of time.</span></span>

<span data-ttu-id="e7296-113">Hamiltonian 模擬是許多其他量子模擬問題的主要元件，而 Hamiltonian 模擬問題的解決方案則是描述合成將逼近單一 $ \tilde{U} $ 之基本量子閘道序列的演算法。發生錯誤 $\\| \tilde{U}-U （t）\\|[spectral 標準](xref:microsoft.quantum.concepts.matrix-advanced)中的 \le \epsilon $。</span><span class="sxs-lookup"><span data-stu-id="e7296-113">Hamiltonian simulation is a major component of many other quantum simulation problems, and solutions to Hamiltonian simulation problem are algorithms that describes a sequence of primitive quantum gates for synthesizing an approximating unitary $\tilde{U}$ with error $\\|\tilde{U} - U(t)\\| \le \epsilon$ in the [spectral norm](xref:microsoft.quantum.concepts.matrix-advanced).</span></span> <span data-ttu-id="e7296-114">這些演算法的複雜性非常強烈，因為量子電腦可存取相關 Hamiltonian 的描述。</span><span class="sxs-lookup"><span data-stu-id="e7296-114">The complexity of these algorithms depend very strongly on how a description of the Hamiltonian of interest is made accessible by a quantum computer.</span></span> <span data-ttu-id="e7296-115">例如，在最糟的情況下，如果要以 $ 2 ^ n \times 2 ^ n $ qubits 的清單來提供 $n $ 的 $H $ 作用，每個矩陣元素都有一個，只要讀取資料，就會需要指數時間。</span><span class="sxs-lookup"><span data-stu-id="e7296-115">For instance, in the worst-case, if $H$ acting on $n$ qubits were to be provided as a list of $2^n \times 2^n$ numbers, one for each matrix element, simply reading the data would already require exponential time.</span></span> <span data-ttu-id="e7296-116">在最佳的情況下，可以假設有一個 $O \ket{t}\ket{\psi （0）} = \ket{t}U （t） \ket{\psi （0）} $ 完整的黑色方塊，可解決此問題。</span><span class="sxs-lookup"><span data-stu-id="e7296-116">In the best case, one could assume access to a black-box unitary that $O\ket{t}\ket{\psi(0)}=\ket{t}U(t)\ket{\psi(0)}$ trivially solves the problem.</span></span> <span data-ttu-id="e7296-117">這兩種輸入模型都不會特別有趣--前者並不是傳統方法，而後者則是以黑色方塊隱藏其執行的基本閘道複雜度，這可能是 qubits 數目的指數。</span><span class="sxs-lookup"><span data-stu-id="e7296-117">Neither of these input models are particularly interesting -- the former as it is no better than classical approaches, and the latter as the black-box hides the primitive gate complexity of its implementation, which could be exponential in the number of qubits.</span></span>

### <a name="descriptions-of-hamiltonians"></a><span data-ttu-id="e7296-118">Hamiltonians 的描述</span><span class="sxs-lookup"><span data-stu-id="e7296-118">Descriptions of Hamiltonians</span></span> ###

<span data-ttu-id="e7296-119">因此需要輸入格式的其他假設。</span><span class="sxs-lookup"><span data-stu-id="e7296-119">Additional assumptions of the format of the input are therefore required.</span></span> <span data-ttu-id="e7296-120">有足夠描述性的輸入模型與包含有趣的 Hamiltonians （例如實際實體系統或有趣的運算問題，以及嚴格限制的輸入模型）之間必須有精確的平衡以有效率地能實作在量子電腦上。</span><span class="sxs-lookup"><span data-stu-id="e7296-120">A fine balance must be struck between input models that are sufficiently descriptive to encompass interesting Hamiltonians, such as those for realistic physical systems or interesting computational problems, and input models that are sufficiently restrictive to be efficiently implementable on a quantum computer.</span></span> <span data-ttu-id="e7296-121">在此文獻中可找到各種非一般的輸入模型，其範圍從量子到傳統。</span><span class="sxs-lookup"><span data-stu-id="e7296-121">A variety of non-trivial input model may be found in the literature, and they range from quantum to classical.</span></span> 

<span data-ttu-id="e7296-122">做為配量輸入模型的範例，以[範例為基礎的 Hamiltonian 模擬](http://www.nature.com/articles/s41534-017-0013-7)會假設產生密度矩陣 $ \rho $ 之複製的量子作業的黑箱存取，而這會被視為 Hamiltonian $H $。</span><span class="sxs-lookup"><span data-stu-id="e7296-122">As examples of quantum input models, [sample-based Hamiltonian simulation](http://www.nature.com/articles/s41534-017-0013-7) assumes black-box access to quantum operations that produce copies of a density matrix $\rho$, which are taken to be the Hamiltonian $H$.</span></span> <span data-ttu-id="e7296-123">在[單一存取模型](https://arxiv.org/abs/1202.5822)中，一個 supposes Hamiltonian 改為會 decompose 為 unitaries $ $ \begin{align} H 的總和 & = \sum ^ {d-1}\_{j = 0} a\_j \hat{U}\_j，\end{align} $ $ where $a\_j > 0 $ 為係數和 $ \hat{U}\_j $ 為 unitaries。</span><span class="sxs-lookup"><span data-stu-id="e7296-123">In the [unitary access model](https://arxiv.org/abs/1202.5822) one supposes that the Hamiltonian instead decomposes into a sum of unitaries $$ \begin{align} H & = \sum^{d-1}\_{j=0} a\_j \hat{U}\_j, \end{align} $$ where $a\_j>0$ are coefficients, and $\hat{U}\_j$ are unitaries.</span></span> <span data-ttu-id="e7296-124">然後假設一個人可以使用單一 oracle $V = \sum ^ {d-1}\_{j = 0} \ket{j}\bra{j}\otimes \hat{U}\_j $ 來選取所需的 $ \hat{U}\_j $，而 oracle $A \ket{0}= \sum ^ {d-1}\_{j = 0} \sqrt{a\_j/\ sum ^ {d-1}\_{k = 0} \Alpha\_j} \ket{j} $ 來建立配量狀態編碼這些係數。</span><span class="sxs-lookup"><span data-stu-id="e7296-124">It is then assumed that one has black-box access to the unitary oracle $V=\sum^{d-1}\_{j=0}\ket{j}\bra{j}\otimes \hat{U}\_j$ that selects the desired $\hat{U}\_j$, and the oracle $A\ket{0}=\sum^{d-1}\_{j=0}\sqrt{a\_j/\sum^{d-1}\_{k=0}\alpha\_j}\ket{j}$ that create a quantum state encoding these coefficients.</span></span> <span data-ttu-id="e7296-125">在[Sparse Hamiltonian 模擬](https://arxiv.org/abs/quant-ph/0301023)的案例中，一個假設 Hamiltonian 是一個疏鬆陣列，其中每個資料列只包含 $d = \mathcal{O} （\Text{polylog} （N）） $ 非零的元素。</span><span class="sxs-lookup"><span data-stu-id="e7296-125">In the case of [sparse Hamiltonian simulation](https://arxiv.org/abs/quant-ph/0301023), one assumes that the Hamiltonian is a sparse matrix with only $d=\mathcal{O}(\text{polylog}(N))$ non-zero element in every row.</span></span> <span data-ttu-id="e7296-126">此外，其中一個會假設有有效率的配量電路，輸出這些非零元素的位置，以及它們的值。</span><span class="sxs-lookup"><span data-stu-id="e7296-126">Moreover, one assumes the existence of efficient quantum circuits that output the location of these non-zero elements, as well as the their values.</span></span> <span data-ttu-id="e7296-127">[Hamiltonian 模擬演算法](xref:microsoft.quantum.more-information)的複雜性是根據這些黑箱的查詢數來進行評估，而基本閘道的複雜性則會非常依賴執行這些黑色方塊的困難程度。</span><span class="sxs-lookup"><span data-stu-id="e7296-127">The complexity of [Hamiltonian simulation algorithms](xref:microsoft.quantum.more-information) is evaluated in terms of number of queries to these black-boxes, and the primitive gate complexity then depends very much on the difficulty of implementing these black-boxes.</span></span>

> [!NOTE]
> <span data-ttu-id="e7296-128">Big O 標記法通常用來描述演算法的複雜性調整。</span><span class="sxs-lookup"><span data-stu-id="e7296-128">The big-O notation is commonly used to describe the complexity scaling of algorithms.</span></span> <span data-ttu-id="e7296-129">假設有兩個真正的函式 $f，g $，expression $g （x） = \mathcal{O} （f （x）） $ 表示存在絕對的正常數 $x\_0，c > 0 $，讓 $g （x） \le c f （x） $ 適用于所有 $x \ge x\_$0。</span><span class="sxs-lookup"><span data-stu-id="e7296-129">Given two real functions $f,g$, the expression $g(x)=\mathcal{O}(f(x))$ means that there exists an absolute positive constant $x\_0, c>0$ such that $g(x) \le c f(x)$ for all $x\ge x\_0$.</span></span> 

<span data-ttu-id="e7296-130">在最實際的應用程式中，若要在量子電腦上執行，這些黑箱必須有效率地能實作，也就是 $ \mathcal{O} （\text{polylog} （N）） $ 基本型量子閘道。</span><span class="sxs-lookup"><span data-stu-id="e7296-130">In most practical applications to be implemented on a quantum computer, these black-boxes must be efficiently implementable, that is with $\mathcal{O}(\text{polylog}(N))$ primitive quantum gates.</span></span> <span data-ttu-id="e7296-131">更強、有效率的 simulable Hamiltonians 必須有足夠的稀疏傳統描述。</span><span class="sxs-lookup"><span data-stu-id="e7296-131">More strongly, efficiently simulable Hamiltonians must have some sufficiently sparse classical description.</span></span> <span data-ttu-id="e7296-132">在其中一個這類的形式中，假設 Hamiltonian 會 decompose 為 Hermitian part $ $ \begin{align} H & = \sum ^ {d-1} _ {j = 0} H_j 的總和。</span><span class="sxs-lookup"><span data-stu-id="e7296-132">In one such formulation, it is assumed that the Hamiltonian decomposes into a sum of Hermitian parts $$ \begin{align} H & = \sum^{d-1}_{j=0} H_j.</span></span>
<span data-ttu-id="e7296-133">\end{align} $ $ 也會假設每個元件（Hamiltonian $H\_j $）很容易模擬。</span><span class="sxs-lookup"><span data-stu-id="e7296-133">\end{align} $$ Moreover, it is assumed that each part, a Hamiltonian $H\_j$, is easy to simulate.</span></span> <span data-ttu-id="e7296-134">這表示任何時間 $t $ 的單一 $e ^ {-iH\_j t} $ 可以完全使用 $ \mathcal{O} （1） $ 基本型量子閘道來執行。</span><span class="sxs-lookup"><span data-stu-id="e7296-134">This means that the unitary $e^{-iH\_j t}$ for any time $t$ may be implemented exactly using $\mathcal{O}(1)$ primitive quantum gates.</span></span> <span data-ttu-id="e7296-135">比方說，在特殊情況下，每個 $H\_j $ 都是本機 Pauli 運算子，這表示它們是張量產品的 $ \mathcal{O} （1） $ 非身分識別 Pauli 運算子，其作用於空間關閉的 qubits。</span><span class="sxs-lookup"><span data-stu-id="e7296-135">For instance, this is true in the special case where each $H\_j$ are local Pauli operators, meaning that they are of tensor products of $\mathcal{O}(1)$ non-identity Pauli operators that act on spatially close qubits.</span></span> <span data-ttu-id="e7296-136">此模型特別適用于具有系結和本機互動的實體系統，因為詞彙數目是 $d = \mathcal{O} （\text{polylog} （N）） $，而且可能會清楚地寫下，亦即傳統方式所述的多項式時間。</span><span class="sxs-lookup"><span data-stu-id="e7296-136">This model is particularly applicable to physical systems with bounded and local interaction, as the number of terms is $d=\mathcal{O}(\text{polylog}(N))$, and may clearly be written down, i.e. classically described, in polynomial time.</span></span>

> [!TIP]
> <span data-ttu-id="e7296-137">分解成元件總和的 Hamiltonians 可能會使用 Dynamical 產生器表示程式庫來描述。</span><span class="sxs-lookup"><span data-stu-id="e7296-137">Hamiltonians that decompose into a sum of parts may be described using the Dynamical Generator Representation library.</span></span> <span data-ttu-id="e7296-138">如需詳細資訊，請參閱[資料結構](xref:microsoft.quantum.libraries.data-structures)中的 Dynamical 產生器表示一節。</span><span class="sxs-lookup"><span data-stu-id="e7296-138">For more information, see the Dynamical Generator Representation section in [data structures](xref:microsoft.quantum.libraries.data-structures).</span></span>

### <a name="simulation-algorithms"></a><span data-ttu-id="e7296-139">模擬演算法</span><span class="sxs-lookup"><span data-stu-id="e7296-139">Simulation Algorithms</span></span> ###

<span data-ttu-id="e7296-140">量子模擬演算法會將指定的 Hamiltonian 描述轉換成一系列基本的配量閘道，這是一個整體的 Hamiltonian，大約是時間進化。</span><span class="sxs-lookup"><span data-stu-id="e7296-140">A quantum simulation algorithm converts a given description of a Hamiltonian into a sequence of primitive quantum gates that, as a whole, approximate time-evolution by said Hamiltonian.</span></span>

<span data-ttu-id="e7296-141">在 Hamiltonian 會 decompose 為 Hermitian 部分總和的特殊情況下，Trotter-Plat'home co. 分解是特別簡單且直覺化的演算法，可模擬 Hamiltonians，以分解成 Hermitian 元件的總和。</span><span class="sxs-lookup"><span data-stu-id="e7296-141">In the special case where the Hamiltonian decomposes into a sum of Hermitian parts, the Trotter-Suzuki decomposition is a particularly simple and intuitive algorithm for simulating Hamiltonians that decompose into a sum of Hermitian components.</span></span> <span data-ttu-id="e7296-142">例如，此系列的第一位整合者約 $ $ \begin{align} U （t） & = \left （e ^ {-iH\_0 t/r} e ^ {-iH\_1 t/r} \cdots e ^ {-iH\_{d-1} t/r} \right） ^ {r} + \mathcal{O} （d ^ 2 \ max_j\\|H\_j\\| ^ 2 t/r），使用 $r d $ 詞彙的乘積 \end{align} $ $。</span><span class="sxs-lookup"><span data-stu-id="e7296-142">For instance, a first-order integrator of this family approximates $$ \begin{align} U(t) & = \left( e^{-iH\_0 t / r} e^{-iH\_1 t / r} \cdots e^{-iH\_{d-1} t / r} \right)^{r} + \mathcal{O}(d^2 \max_j\\|H\_j\\|^2 t^2/r), \end{align} $$ using a product of $r d$ terms.</span></span> 

> [!TIP]
> <span data-ttu-id="e7296-143">範例中涵蓋 Trotter Plat'home co. 模擬演算法的應用程式。</span><span class="sxs-lookup"><span data-stu-id="e7296-143">Applications of the Trotter-Suzuki simulation algorithm are covered in the samples.</span></span>
> <span data-ttu-id="e7296-144">針對僅使用每部目的電腦所提供之內建作業的 Ising 模型，請參閱[ **SimpleIsing**範例](https://github.com/Microsoft/Quantum/tree/master/Samples/src/SimpleIsing)。</span><span class="sxs-lookup"><span data-stu-id="e7296-144">For the Ising model using only the intrinsic operations provided by each target machine, please see the [**SimpleIsing** sample](https://github.com/Microsoft/Quantum/tree/master/Samples/src/SimpleIsing).</span></span>
> <span data-ttu-id="e7296-145">如需使用 Trotter-Plat'home co. 程式庫控制項結構的 Ising 模型，請參閱[ **IsingTrotter**範例](https://github.com/Microsoft/Quantum/tree/master/Samples/src/IsingTrotterEvolution)。</span><span class="sxs-lookup"><span data-stu-id="e7296-145">For the Ising model using the Trotter-Suzuki library control structure, please see the [**IsingTrotter** sample](https://github.com/Microsoft/Quantum/tree/master/Samples/src/IsingTrotterEvolution).</span></span>
> <span data-ttu-id="e7296-146">如需使用 Trotter Plat'home co. 程式庫控制結構的分子 Hydrogen，請參閱[ **H2 模擬**範例](https://github.com/Microsoft/Quantum/tree/master/Samples/src/H2SimulationCmdLine)。</span><span class="sxs-lookup"><span data-stu-id="e7296-146">For molecular Hydrogen using the Trotter-Suzuki library control structure, please see the [**H2 simulation** sample](https://github.com/Microsoft/Quantum/tree/master/Samples/src/H2SimulationCmdLine).</span></span>

<span data-ttu-id="e7296-147">在許多情況下，我們想要執行模擬演算法，但對其執行的細節並不感興趣。</span><span class="sxs-lookup"><span data-stu-id="e7296-147">In many cases, we would like to implement the simulation algorithm, but are not interested in the details of its implementation.</span></span> <span data-ttu-id="e7296-148">例如，第二個訂單的整合者近似 $ $ \begin{align} U （t） & = \left （e ^ {-iH\_0 t/2r} e ^ {-iH\_1 t/2r} \cdots e ^ {-iH\_{d-1} t/2r} e ^ {-iH\_{d-1} t/2r} \cdots e ^ {-iH\_1 t/2r} e ^ {-iH\_0 t/2r} \right） ^ {r} + \mathcal{O} （d ^ 3 \ max_j\\|H\_j\\| ^ 3 t ^ 3/r ^ 2），使用 $ 2rd $ 詞彙的產品 \end{align} $ $。</span><span class="sxs-lookup"><span data-stu-id="e7296-148">For instance, the second-order integrator approximates $$ \begin{align} U(t) & = \left( e^{-iH\_0 t / 2r} e^{-iH\_1 t / 2r} \cdots e^{-iH\_{d-1} t / 2r} e^{-iH\_{d-1} t / 2r}  \cdots e^{-iH\_1 t / 2r} e^{-iH\_0 t / 2r} \right)^{r} + \mathcal{O}(d^3 \max_j\\|H\_j\\|^3 t^3/r^2), \end{align} $$ using a product of $2rd$ terms.</span></span> <span data-ttu-id="e7296-149">較大的訂單也牽涉到更多詞彙，而優化變體可能需要指數上的高度非一般排序。</span><span class="sxs-lookup"><span data-stu-id="e7296-149">Larger orders will involve even more terms and optimized variants may require highly non-trivial orderings on the exponentials.</span></span> <span data-ttu-id="e7296-150">其他先進的演算法也可能牽涉到在中繼步驟中使用 ancilla qubits。</span><span class="sxs-lookup"><span data-stu-id="e7296-150">Other advanced algorithms may also involve the use of ancilla qubits in intermediate steps.</span></span> <span data-ttu-id="e7296-151">因此，我們會在 canon 中將模擬演算法封裝為使用者定義型別</span><span class="sxs-lookup"><span data-stu-id="e7296-151">Thus we package simulation algorithms in the canon as the user-defined type</span></span>

```qsharp
newtype SimulationAlgorithm = ((Double, EvolutionGenerator, Qubit[]) => Unit is Adj + Ctl);
```

<span data-ttu-id="e7296-152">第一個參數 `Double` 是模擬的時間，而第二個參數 `EvolutionGenerator`（在[資料結構](xref:microsoft.quantum.libraries.data-structures)的 Dynamical 產生器表示區段中所涵蓋）是與搭配的時間獨立 Hamiltonian 的傳統描述如何透過量子線路模擬 Hamiltonian 中每個詞彙的指示。</span><span class="sxs-lookup"><span data-stu-id="e7296-152">The first parameter `Double` is the time of simulation, the second parameter `EvolutionGenerator`, covered in the Dynamical Generator Representation section of [data-structures](xref:microsoft.quantum.libraries.data-structures), is a classical description of a time-independent Hamiltonian packaged with instructions on how each term in the Hamiltonian may be simulated by a quantum circuit.</span></span> <span data-ttu-id="e7296-153">此形式的類型大約是第三個參數 `Qubit[]`上的單一作業 $e ^ {-iHt} $，這是儲存模擬系統之量子狀態的暫存器。</span><span class="sxs-lookup"><span data-stu-id="e7296-153">Types of this form approximate the unitary operation $e^{-iHt}$ on the third parameter `Qubit[]`, which is the register storing the quantum state of the simulated system.</span></span> <span data-ttu-id="e7296-154">類似于時間相依的情況，我們會改為定義具有 `EvolutionSchedule` 類型的使用者定義型別，這是時間相依 Hamiltonian 的傳統描述。</span><span class="sxs-lookup"><span data-stu-id="e7296-154">Similarly for the time-dependent case, we define a user-defined type with an `EvolutionSchedule` type instead, which is a classical description of a time-dependent Hamiltonian.</span></span>

```qsharp
newtype TimeDependentSimulationAlgorithm = ((Double, EvolutionSchedule, Qubit[]) => Unit : Adjoint, Controlled);
```

<span data-ttu-id="e7296-155">例如，您可以使用下列 canon 函式來呼叫 Trotter-Plat'home co. 分解，其中參數 `trotterStepSize` 修改每個指數中模擬的持續時間，並 `trotterOrder` 所需的整合器順序。</span><span class="sxs-lookup"><span data-stu-id="e7296-155">As an example, the Trotter-Suzuki decomposition may be called using the following canon functions, with parameters `trotterStepSize` modifying the duration of simulation in each exponential, and `trotterOrder` for the order of the desired integrator.</span></span>

```qsharp
function TrotterSimulationAlgorithm(
    trotterStepSize: Double, 
    trotterOrder: Int) 
    : SimulationAlgorithm {
    ...
}
function TimeDependentTrotterSimulationAlgorithm(
    trotterStepSize: Double, 
    trotterOrder: Int) 
    : TimeDependentSimulationAlgorithm {
    ...
}
```

> [!TIP]
> <span data-ttu-id="e7296-156">範例中涵蓋模擬程式庫的應用程式。</span><span class="sxs-lookup"><span data-stu-id="e7296-156">Applications of the simulation library are covered in the samples.</span></span> <span data-ttu-id="e7296-157">如需使用 `SimulationAlgorithm`Ising 模型中的階段估計，請參閱[ **IsingPhaseEstimation**範例](https://github.com/Microsoft/Quantum/tree/master/Samples/src/IsingPhaseEstimation)。</span><span class="sxs-lookup"><span data-stu-id="e7296-157">For phase estimation in the Ising model using `SimulationAlgorithm`, please see the [**IsingPhaseEstimation** sample](https://github.com/Microsoft/Quantum/tree/master/Samples/src/IsingPhaseEstimation).</span></span>
> <span data-ttu-id="e7296-158">如需使用 `TimeDependentSimulationAlgorithm`Ising 模型中的 adiabatic 狀態準備，請參閱[ **AdiabaticIsing**範例](https://github.com/Microsoft/Quantum/tree/master/Samples/src/AdiabaticIsing)。</span><span class="sxs-lookup"><span data-stu-id="e7296-158">For adiabatic state preparation in the Ising model using `TimeDependentSimulationAlgorithm`, please see the [**AdiabaticIsing** sample](https://github.com/Microsoft/Quantum/tree/master/Samples/src/AdiabaticIsing).</span></span>


### <a name="adiabatic-state-preparation--phase-estimation"></a><span data-ttu-id="e7296-159">Adiabatic 狀態準備 & 階段估計</span><span class="sxs-lookup"><span data-stu-id="e7296-159">Adiabatic State Preparation & Phase Estimation</span></span> ###

<span data-ttu-id="e7296-160">Hamiltonian 模擬的一個常見應用就是 adiabatic 狀態準備。</span><span class="sxs-lookup"><span data-stu-id="e7296-160">One common application of Hamiltonian simulation is adiabatic state preparation.</span></span> <span data-ttu-id="e7296-161">這裡提供兩個 Hamiltonians $H\_{\text{start}} $ 和 $H\_{\text{end}} $）和量子 state $ \ket{\psi （0）} $，這是開始 Hamiltonian $H\_{\text{start}} $ 的基礎狀態。</span><span class="sxs-lookup"><span data-stu-id="e7296-161">Here, one is provided with two Hamiltonians $H\_{\text{start}}$ and $H\_{\text{end}}$, and a quantum state $\ket{\psi(0)}$ that is a ground state of the start Hamiltonian $H\_{\text{start}}$.</span></span> <span data-ttu-id="e7296-162">通常會選擇 $H\_{\text{start}} $，讓 $ \ket{\psi （0）} $ 很容易從計算基礎狀態 $ \ket{0\cdots 0} $ 準備。</span><span class="sxs-lookup"><span data-stu-id="e7296-162">Typically, $H\_{\text{start}}$ is chosen such that $\ket{\psi(0)}$ is easy to prepare from a computational basis state $\ket{0\cdots 0}$.</span></span> <span data-ttu-id="e7296-163">藉由在與時間相依的模擬問題 sufficientl 中插入這些 Hamiltonians 的速度變慢，最後可能會有很高的機率，\_{\text{end}} $ 的最終 Hamiltonian $H 的基礎狀態。</span><span class="sxs-lookup"><span data-stu-id="e7296-163">By interpolating between these Hamiltonians in the time-dependent simulation problem sufficientl slowly, it is possible to end up, with high probability, in a ground state of the final Hamiltonian $H\_{\text{end}}$.</span></span> <span data-ttu-id="e7296-164">雖然準備好的 Hamiltonian 基礎狀態，可以藉由呼叫以時間為基礎的 Hamiltonian 模擬演算法做為副程式來繼續進行，而其他概念不同的方法，例如 variational 量子eigensolver 是可行的。</span><span class="sxs-lookup"><span data-stu-id="e7296-164">Though preparing good approximations to Hamiltonian ground states could proceed in this manner by calling upon on time-dependent Hamiltonian simulation algorithms as a subroutine, other conceptually different approaches such as the variational quantum eigensolver are possible.</span></span>

<span data-ttu-id="e7296-165">但是在量子化學中的另一個應用程式，是估計 Hamiltonians 的基礎狀態能源，代表化學反應的中繼步驟。</span><span class="sxs-lookup"><span data-stu-id="e7296-165">Yet another application ubiquitous in quantum chemistry is estimating the ground state energy of Hamiltonians representing the intermediate steps of chemical reaction.</span></span> <span data-ttu-id="e7296-166">例如，這種配置可能會依賴 adiabatic 狀態準備來建立地面狀態，然後將與時間無關的 Hamiltonian 模擬納入階段估計特性中，以使用一些有限的錯誤來將此能源解壓縮，並成功的機率。</span><span class="sxs-lookup"><span data-stu-id="e7296-166">Such a scheme could, for instance, rely on adiabatic state preparation to create the ground state, and then incorporate time-independent Hamiltonian simulation as a subroutine in phase estimation characterization to extract this energy with some finite error and probability of success.</span></span> 

<span data-ttu-id="e7296-167">將模擬演算法抽象化為使用者定義的型別 `SimulationAlgorithm` 和 `TimeDependentSimulationAlgorithm` 可讓我們輕鬆地將其功能納入更複雜的量子演算法。</span><span class="sxs-lookup"><span data-stu-id="e7296-167">Abstracting simulation algorithms as the user-defined types `SimulationAlgorithm` and `TimeDependentSimulationAlgorithm` allow us to conveniently incorporate their functionality into more sophisticated quantum algorithms.</span></span> <span data-ttu-id="e7296-168">這應採用我們對這些常用的副程式執行相同的動作。</span><span class="sxs-lookup"><span data-stu-id="e7296-168">This motivates us to do the same for these commonly used subroutines.</span></span>

<span data-ttu-id="e7296-169">因此，我們定義了方便的函式</span><span class="sxs-lookup"><span data-stu-id="e7296-169">Thus we define the convenient function</span></span>

```qsharp
function InterpolatedEvolution(
        interpolationTime: Double, 
        evolutionGeneratorStart: EvolutionGenerator,
        evolutionGeneratorEnd: EvolutionGenerator,
        timeDependentSimulationAlgorithm: TimeDependentSimulationAlgorithm)
        : (Qubit[] => Unit is Adj + Ctl) {
        ...
}
 
```

<span data-ttu-id="e7296-170">這會傳回單一作業，此作業會執行 adiabatic 狀態準備的所有步驟。</span><span class="sxs-lookup"><span data-stu-id="e7296-170">This returns a unitary operation that implements all steps of adiabatic state preparation.</span></span> <span data-ttu-id="e7296-171">第一個參數 `interpolatedTime` 定義在第二個 `evolutionGeneratorStart` 參數所描述的開始 Hamiltonian 和第三個參數 `evolutionGeneratorEnd`所描述的結束 Hamiltonian 之間，線性插補的時間。</span><span class="sxs-lookup"><span data-stu-id="e7296-171">The first parameter `interpolatedTime` defines the time over which we linearly interpolate between the start Hamiltonian described by the second parameter `evolutionGeneratorStart` and the end Hamiltonian described by the third parameter `evolutionGeneratorEnd`.</span></span> <span data-ttu-id="e7296-172">第四個參數 `timeDependentSimulationAlgorithm` 是其中一個可選擇模擬演算法的位置。</span><span class="sxs-lookup"><span data-stu-id="e7296-172">The fourth parameter `timeDependentSimulationAlgorithm` is where one makes the choice of simulation algorithm.</span></span> <span data-ttu-id="e7296-173">請注意，如果 `interpolatedTime` 夠長，初始的狀態會在時間相依模擬的整個持續時間內維持 Hamiltonian 的瞬間接地狀態，因此會在結束 Hamiltonian 的基礎狀態結束。</span><span class="sxs-lookup"><span data-stu-id="e7296-173">Note that if `interpolatedTime` is long enough, an initial ground state remains an instantaneous ground state of the Hamiltonian over the entire duration of time-dependent simulation, and thus ends in the ground state of the end Hamiltonian.</span></span>

<span data-ttu-id="e7296-174">我們也定義了一個有用的作業，可自動執行典型「量子化學」實驗的所有步驟。</span><span class="sxs-lookup"><span data-stu-id="e7296-174">We also define a helpful operation that automatically performs all steps of a typical quantum chemistry experiment.</span></span> <span data-ttu-id="e7296-175">比方說，我們有下列各項，它會傳回 adiabatic 狀態準備所產生之狀態的能源預估：</span><span class="sxs-lookup"><span data-stu-id="e7296-175">For instance we have the following, which returns an energy estimate of the state produced by adiabatic state preparation:</span></span>

```qsharp
operation AdiabaticStateEnergyEstimate( 
    nQubits : Int, 
    statePrepUnitary: (Qubit[] => Unit),
    adiabaticUnitary: (Qubit[] => Unit),
    qpeUnitary: (Qubit[] => Unit is Adj + Ctl),
    phaseEstAlgorithm : ((DiscreteOracle, Qubit[]) => Double)) 
    : Double {
...
}
```

<span data-ttu-id="e7296-176">`nQubits` 是用來編碼初始量子狀態的 qubits 數目。</span><span class="sxs-lookup"><span data-stu-id="e7296-176">`nQubits` is the number of qubits used to encode the initial quantum state.</span></span> <span data-ttu-id="e7296-177">`statePrepUnitary` 從計算基礎 $ \ket{0\cdots 0} $ 準備開始狀態。</span><span class="sxs-lookup"><span data-stu-id="e7296-177">`statePrepUnitary` prepares the start state from the computational basis $\ket{0\cdots 0}$.</span></span> <span data-ttu-id="e7296-178">`adiabaticUnitary` 是執行 adiabatic 狀態準備的單一作業，例如由 `InterpolatedEvolution` 函數所產生。</span><span class="sxs-lookup"><span data-stu-id="e7296-178">`adiabaticUnitary` is the unitary operation that implements adiabatic state preparation, such as produced by the  `InterpolatedEvolution` function.</span></span> <span data-ttu-id="e7296-179">`qpeUnitary` 是用來對產生的量子狀態執行階段估計的單一作業。</span><span class="sxs-lookup"><span data-stu-id="e7296-179">`qpeUnitary` is the unitary operation that is used to perform phase estimation on the resulting quantum state.</span></span> <span data-ttu-id="e7296-180">`phaseEstAlgorithm` 是我們選擇的階段估計演算法。</span><span class="sxs-lookup"><span data-stu-id="e7296-180">`phaseEstAlgorithm` is our choice of phase estimation algorithm.</span></span>

> [!TIP]
> <span data-ttu-id="e7296-181">範例中會涵蓋 adiabatic 狀態準備的應用程式。</span><span class="sxs-lookup"><span data-stu-id="e7296-181">Applications of adiabatic state preparation are covered in the samples.</span></span> <span data-ttu-id="e7296-182">針對使用手動執行 adiabatic 狀態準備與使用 `AdiabaticEvolution` 函數的 Ising 模型，請參閱[ **AdiabaticIsing**範例](https://github.com/Microsoft/Quantum/tree/master/Samples/src/AdiabaticIsing)。</span><span class="sxs-lookup"><span data-stu-id="e7296-182">For the Ising model using a manual implementation of adiabatic state preparation versus using the `AdiabaticEvolution` function, please see the [**AdiabaticIsing** sample](https://github.com/Microsoft/Quantum/tree/master/Samples/src/AdiabaticIsing).</span></span>
> <span data-ttu-id="e7296-183">如需 Ising 模型中的階段估計和 adiabatic 狀態準備，請參閱[ **IsingPhaseEstimation**範例](https://github.com/Microsoft/Quantum/tree/master/Samples/src/IsingPhaseEstimation)。</span><span class="sxs-lookup"><span data-stu-id="e7296-183">For phase estimation and adiabatic state preparation in the Ising model, please see the [**IsingPhaseEstimation** sample](https://github.com/Microsoft/Quantum/tree/master/Samples/src/IsingPhaseEstimation).</span></span>

> [!TIP]
> <span data-ttu-id="e7296-184">[模擬分子 Hydrogen](https://github.com/Microsoft/Quantum/tree/master/Samples/src/H2SimulationCmdLine)是一個有趣又簡單的範例。</span><span class="sxs-lookup"><span data-stu-id="e7296-184">The [simulation of molecular Hydrogen](https://github.com/Microsoft/Quantum/tree/master/Samples/src/H2SimulationCmdLine) is an interesting and brief sample.</span></span> <span data-ttu-id="e7296-185">[O'Malley et. al](https://arxiv.org/abs/1512.06860)中回報的模型和實驗性結果。</span><span class="sxs-lookup"><span data-stu-id="e7296-185">The model and experimental results reported in [O'Malley et. al.](https://arxiv.org/abs/1512.06860)</span></span> <span data-ttu-id="e7296-186">只需要 Pauli 矩陣，並採用 $ \hat H = g\_格式 {0}I\_0 I\_1 + g\_1 {Z\_0} + g\_2 {Z\_1} + g\_3 {Z\_0} {Z\_1} + g\_4 {Y\_0} {Y\_1} + g\_5 {X\_0} {X\_1} $。</span><span class="sxs-lookup"><span data-stu-id="e7296-186">only requires Pauli matrices and takes the form $\hat H = g\_{0}I\_0I\_1+g\_1{Z\_0}+g\_2{Z\_1}+g\_3{Z\_0}{Z\_1}+g\_4{Y\_0}{Y\_1}+g\_5{X\_0}{X\_1}$.</span></span> <span data-ttu-id="e7296-187">這是有效的 Hamiltonian，只需要2個 qubits，其中 $g $ 的常數是從兩個 Hydrogen 原子之間的距離 $R $ 計算而來。</span><span class="sxs-lookup"><span data-stu-id="e7296-187">This is an effective Hamiltonian only requiring only 2 qubits, where the constants $g$ are computed from the distance $R$ between the two Hydrogen atoms.</span></span> <span data-ttu-id="e7296-188">使用 canon 函數，Paulis 會轉換成 unitaries，然後使用 Trotter-Plat'home co. 分解，在短時間內演變。</span><span class="sxs-lookup"><span data-stu-id="e7296-188">Using canon functions, the Paulis are converted to unitaries and then evolved over short periods of time using the Trotter-Suzuki decomposition.</span></span> <span data-ttu-id="e7296-189">在不使用 adiabatic 狀態準備的情況下，您可以建立 $H _2 $ 地面狀態的良好近似值，因此可以利用來自 canon 的階段估計，直接找到基礎狀態的能源。</span><span class="sxs-lookup"><span data-stu-id="e7296-189">A good approximation to the $H_2$ ground state can be created without using adiabatic state preparation, and so the ground state energy may be found directly by utilizing phase estimation from the canon.</span></span>

## <a name="shors-algorithm"></a><span data-ttu-id="e7296-190">快速鍵的演算法</span><span class="sxs-lookup"><span data-stu-id="e7296-190">Shor's Algorithm</span></span> ##
<span data-ttu-id="e7296-191">快速鍵的演算法仍然是配量計算的其中一個最重要的發展，因為它顯示配量電腦可用來解決重要、目前傳統方式的棘手問題。</span><span class="sxs-lookup"><span data-stu-id="e7296-191">Shor's algorithm remains one of the most significant developments in quantum computing because it showed that quantum computers could be used to solve important, currently classically intractable problems.</span></span>
<span data-ttu-id="e7296-192">快速鍵的演算法提供了一種快速的方法，讓您使用量子電腦來將大量數位納入考慮，此問題稱為「*分解*」。</span><span class="sxs-lookup"><span data-stu-id="e7296-192">Shor's algorithm provides a fast way to factor large numbers using a quantum computer, a problem called *factoring*.</span></span>
<span data-ttu-id="e7296-193">許多當日 cryptosystems 的安全性是根據假設沒有任何快速演算法可進行分解。</span><span class="sxs-lookup"><span data-stu-id="e7296-193">The security of many present-day cryptosystems is based on the assumption that no fast algorithm exists for factoring.</span></span>
<span data-ttu-id="e7296-194">因此，快速鍵的演算法對於我們在後量子世界中的安全性考慮有深遠的影響。</span><span class="sxs-lookup"><span data-stu-id="e7296-194">Thus Shor's algorithm has had a profound impact on how we think about security in a post-quantum world.</span></span>

<span data-ttu-id="e7296-195">快速鍵的演算法可以視為混合式演算法。</span><span class="sxs-lookup"><span data-stu-id="e7296-195">Shor's algorithm can be thought of as a hybrid algorithm.</span></span>
<span data-ttu-id="e7296-196">量子電腦是用來執行所謂的運算硬性工作，稱為「期間尋找」。</span><span class="sxs-lookup"><span data-stu-id="e7296-196">The quantum computer is used to perform a computationally hard task known as period finding.</span></span>
<span data-ttu-id="e7296-197">然後會傳統方式處理期間尋找的結果來估計因素。</span><span class="sxs-lookup"><span data-stu-id="e7296-197">The results from period finding are then classically processed to estimate the factors.</span></span>
<span data-ttu-id="e7296-198">我們會在下列兩個步驟中進行檢查。</span><span class="sxs-lookup"><span data-stu-id="e7296-198">We review these two steps below.</span></span>

### <a name="period-finding"></a><span data-ttu-id="e7296-199">期間尋找</span><span class="sxs-lookup"><span data-stu-id="e7296-199">Period Finding</span></span> ###

<span data-ttu-id="e7296-200">瞭解配量傅立葉轉換和階段估計的工作（請參閱[量子演算法](xref:microsoft.quantum.libraries.standard.algorithms)），我們可以使用這些工具來解決傳統方式的硬運算問題，稱為*期間尋找*。</span><span class="sxs-lookup"><span data-stu-id="e7296-200">Having seen how the quantum Fourier transform and phase estimation work (see [Quantum algorithms](xref:microsoft.quantum.libraries.standard.algorithms)), we can use these tools to solve a classically hard computational problem called *period finding*.</span></span>  <span data-ttu-id="e7296-201">在下一節中，我們將瞭解如何套用期間尋找以進行分解。</span><span class="sxs-lookup"><span data-stu-id="e7296-201">In the next section, we will see how to apply period finding to factoring.</span></span>

<span data-ttu-id="e7296-202">假設有兩個整數 $a $ 和 $N $，其中 $a < N $，期間尋找的目標（也稱為「訂單尋找」）是尋找 $r $ 模數 $a $ 的_順序_$N $，其中 $r $ 已定義為最小正整數，例如 $a ^ r \equiv 1 \text{Mod} N $。</span><span class="sxs-lookup"><span data-stu-id="e7296-202">Given two integers $a$ and $N$, where $a<N$, the goal of period finding, also called order finding, is to find the _order_ $r$ of $a$ modulo $N$, where $r$ is defined to be the least positive integer such that $a^r \equiv 1 \text{ mod } N$.</span></span>  

<span data-ttu-id="e7296-203">若要使用量子電腦來尋找訂單，我們可以使用套用至下列單一運算子的階段估計演算法 $U _a $： $ $ U_a \ket{x} \equiv \ket{（ax） \text{mod} N}. $ $ 特徵向量 of $U _a $ 適用于 integer $s $ 和 $ 0 \ leq s \leq r-$1，$ $ \ket{x_s} \equiv 1/\sqrt{r} \sum\_{k = 0} ^ {r-1} e ^ {\frac{-2\pi i sk} {r}} \ket{a ^ k\text {mod} N}，$ $ 是 $U _a $ 的_eigenstates_ 。</span><span class="sxs-lookup"><span data-stu-id="e7296-203">To find the order using a quantum computer, we can use the phase estimation algorithm applied to the following unitary operator $U_a$: $$ U_a\ket{x} \equiv \ket{(ax)\text{ mod }N} .$$ The eigenvectors of $U_a$ are for integer $s$ and $0\leq s \leq r - 1$, $$\ket{x_s} \equiv 1 / \sqrt{r} \sum\_{k=0}^{r-1} e^{\frac{-2\pi i sk}{r}} \ket{a^k\text{ mod }N},$$ are _eigenstates_ of $U_a$.</span></span>
<span data-ttu-id="e7296-204">$U _a $ 的特徵值是 $ $ U\_\ket{x\_s} = e ^ {2 \ pi i s/r} \ket{x\_s}。</span><span class="sxs-lookup"><span data-stu-id="e7296-204">The eigenvalues of $U_a$ are $$ U\_a \ket{x\_s} = e^{2\pi i s / r} \ket{x\_s} .</span></span> $$

<span data-ttu-id="e7296-205">第一階段估計會輸出特徵值 $e ^ {2 \ pi i s/r} $，其中 $r $ 可以使用 $s/r $ 的[接續分數](https://en.wikipedia.org/wiki/Continued_fraction)有效率地學習。</span><span class="sxs-lookup"><span data-stu-id="e7296-205">Phase estimation thus outputs the eigenvalues $e^{2\pi i s / r}$ from which $r$ can be learned efficiently using [continued fractions](https://en.wikipedia.org/wiki/Continued_fraction) from $s / r$.</span></span>

<span data-ttu-id="e7296-206">配量期間的線路圖表如下：</span><span class="sxs-lookup"><span data-stu-id="e7296-206">The circuit diagram for quantum period finding is:</span></span>

![](./../../media/QPE.svg)

<span data-ttu-id="e7296-207">這裡 $ 2n $ qubits 會初始化為 $ \ket{0}$，$n $ qubits 會初始化為 $ \ket{1}$。</span><span class="sxs-lookup"><span data-stu-id="e7296-207">Here $2n$ qubits are initialized to $\ket{0}$ and $n$ qubits are initialized to $\ket{1}$.</span></span>
<span data-ttu-id="e7296-208">讀者可能會想知道，eigenstates 的量子暫存器為何會初始化為 $ \ket{1}$。</span><span class="sxs-lookup"><span data-stu-id="e7296-208">The reader again may wonder why the quantum register to hold the eigenstates is initialized to $\ket{1}$.</span></span>
<span data-ttu-id="e7296-209">因為一個人事先不知道訂單 $r $，所以我們無法直接準備 $ \ket{x_s} $ 狀態。</span><span class="sxs-lookup"><span data-stu-id="e7296-209">As one does not know the order $r$ in advance, we cannot actually prepare $\ket{x_s}$ states directly.</span></span>
<span data-ttu-id="e7296-210">幸運的是，$ 1/\ sqrt {r} \sum\_{s = 0} ^ {r-1} \ket{x\_s} = \ket{1}$。</span><span class="sxs-lookup"><span data-stu-id="e7296-210">Luckily, it turns out that $1/\sqrt{r} \sum\_{s=0}^{r-1} \ket{x\_s} = \ket{1}$.</span></span>
<span data-ttu-id="e7296-211">我們不需要實際準備 $ \ket{x} $！</span><span class="sxs-lookup"><span data-stu-id="e7296-211">We don't need to actually prepare $\ket{x}$!</span></span>
<span data-ttu-id="e7296-212">我們可以只在 state $ \ket{1}$ 中準備 $n $ qubits 的量子暫存器。</span><span class="sxs-lookup"><span data-stu-id="e7296-212">We can just prepare a quantum register of $n$ qubits in state $\ket{1}$.</span></span> 

<span data-ttu-id="e7296-213">線路包含 QFT 和數個受控制的閘道。</span><span class="sxs-lookup"><span data-stu-id="e7296-213">The circuit contains the QFT and several controlled gates.</span></span>
<span data-ttu-id="e7296-214">[先前](xref:microsoft.quantum.libraries.standard.algorithms)已說明過 QFT 閘道。</span><span class="sxs-lookup"><span data-stu-id="e7296-214">The QFT gate has been described [previously](xref:microsoft.quantum.libraries.standard.algorithms).</span></span>
<span data-ttu-id="e7296-215">如果控制項 qubit 是 $ \ket{1}$，受控制的 $U _a $ 閘道會將 $ \ket{x} $ 對應至 $ \ket{（ax） \text{mod} N} $，否則會將 $ \ket{x} $ 對應至 $ \ket{x} $。</span><span class="sxs-lookup"><span data-stu-id="e7296-215">The controlled-$U_a$ gate maps $\ket{x}$ to $\ket{(ax)\text{ mod } N}$ if the control qubit is $\ket{1}$, and maps $\ket{x}$ to $\ket{x}$ otherwise.</span></span>

<span data-ttu-id="e7296-216">若要達到 $ （a ^ nx） \text{mod} N $，我們可以直接套用受控制的 $U _ {a ^ n} $，其中我們會計算 $a ^ N \text{mod} N $ 傳統方式以插入量子線路。</span><span class="sxs-lookup"><span data-stu-id="e7296-216">To achieve $(a^nx)\text{ mod } N$,  we can simply apply controlled-$U_{a^n}$, where we calculate $a^n \text{ mod } N$ classically to plug into the quantum circuit.</span></span>  
<span data-ttu-id="e7296-217">如需達成這類別模組化算術的線路，請參閱[量子算術檔](./algorithms.md#arithmetic)，特別是我們需要模組化乘冪來執行受控制的 $U\_{a ^ i} $ 作業。</span><span class="sxs-lookup"><span data-stu-id="e7296-217">The circuits to achieve such modular arithmetic have been described in the [quantum arithmetic documentation](./algorithms.md#arithmetic), specifically we require a modular exponentiation circuit to implement the controlled-$U\_{a^i}$ operations.</span></span>

<span data-ttu-id="e7296-218">雖然上述線路對應至配量[階段估計](xref:microsoft.quantum.characterization.quantumphaseestimation)，並明確啟用訂單尋找，但我們可以減少所需的 qubits 數目。</span><span class="sxs-lookup"><span data-stu-id="e7296-218">While the circuit above corresponds to [Quantum Phase Estimation](xref:microsoft.quantum.characterization.quantumphaseestimation) and explicitly enables order finding, we can reduce the number of qubits required.</span></span> <span data-ttu-id="e7296-219">我們可以依照[arXiv： quant-ph/0205095v3 的第8頁](https://arxiv.org/pdf/quant-ph/0205095v3.pdf#page=8)中所述的順序尋找 Beauregard 的方法，或使用中提供的其中一個階段估計常式。</span><span class="sxs-lookup"><span data-stu-id="e7296-219">We can either follow Beauregard's method for order finding as described [on Page 8 of arXiv:quant-ph/0205095v3](https://arxiv.org/pdf/quant-ph/0205095v3.pdf#page=8), or use one of the phase estimation routines available in Microsoft.Quantum.Canon.</span></span> <span data-ttu-id="e7296-220">例如，[健全的階段估計](xref:microsoft.quantum.characterization.robustphaseestimation)也會使用一個額外的 qubit。</span><span class="sxs-lookup"><span data-stu-id="e7296-220">For example, [Robust Phase Estimation](xref:microsoft.quantum.characterization.robustphaseestimation) also uses one extra qubit.</span></span>
 
### <a name="factoring"></a><span data-ttu-id="e7296-221">出來</span><span class="sxs-lookup"><span data-stu-id="e7296-221">Factoring</span></span> ###
<span data-ttu-id="e7296-222">「分解」的目標是要判斷兩個整數 $N $ 的主要因素，其中 $N $ 是 $n $ 位數位。</span><span class="sxs-lookup"><span data-stu-id="e7296-222">The goal of factoring is to determine the two prime factors of integer $N$, where $N$ is an $n$-bit number.</span></span>  
<span data-ttu-id="e7296-223">「分解」包含如下所述的步驟。</span><span class="sxs-lookup"><span data-stu-id="e7296-223">Factoring consists of the steps described below.</span></span> <span data-ttu-id="e7296-224">這些步驟分成三個部分：傳統前置處理常式（1-4）;用來尋找 $a \text{mod} N $ （5）順序的量子計算常式;和傳統的後處理常式，以衍生訂單的主要因數（6-9）。</span><span class="sxs-lookup"><span data-stu-id="e7296-224">The steps are split into three parts: a classical preprocessing routine (1-4); a quantum computing routine to find the order of $a \text{ mod } N$ (5); and a classical postprocessing routine to derive the prime factors from the order (6-9).</span></span>

<span data-ttu-id="e7296-225">傳統前置處理常式包含下列步驟：</span><span class="sxs-lookup"><span data-stu-id="e7296-225">The classical preprocessing routine consists of the following steps:</span></span>
1. <span data-ttu-id="e7296-226">如果 $N $ 為偶數，則傳回質數因數 $2 $。</span><span class="sxs-lookup"><span data-stu-id="e7296-226">If $N$ is even, return the prime factor $2$.</span></span>
2. <span data-ttu-id="e7296-227">如果 $N = p ^ q $ for $p \geq1 $，$q \geq2 $，則傳回 $p $ 的主要因數。</span><span class="sxs-lookup"><span data-stu-id="e7296-227">If $N=p^q$ for $p\geq1$, $q\geq2$, return the prime factor $p$.</span></span>  <span data-ttu-id="e7296-228">此步驟執行傳統方式。</span><span class="sxs-lookup"><span data-stu-id="e7296-228">This step is performed classically.</span></span>
3. <span data-ttu-id="e7296-229">選擇 $a $ 的亂數字，讓 $1 < < N-$1。</span><span class="sxs-lookup"><span data-stu-id="e7296-229">Choose a random number $a$ such that $1 < a < N-1$.</span></span>
4. <span data-ttu-id="e7296-230">如果 $ \text{gcd} （a，N） > 1 $，則傳回主要因數 $ \text{gcd} （a，N） $。</span><span class="sxs-lookup"><span data-stu-id="e7296-230">If $\text{gcd}(a,N)>1$, return the prime factor $\text{gcd}(a,N)$.</span></span> <span data-ttu-id="e7296-231">此步驟是使用 Euclid 的演算法來計算。</span><span class="sxs-lookup"><span data-stu-id="e7296-231">This step is computed using Euclid's algorithm.</span></span>
<span data-ttu-id="e7296-232">如果未傳回任何主要因素，我們會繼續進行量副程式：</span><span class="sxs-lookup"><span data-stu-id="e7296-232">If no prime factor has been returned, we proceed to the quantum routine:</span></span>
5. <span data-ttu-id="e7296-233">呼叫配量期間尋找演算法，以計算 $a \text{mod} N $ 的 order $r $。</span><span class="sxs-lookup"><span data-stu-id="e7296-233">Call the quantum period finding algorithm to calculate the order $r$ of $a \text{ mod } N$.</span></span> <span data-ttu-id="e7296-234">在傳統的後處理常式中使用 $r $ 來判斷主要因素：</span><span class="sxs-lookup"><span data-stu-id="e7296-234">Use $r$ in the classical postprocessing routine to determine the prime factors:</span></span>
6. <span data-ttu-id="e7296-235">如果 $r $ 是奇數，請回到前置處理步驟（3）。</span><span class="sxs-lookup"><span data-stu-id="e7296-235">If $r$ is odd, go back to preprocessing step (3).</span></span>
7. <span data-ttu-id="e7296-236">如果 $r $ 是偶數，$a ^ {r/2} =-1 \ 文字 {mod} N $，請回到前置處理步驟（3）。</span><span class="sxs-lookup"><span data-stu-id="e7296-236">If $r$ is even and $a^{r/2} = -1\text{ mod }N$, go back to preprocessing step (3).</span></span>
8. <span data-ttu-id="e7296-237">如果 $ \text{gcd} （^ {r/2} + 1，N） $ 是 $N $ 的非一般因素，則會傳回 $ \text{gcd} （a ^ {r/2} + 1，N） $。</span><span class="sxs-lookup"><span data-stu-id="e7296-237">If $\text{gcd}(a^{r/2}+1, N)$ is a non-trivial factor of $N$, return $\text{gcd}(a^{r/2}+1, N)$.</span></span>
9. <span data-ttu-id="e7296-238">如果 $ \text{gcd} （^ {r/2}-1，N） $ 是 $N $ 的非一般因素，則會傳回 $ \text{gcd} （a ^ {r/2}-1，N） $。</span><span class="sxs-lookup"><span data-stu-id="e7296-238">If $\text{gcd}(a^{r/2}-1, N)$ is a non-trivial factor of $N$, return $\text{gcd}(a^{r/2}-1, N)$.</span></span>


<span data-ttu-id="e7296-239">「分解演算法」（概率）：可顯示的機率至少為一一半，$r $ 會是偶數，$a ^ {r/2} \neq-1 \text{mod} N $，因而產生一個主要因素。</span><span class="sxs-lookup"><span data-stu-id="e7296-239">The factoring algorithm is probabilistic: it can been shown that with probability at least one half that $r$ will be even and $a^{r/2} \neq -1 \text{ mod }N$, thus producing a prime factor.</span></span>  <span data-ttu-id="e7296-240">（如需詳細[資訊](xref:microsoft.quantum.more-information)，請參閱[快速鍵的原始](https://doi.org/10.1109/SFCS.1994.365700)檔，或中的其中一個*基本量子計算*文字）。</span><span class="sxs-lookup"><span data-stu-id="e7296-240">(See [Shor's original paper](https://doi.org/10.1109/SFCS.1994.365700) for details, or one of the *Basic quantum computing* texts in [For more information](xref:microsoft.quantum.more-information)).</span></span>
<span data-ttu-id="e7296-241">如果未傳回主要因素，我們只需重複步驟（1）中的演算法。</span><span class="sxs-lookup"><span data-stu-id="e7296-241">If a prime factor is not returned, then we simply repeat the algorithm from step (1).</span></span>  <span data-ttu-id="e7296-242">$N $ 嘗試之後，每次嘗試失敗的機率最多為 $ 2 ^ {-n} $。</span><span class="sxs-lookup"><span data-stu-id="e7296-242">After $n$ tries, the probability that every attempt has failed is at most $2^{-n}$.</span></span>
<span data-ttu-id="e7296-243">因此，在重複演算法之後，幾乎都能確保成功的次數。</span><span class="sxs-lookup"><span data-stu-id="e7296-243">Thus after repeating the algorithm a small number of times success is virtually assured.</span></span>
