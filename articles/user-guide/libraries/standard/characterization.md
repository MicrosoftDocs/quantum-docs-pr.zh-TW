---
title: 量子特性和統計資料
description: 瞭解階段估計的測量統計資料如何用來估計量副程式設計中的結果值。
author: QuantumWriter
uid: microsoft.quantum.libraries.characterization
ms.author: martinro@microsoft.com
ms.date: 12/11/2017
ms.topic: article
ms.openlocfilehash: 9d763d11ef9c08cc0941cade217dbb2942ef4bf9
ms.sourcegitcommit: 2f4c637e194dc2b5d18539469ed37444e2800199
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 07/30/2020
ms.locfileid: "87436526"
---
# <a name="quantum-characterization-and-statistics"></a><span data-ttu-id="2ded0-103">量子特性和統計資料</span><span class="sxs-lookup"><span data-stu-id="2ded0-103">Quantum Characterization and Statistics</span></span> #

<span data-ttu-id="2ded0-104">務必要能夠描述作業的效果，以便開發有用的配量演算法。</span><span class="sxs-lookup"><span data-stu-id="2ded0-104">It is critical to be able to characterize the effects of operations in order to develop useful quantum algorithms.</span></span>
<span data-ttu-id="2ded0-105">這是一項挑戰，因為每個配量系統的測量最多隻會產生一位資訊。</span><span class="sxs-lookup"><span data-stu-id="2ded0-105">This is challenging because every measurement of a quantum system yields at most one bit of information.</span></span>
<span data-ttu-id="2ded0-106">若要瞭解 eigenvalue，請單獨讓一個配量狀態，許多度量的結果都必須拼接在一起，讓使用者能夠搜集所需的許多資訊來表示這些概念。</span><span class="sxs-lookup"><span data-stu-id="2ded0-106">In order to learn an eigenvalue, let alone a quantum state, the results of many measurements must be stitched together so that the user can glean the many bits of information needed to represent these concepts.</span></span>
<span data-ttu-id="2ded0-107">配量狀態特別令人傷腦筋，因為[沒有任何](xref:microsoft.quantum.concepts.pauli#the-no-cloning-theorem)複製的定理指出無法從單一狀態複本學習任意的量子狀態，因為這樣做可讓您建立狀態的複本。</span><span class="sxs-lookup"><span data-stu-id="2ded0-107">Quantum states are especially vexing because the [no-cloning theorem](xref:microsoft.quantum.concepts.pauli#the-no-cloning-theorem) states that there is no way to learn an arbitrary quantum state from a single copy of the state, because doing so would let you make copies of the state.</span></span>
<span data-ttu-id="2ded0-108">這會反映使用者的量子狀態混淆，這是因為問 # 並未公開或甚至定義量副程式*的狀態。*</span><span class="sxs-lookup"><span data-stu-id="2ded0-108">This obfuscation of the quantum state from the user is reflected in the fact that Q# does not expose or even define what a state *is* to quantum programs.</span></span>
<span data-ttu-id="2ded0-109">因此，我們藉由將作業和狀態視為全黑箱，來處理量子的特性;這種方法與量子特性、驗證和驗證（QCVV）的實驗性做法共同共通。</span><span class="sxs-lookup"><span data-stu-id="2ded0-109">We thus approach quantum characterization by treating operations and states as black-box; this approach shares much in common with the experimental practice of quantum characterization, verification and validation (QCVV).</span></span>

<span data-ttu-id="2ded0-110">特性與先前討論的許多其他程式庫不同。</span><span class="sxs-lookup"><span data-stu-id="2ded0-110">Characterization is distinct from many of the other libraries discussed previously.</span></span>
<span data-ttu-id="2ded0-111">這裡的目標是要瞭解有關系統的傳統資訊，而不是在狀態向量上執行單一轉換。</span><span class="sxs-lookup"><span data-stu-id="2ded0-111">The aim here is less to learn classical information about the system, rather than to perform a unitary transformation on a state vector.</span></span>
<span data-ttu-id="2ded0-112">因此，這些程式庫必須混合傳統和量子資訊的處理。</span><span class="sxs-lookup"><span data-stu-id="2ded0-112">These libraries must therefore blend both classical and quantum information processing.</span></span>


## <a name="iterative-phase-estimation"></a><span data-ttu-id="2ded0-113">反復階段估計</span><span class="sxs-lookup"><span data-stu-id="2ded0-113">Iterative Phase Estimation</span></span> ##

<span data-ttu-id="2ded0-114">根據量子特性來查看配量程式設計，會建議對量子階段估計有用的替代方法。</span><span class="sxs-lookup"><span data-stu-id="2ded0-114">Viewing quantum programming in terms of quantum characterization suggests a useful alternative to quantum phase estimation.</span></span>
<span data-ttu-id="2ded0-115">也就是說，我們可以將階段估計視為*傳統*代理程式透過測量來學習量子系統屬性的過程，而不是準備 $n $ qubit 暫存器包含階段的二進位標記法。</span><span class="sxs-lookup"><span data-stu-id="2ded0-115">That is, instead of preparing an $n$-qubit register to contain a binary representation of the phase as in quantum phase estimation, we can view phase estimation as the process by which a *classical* agent learns properties of a quantum system through measurements.</span></span>
<span data-ttu-id="2ded0-116">我們會在量子案例中繼續進行，方法是使用階段 kickback，將黑色方塊作業的應用程式轉換成未知的角度旋轉，但會測量在旋轉後緊接在每個步驟中旋轉的 ancilla qubit。</span><span class="sxs-lookup"><span data-stu-id="2ded0-116">We proceed as in the quantum case by using phase kickback to turn applications of a black-box operation into rotations by an unknown angle, but will measure the ancilla qubit that we rotate at each step immediately following the rotation.</span></span>
<span data-ttu-id="2ded0-117">這有個優點，我們只需要一個額外的 qubit 來執行量子案例中所述的階段 kickback，因為我們接著會以反復的方式從每個步驟的測量結果中學習階段。</span><span class="sxs-lookup"><span data-stu-id="2ded0-117">This has the advantage that we only require a single additional qubit to perform the phase kickback described in the quantum case, as we then learn the phase from the measurement results at each step in an iterative fashion.</span></span>  
<span data-ttu-id="2ded0-118">下面所提議的每一種方法，都使用不同的策略來設計實驗和不同的資料處理方法，以瞭解階段。</span><span class="sxs-lookup"><span data-stu-id="2ded0-118">Each of the methods proposed below uses a different strategy for designing experiments and different data processing methods to learn the phase.</span></span>  <span data-ttu-id="2ded0-119">它們各有獨特的優勢，範圍從具有嚴格的錯誤界限，到納入先前資訊的能力、容許錯誤或在記憶體 limitted 的傳統電腦上執行。</span><span class="sxs-lookup"><span data-stu-id="2ded0-119">They each have unique advantage ranging from having rigorous error bounds, to the abilities to incorporate prior information, tolerate errors or run on memory limitted classical computers.</span></span>

<span data-ttu-id="2ded0-120">在討論反復的階段估計時，我們會考慮將單一 $U $ 指定為黑箱作業。</span><span class="sxs-lookup"><span data-stu-id="2ded0-120">In discussing iterative phase estimation, we will consider a unitary $U$ given as a black-box operation.</span></span>
<span data-ttu-id="2ded0-121">如[資料結構](xref:microsoft.quantum.libraries.data-structures)中的 oracles 一節所述，Q # canon 會依照 <xref:microsoft.quantum.oracles.discreteoracle> 使用者定義型別（由元組類型定義）來進行作業 `((Int, Qubit[]) => Unit : Adjoint, Controlled)` 。</span><span class="sxs-lookup"><span data-stu-id="2ded0-121">As described in the section on oracles in [data structures](xref:microsoft.quantum.libraries.data-structures), the Q# canon models such operations by the <xref:microsoft.quantum.oracles.discreteoracle> user-defined type, defined by the tuple type `((Int, Qubit[]) => Unit : Adjoint, Controlled)`.</span></span>
<span data-ttu-id="2ded0-122">具體而言，若 `U : DiscreteOracle` 為，則會 `U(m)` 為 $U 的 ^ m $ `m : Int` 。</span><span class="sxs-lookup"><span data-stu-id="2ded0-122">Concretely, if `U : DiscreteOracle`, then `U(m)` implements $U^m$ for `m : Int`.</span></span>

<span data-ttu-id="2ded0-123">有了這個定義之後，反復階段估計的每個步驟 $U 就會繼續進行 $ \ket{+} $ 狀態的輔助 qubit，以及[我們假設的](xref:microsoft.quantum.concepts.matrix-advanced)初始狀態 $ \ket{\phi} $，亦即 $U （m） \ket{\phi} = e ^ {im\phi} \ ket {\ phi} $。</span><span class="sxs-lookup"><span data-stu-id="2ded0-123">With this definition in place, each step of iterative phase estimation proceeds by preparing an auxiliary qubit in the $\ket{+}$ state along with the initial state $\ket{\phi}$ that we assume is an [eigenvector](xref:microsoft.quantum.concepts.matrix-advanced) of $U(m)$, i.e. $U(m)\ket{\phi}= e^{im\phi}\ket{\phi}$.</span></span>  
<span data-ttu-id="2ded0-124">接著會使用的受控制應用程式來 `U(m)` 準備 state $ \left （R \_ 1 （m \phi） \ket{+} \right） \ket{\phi} $。</span><span class="sxs-lookup"><span data-stu-id="2ded0-124">A controlled application of `U(m)` is then used which prepares the state $\left(R\_1(m \phi) \ket{+}\right)\ket{\phi}$.</span></span>
<span data-ttu-id="2ded0-125">如同在量子案例中，受控制的 oracle 應用程式的效果與在 `U(m)` $ \ket{+} $ 的未知階段套用 $R _1 $ 的效果完全相同，因此我們可以更簡單的方式來描述 $U $ 的效果。</span><span class="sxs-lookup"><span data-stu-id="2ded0-125">As in the quantum case, the effect of a controlled application of the oracle `U(m)` is precisely the same as the effect of applying $R_1$ for the unknown phase on $\ket{+}$, such that we can describe the effects of $U$ in this simpler fashion.</span></span>
<span data-ttu-id="2ded0-126">接著，此演算法會藉由套用 $R _1 （-m\theta） $ 來取得 state $ \ket{\psi} = \left （R \_ 1 （m [\phi-\theta]） \ket{+} \right） \ket{\phi} $ $，以旋轉控制項 qubit。</span><span class="sxs-lookup"><span data-stu-id="2ded0-126">Optionally, the algorithm then rotates the control qubit by applying $R_1(-m\theta)$ to obtain a state $\ket{\psi}=\left(R\_1(m [\phi-\theta]) \ket{+}\right)\ket{\phi}$$.</span></span>
<span data-ttu-id="2ded0-127">作為控制項使用的輔助 qubit， `U(m)` 接著會以 $X $ 基準測量，以取得單一的傳統 `Result` 。</span><span class="sxs-lookup"><span data-stu-id="2ded0-127">The auxiliary qubit used as a control for `U(m)` is then measured in the $X$ basis to obtain a single classical `Result`.</span></span>

<span data-ttu-id="2ded0-128">此時，從 `Result` 透過反復階段估計取得的值來重建階段，是一種傳統的統計推斷問題。</span><span class="sxs-lookup"><span data-stu-id="2ded0-128">At this point, reconstructing the phase from the `Result` values obtained through iterative phase estimation is a classical statistical inference problem.</span></span>
<span data-ttu-id="2ded0-129">找出最大化所取得之資訊的 $m $ 值，只是統計資料中的問題。</span><span class="sxs-lookup"><span data-stu-id="2ded0-129">Finding the value of $m$ that maximizes the information gained, given a fixed inference method, is simply a problem in statistics.</span></span>
<span data-ttu-id="2ded0-130">我們藉由在貝氏參數估計形式中簡要說明理論層級的反復階段估計，然後再繼續描述 Q # canon 中提供的統計演算法來解決此傳統推斷問題，以強調這一點。</span><span class="sxs-lookup"><span data-stu-id="2ded0-130">We emphasize this by briefly describing iterative phase estimation at a theoretical level in the Bayesian parameter estimation formalism before proceeding to describe the statistical algorithms provided in the Q# canon for solving this classical inference problem.</span></span>

### <a name="iterative-phase-estimation-without-eigenstates"></a><span data-ttu-id="2ded0-131">不 Eigenstates 的反復階段估計</span><span class="sxs-lookup"><span data-stu-id="2ded0-131">Iterative Phase Estimation Without Eigenstates</span></span> ###

<span data-ttu-id="2ded0-132">如果提供的輸入狀態不是 eigenstate，也就是假設如果 $U （m） \ket{\phi \_ j} = e ^ {im\phi \_ j} $，則階段估計的程式會以不確定的方式，將配量狀態引導至單一能源 eigenstate。</span><span class="sxs-lookup"><span data-stu-id="2ded0-132">If an input state is provided that is not an eigenstate, which is to say that if $U(m)\ket{\phi\_j} = e^{im\phi\_j}$ then the process of phase estimation non-deterministically guides the quantum state towards a single energy eigenstate.</span></span>  <span data-ttu-id="2ded0-133">最後聚合的 eigenstate 是最有可能產生觀察到的 eigenstate `Result` 。</span><span class="sxs-lookup"><span data-stu-id="2ded0-133">The eigenstate it ultimately converges to is the eigenstate that is most likely to produce the observed `Result`.</span></span>

<span data-ttu-id="2ded0-134">具體而言，PE 的單一步驟會在狀態 \begin{align} \ sum_j \sqrt{\Pr （\phi \_ j）} \ket{\phi \_ j} \mapsto \sum \_ j\frac {\ Sqrt {\ Pr （\phi \_ j）} \sqrt{\Pr （\text{Result} | \phi j）} \ket{\phi j \_ \_ }} {\sqrt{\Pr （\phi \_ j） \sum \_ j \Pr （\text{Result} | \phi \_ j）}} 上執行下列非單一的轉換。</span><span class="sxs-lookup"><span data-stu-id="2ded0-134">Specifically, a single step of PE performs the following non-unitary transformation on a state \begin{align} \sum_j \sqrt{\Pr(\phi\_j)} \ket{\phi\_j} \mapsto \sum\_j\frac{\sqrt{\Pr(\phi\_j)}\sqrt{\Pr(\text{Result}|\phi\_j)}\ket{\phi\_j}}{\sqrt{\Pr(\phi\_j)\sum\_j \Pr(\text{Result}|\phi\_j)}}.</span></span>
<span data-ttu-id="2ded0-135">\end{align} 因為此程式會反復執行多個 `Result` 值，所以不具有 $ \ prod_k \pr （\text{Result} \_ k | \phi j） $ 的最大值的 eigenstates 將會以 \_ 指數方式隱藏。</span><span class="sxs-lookup"><span data-stu-id="2ded0-135">\end{align} As this process is iterated over multiple `Result` values, eigenstates that do not have maximal values of $\prod_k\Pr(\text{Result}\_k|\phi\_j)$ will be exponentially suppressed.</span></span>
<span data-ttu-id="2ded0-136">因此，如果已正確選擇實驗，則推斷程式通常會聚合成具有單一 eigenvalue 的狀態。</span><span class="sxs-lookup"><span data-stu-id="2ded0-136">As a result, the inference process will tend to converge to states with a single eigenvalue if the experiments are chosen properly.</span></span>

<span data-ttu-id="2ded0-137">貝氏機率分類 ' 定理更進一步的說明，階段估計所產生的狀態是以 \begin{align} \frac{\sqrt{\Pr （\phi \_ j）} \sqrt{\Pr 格式（\text{Result} | \phi \_ j）} \ket{\phi \_ j}} {\sqrt{\Pr （\phi \_ j） \Sum \_ j \Pr （\text{Result} | \phi \_ j）}} = \ sum_j \sqrt{\Pr （\phi \_ j | \text{Result}）} \ket{\phi \_ j} 的形式寫入。</span><span class="sxs-lookup"><span data-stu-id="2ded0-137">Bayes' theorem further suggests that the state that results from phase estimation be written in the form \begin{align} \frac{\sqrt{\Pr(\phi\_j)}\sqrt{\Pr(\text{Result}|\phi\_j)}\ket{\phi\_j}}{\sqrt{\Pr(\phi\_j)\sum\_j \Pr(\text{Result}|\phi\_j)}}=\sum_j \sqrt{\Pr(\phi\_j|\text{Result})} \ket{\phi\_j}.</span></span>
<span data-ttu-id="2ded0-138">\end{align} 這裡 $ \Pr （\phi \_ j | \text{Result}） $ 可以解釋為每個假設有關于 ascribe 的機率：</span><span class="sxs-lookup"><span data-stu-id="2ded0-138">\end{align} Here $\Pr(\phi\_j|\text{Result})$ can be interpretted as the probability that one would ascribe to each hypothesis about the eigenstates given:</span></span>

1. <span data-ttu-id="2ded0-139">測量之前的量子狀態知識，</span><span class="sxs-lookup"><span data-stu-id="2ded0-139">knowledge of the quantum state prior to measurement,</span></span>
2. <span data-ttu-id="2ded0-140">$U $ 和的 eigenstates 知識</span><span class="sxs-lookup"><span data-stu-id="2ded0-140">knowledge of the eigenstates of $U$ and,</span></span>
3. <span data-ttu-id="2ded0-141">$U $ 的特徵值知識。</span><span class="sxs-lookup"><span data-stu-id="2ded0-141">knowledge of the eigenvalues of $U$.</span></span>

<span data-ttu-id="2ded0-142">學習這三件事通常在傳統電腦上會有指數的困難。</span><span class="sxs-lookup"><span data-stu-id="2ded0-142">Learning these three things is often exponentially hard on a classical computer.</span></span>
<span data-ttu-id="2ded0-143">第一階段估計的公用程式不是很小的範圍，因為它可以執行這類的量子學習工作，而不需要知道其中任何一項。</span><span class="sxs-lookup"><span data-stu-id="2ded0-143">The utility of phase estimation arises, to no small extent, from the fact that it can perform such a quantum learning task without knowing any of them.</span></span>
<span data-ttu-id="2ded0-144">此原因的階段估計會出現在提供指數加速的一些量子演算法內。</span><span class="sxs-lookup"><span data-stu-id="2ded0-144">Phase estimation for this reason appears within a number of quantum algorithms that provide exponential speedups.</span></span>

### <a name="bayesian-phase-estimation"></a><span data-ttu-id="2ded0-145">貝氏階段估計</span><span class="sxs-lookup"><span data-stu-id="2ded0-145">Bayesian Phase Estimation</span></span> ###

> [!TIP]
> <span data-ttu-id="2ded0-146">如需在實務中貝氏階段估計的詳細資訊，請參閱[**PhaseEstimation**](https://github.com/microsoft/Quantum/tree/master/samples/characterization/phase-estimation)範例。</span><span class="sxs-lookup"><span data-stu-id="2ded0-146">For more details on Bayesian phase estimation in practice, please see the [**PhaseEstimation**](https://github.com/microsoft/Quantum/tree/master/samples/characterization/phase-estimation) sample.</span></span>

<span data-ttu-id="2ded0-147">貝氏階段估計的概念很簡單。</span><span class="sxs-lookup"><span data-stu-id="2ded0-147">The idea of Bayesian phase estimation is simple.</span></span>
<span data-ttu-id="2ded0-148">您可以從階段估計通訊協定收集測量統計資料，然後使用貝氏推斷來處理結果，並提供參數的預估。</span><span class="sxs-lookup"><span data-stu-id="2ded0-148">You collect measurement statistics from the phase estimation protocol and then you process the results using Bayesian inference and provide an estimate of the parameter.</span></span>
<span data-ttu-id="2ded0-149">這項處理可讓您估計 eigenvalue 以及該估計中的不確定性。</span><span class="sxs-lookup"><span data-stu-id="2ded0-149">This processing gives you an estimate of the eigenvalue as well as the uncertainty in that estimate.</span></span>
<span data-ttu-id="2ded0-150">它也可讓您執行自動調整的實驗，並利用先前的資訊。</span><span class="sxs-lookup"><span data-stu-id="2ded0-150">It also allows you to perform adaptive experiments and utilize prior information.</span></span>
<span data-ttu-id="2ded0-151">方法的缺點是，它需要進行計算。</span><span class="sxs-lookup"><span data-stu-id="2ded0-151">The methods' principle drawback is that it is computationally demanding.</span></span>

<span data-ttu-id="2ded0-152">若要瞭解此貝氏推斷程式的運作方式，請考慮處理單一結果的案例 `Zero` 。</span><span class="sxs-lookup"><span data-stu-id="2ded0-152">To understand how this Bayesian inference process works, consider the case of processing a single `Zero` result.</span></span>
<span data-ttu-id="2ded0-153">請注意，$X = \ket{+} \bra{+}-\ket {-} \bra {-} $，讓 $ \ket{+} $ 是對應至 $X $ 的唯一正 eigenstate `Zero` 。</span><span class="sxs-lookup"><span data-stu-id="2ded0-153">Note that $X = \ket{+}\bra{+} - \ket{-}\bra{-}$, such that $\ket{+}$ is the only positive eigenstate of $X$ corresponding to `Zero`.</span></span>
<span data-ttu-id="2ded0-154">在 `Zero` 給定輸入狀態 $ \ket{\psi}\ket{\phi} $ 的第一個 qubit 上觀察[ `PauliX` 測量](xref:microsoft.quantum.concepts.pauli)的機率，因此 \begin{equation} \Pr （\texttt{Zero} | \psi） = \left | \braket{+ | \psi} \right | ^ 2。</span><span class="sxs-lookup"><span data-stu-id="2ded0-154">The probability of observing `Zero` for a [`PauliX` measurement](xref:microsoft.quantum.concepts.pauli) on the first qubit given an input state $\ket{\psi}\ket{\phi}$ is thus \begin{equation} \Pr(\texttt{Zero} | \psi) = \left| \braket{+ | \psi} \right|^2.</span></span>
<span data-ttu-id="2ded0-155">\end{equation} 在反復階段估計的案例中，我們有 $ \ket{\psi} = R_1 （m [\phi-\theta]） \ket{+} $，因此 \begin{align} \Pr （\texttt{Zero} | \phi; m，\theta） & = \left |\braket{+ |R_1 （m [\phi-\theta]） |+} \right | ^ 2 \\ \\ & = \left | \frac12 \left （\bra {0} + \bra {1} \right） \left （\ket {0} + e ^ {i m [\phi-\theta]} \ket {1} \right） \right | ^ 2 \\ \\ & = \left | \frac{1 + e ^ {i m [\phi-\theta]}} \right {2} | ^ 2 \\ \\ & = \cos ^ 2 （m [\phi-\theta]/2） \tag{★} \label{eq：階段-est-可能性}。</span><span class="sxs-lookup"><span data-stu-id="2ded0-155">\end{equation} In the case of iterative phase estimation, we have that $\ket{\psi} = R_1(m [\phi-\theta]) \ket{+}$, such that \begin{align} \Pr(\texttt{Zero} | \phi; m,\theta) & = \left| \braket{+ | R_1(m [\phi-\theta]) | +} \right|^2 \\\\ & = \left| \frac12 \left( \bra{0} + \bra{1} \right) \left( \ket{0} + e^{i m [\phi-\theta]} \ket{1} \right) \right|^2 \\\\ & = \left| \frac{1 + e^{i m [\phi-\theta]}}{2} \right|^2 \\\\ & = \cos^2(m [\phi-\theta] / 2) \tag{★} \label{eq:phase-est-likelihood}.</span></span>
<span data-ttu-id="2ded0-156">\end{align} 也就是，反復的階段估計包含學習 sinusoidal 函式的震盪頻率，並能夠使用該 sinusoid 所指定的偏差來翻轉硬幣。</span><span class="sxs-lookup"><span data-stu-id="2ded0-156">\end{align} That is, iterative phase estimation consists of learning the oscillation frequency of a sinusoidal function, given the ability to flip a coin with a bias given by that sinusoid.</span></span>
<span data-ttu-id="2ded0-157">遵循傳統的傳統術語，我們呼叫 $ \eqref{eq：階段-est-機率} $ 反復階段估計的*可能性函數*。</span><span class="sxs-lookup"><span data-stu-id="2ded0-157">Following traditional classical terminology, we call $\eqref{eq:phase-est-likelihood}$ the *likelihood function* for iterative phase estimation.</span></span>

<span data-ttu-id="2ded0-158">在觀察到 `Result` 反復階段估計機率的函式之後，我們就可以使用貝氏機率分類的規則，規定我們應該認為該階段遵循該觀察。</span><span class="sxs-lookup"><span data-stu-id="2ded0-158">Having observed a `Result` from the iterative phase estimation likelihood function, we can then use Bayes' rule to prescribe what we should believe the phase to be following that observation.</span></span>
<span data-ttu-id="2ded0-159">具體而言、\begin{equation} \Pr （\phi | d） = \frac{\Pr （d | \phi） \Pr （\phi）} {\int \Pr （d | \phi） \Pr （\phi） {\mathrm d} \phi} \Pr （\phi）、\end{equation}，其中 $d \in \\ {\texttt{Zero}，\texttt{One} \\ } $ 是 `Result` ，而 where $ \Pr （\phi） $ 描述我們先前信念的 $ \phi $。</span><span class="sxs-lookup"><span data-stu-id="2ded0-159">Concretely, \begin{equation} \Pr(\phi | d) = \frac{\Pr(d | \phi) \Pr(\phi)}{\int \Pr(d | \phi) \Pr(\phi){\mathrm d}\phi} \Pr(\phi), \end{equation} where $d \in \\{\texttt{Zero}, \texttt{One}\\}$ is a `Result`, and where $\Pr(\phi)$ describes our prior beliefs about $\phi$.</span></span>
<span data-ttu-id="2ded0-160">這會讓反復階段估計的反復性質明確，因為「事後 posterior 散發 $ \Pr （\phi | d） $ 會立即描述我們在下一個觀察的前面的信念 `Result` 。</span><span class="sxs-lookup"><span data-stu-id="2ded0-160">This then makes the iterative nature of iterative phase estimation explicit, as the posterior distribution $\Pr(\phi | d)$ describes our beliefs immediately preceding our observation of the next `Result`.</span></span>

<span data-ttu-id="2ded0-161">在此程式中的任何時間點，我們可以將傳統控制器所推斷的階段 $ \hat{\phi} $ 報告為 \begin{equation} \hat{\phi} \mathrel{： =} \expect [\phi | \text{data}] = \int \phi \Pr （\phi | \text{data}） {\mathrm d} \phi，\end{equation}，其中 $ \text{data} $ 代表所有取得之值的完整記錄 `Result` 。</span><span class="sxs-lookup"><span data-stu-id="2ded0-161">At any point during this procedure, we can report the phase $\hat{\phi}$ inferred by the classical controller as \begin{equation} \hat{\phi} \mathrel{:=} \expect[\phi | \text{data}] = \int \phi \Pr(\phi | \text{data}) {\mathrm d}\phi, \end{equation} where $\text{data}$ stands for the entire record of all `Result` values obtained.</span></span>

<span data-ttu-id="2ded0-162">實際的貝氏推斷實際上是棘手。</span><span class="sxs-lookup"><span data-stu-id="2ded0-162">Exact Bayesian inference is in practice intractable.</span></span>
<span data-ttu-id="2ded0-163">為了查看這種假設，我們想要瞭解 $ $x $ $n $ 位變數。</span><span class="sxs-lookup"><span data-stu-id="2ded0-163">To see this imagine we wish to learn an $n$-bit variable $x$.</span></span>
<span data-ttu-id="2ded0-164">先前的散發 $ \Pr （x） $ 可支援 $x $ 的 $ 2 ^ n $ 假設值。</span><span class="sxs-lookup"><span data-stu-id="2ded0-164">The prior distribution $\Pr(x)$ has support over $2^n$ hypothetical values of $x$.</span></span>
<span data-ttu-id="2ded0-165">這表示，如果我們需要 $x $ 的高精確度估計，則貝氏階段估計可能需要記憶體和處理時間的承受度。</span><span class="sxs-lookup"><span data-stu-id="2ded0-165">This means that if we need a highly accurate estimate of $x$ then Bayesian phase estimation may need prohibitive memory and processing time.</span></span>
<span data-ttu-id="2ded0-166">對於某些應用程式（例如量子模擬），所需的 limitted 精確度並不會妨礙其他應用程式（例如快速鍵的演算法）無法在其階段估計步驟中使用精確的貝氏推斷。</span><span class="sxs-lookup"><span data-stu-id="2ded0-166">While for some applications, such as quantum simulation, the limitted accuracy required does not preclude such methods other applications, such as Shor's algorithm, cannot use exact Bayesian inference within its phase estimation step.</span></span>  <span data-ttu-id="2ded0-167">基於這個理由，我們也提供大約貝氏方法的實作為，例如[隨機的逐步解說階段估計（RWPE）](xref:microsoft.quantum.research.characterization.randomwalkphaseestimation) ，以及非貝氏的方法，例如[健全的階段估計](xref:microsoft.quantum.characterization.robustphaseestimation)。</span><span class="sxs-lookup"><span data-stu-id="2ded0-167">For this reason, we also provide implementations for approximate Bayesian methods such as [random walk phase estimation (RWPE)](xref:microsoft.quantum.research.characterization.randomwalkphaseestimation) and also non-Bayesian approaches such as [robust phase estimation](xref:microsoft.quantum.characterization.robustphaseestimation).</span></span>

### <a name="robust-phase-estimation"></a><span data-ttu-id="2ded0-168">健全的階段估計</span><span class="sxs-lookup"><span data-stu-id="2ded0-168">Robust Phase Estimation</span></span> ###

<span data-ttu-id="2ded0-169">在最糟的情況下， *posteriori*貝氏從測量結果中重建階段估計的最大值會有指數的困難。</span><span class="sxs-lookup"><span data-stu-id="2ded0-169">A maximum *a posteriori* Bayesian reconstruction of a phase estimate from measurement results is exponentially hard in the worst-case.</span></span> <span data-ttu-id="2ded0-170">因此，大部分實際的階段估計演算法會犧牲一些重建的品質，而在 exchange 中則是一種傳統的後置處理，它會以所做的測量數目來調整 polynomially。</span><span class="sxs-lookup"><span data-stu-id="2ded0-170">Thus most practical phase estimation algorithms sacrifice some quality in the reconstruction, in exchange for an amount of classical post-processing that instead scales polynomially with the number of measurements made.</span></span>

<span data-ttu-id="2ded0-171">具有有效率的傳統後置處理步驟的其中一個範例是[健全的階段估計演算法](https://arxiv.org/abs/1502.02677)，其簽章和輸入都是上面所述。</span><span class="sxs-lookup"><span data-stu-id="2ded0-171">One such example with an efficient classical post-processing step is the [robust phase estimation algorithm](https://arxiv.org/abs/1502.02677), with its signature and inputs mentioned above.</span></span> <span data-ttu-id="2ded0-172">它假設輸入單一的黑色方塊 $U $ 已封裝為 `DiscreteOracle` 類型，因此只會查詢受控制 $U $ 的整數乘冪。</span><span class="sxs-lookup"><span data-stu-id="2ded0-172">It assumes that input unitary black-boxes $U$ are packaged as `DiscreteOracle` type, and therefore only queries integer powers of controlled-$U$.</span></span> <span data-ttu-id="2ded0-173">如果暫存器中的輸入狀態 `Qubit[]` 是 eigenstate $U \ket{\psi} = e ^ {i\phi} \ ket {\ psi} $，則健全的階段估計演算法會傳回 $ \hat{\phi}\in $ 的估計 $ \pi [-\pi，\phi） $ 作為 `Double` 。</span><span class="sxs-lookup"><span data-stu-id="2ded0-173">If the input state in the `Qubit[]` register is an eigenstate $U\ket{\psi}=e^{i\phi}\ket{\psi}$, the robust phase estimation algorithm returns an estimate $\hat{\phi}\in[-\pi,\pi)$ of $\phi$ as a `Double`.</span></span>

<span data-ttu-id="2ded0-174">健全的階段估計最重要的功能是與其他大部分有用的變體共用，是 $ \hat{\phi} $ 的重建品質在某種程度上是海森堡有限的。</span><span class="sxs-lookup"><span data-stu-id="2ded0-174">The most important feature of robust phase estimation, which is shared with most other useful variants, is that the reconstruction quality of $\hat{\phi}$ is in some sense Heisenberg-limited.</span></span> <span data-ttu-id="2ded0-175">這表示如果 $ \hat{\phi} $ 與 true 值的偏差是 $ \sigma $，則 $ \sigma $ 會以反比星號調整至 $U $ 所控制的查詢總數 $Q $，亦即 $ \sigma = \mathcal{O} （1/Q） $。</span><span class="sxs-lookup"><span data-stu-id="2ded0-175">This means that if the deviation of $\hat{\phi}$ from the true value is $\sigma$, then $\sigma$ scales inversely-proportional to the total number of queries $Q$ made to controlled-$U$, i.e. $\sigma=\mathcal{O}(1/Q)$.</span></span> <span data-ttu-id="2ded0-176">現在，偏差的定義會因不同的估計演算法而有所不同。</span><span class="sxs-lookup"><span data-stu-id="2ded0-176">Now, the definition of deviation varies between different estimation algorithms.</span></span> <span data-ttu-id="2ded0-177">在某些情況下，它可能表示至少有 $ \mathcal{O} （1） $ 機率，估計錯誤 $ | \hat{\phi}-\phi | \_\circ\le \sigma $ on a 迴圈量值 $ \circ $。</span><span class="sxs-lookup"><span data-stu-id="2ded0-177">In some cases, it may mean that with at least $\mathcal{O}(1)$ probability, the estimation error $|\hat{\phi}-\phi|\_\circ\le \sigma$ on some circular measure $\circ$.</span></span> <span data-ttu-id="2ded0-178">針對健全的階段估計， \_ 如果我們將定期階段解除包裝成單一的有限間隔 $ （-\hat{\phi}-\phi，\pi] $，則偏差就會精確地指向 $ \sigma ^ 2 = \mathbb{E} \hat{\phi} [（\mod \_ {2 \ pi} （\pi + \pi）-\pi） ^ 2] $。</span><span class="sxs-lookup"><span data-stu-id="2ded0-178">For robust phase estimation, deviation is precisely the variance $\sigma^2 = \mathbb{E}\_\hat{\phi}[(\mod\_{2\pi}(\hat{\phi}-\phi +\pi)-\pi)^2]$ if we unwrap periodic phases onto a single finite interval $(-\pi,\pi]$.</span></span> <span data-ttu-id="2ded0-179">更精確地說，健全狀況估計中的標準差符合到差異 $ $ \begin{align} 2.0 \pi/Q \le \sigma \le 2 \ pi/2 ^ {n} \le 10.7 \ pi/Q，\end{align} $ $，其中下限達到 asymptotically 大型 $Q $ 的限制，而上限則是針對小型樣本大小所保證。</span><span class="sxs-lookup"><span data-stu-id="2ded0-179">More precisely, the standard deviation in robust phase estimation satisfies the inequalities $$ \begin{align} 2.0 \pi / Q \le \sigma \le 2\pi / 2^{n} \le 10.7\pi / Q, \end{align} $$ where the lower bound is reached in the limit of asymptotically large $Q$, and the upper bound is guaranteed even for small sample sizes.</span></span>  <span data-ttu-id="2ded0-180">請注意，輸入所選取的 $n $ 會 `bitsPrecision` 隱含定義 $Q $。</span><span class="sxs-lookup"><span data-stu-id="2ded0-180">Note that $n$ selected by the `bitsPrecision` input, which implicitly defines $Q$.</span></span>

<span data-ttu-id="2ded0-181">其他相關的詳細資料包括只有 $1 $ ancilla qubit 的小空間額外負荷，或程式是非彈性的，這表示所需的量子實驗順序與中繼測量結果無關。</span><span class="sxs-lookup"><span data-stu-id="2ded0-181">Other relevant details include, say, the small space overhead of just $1$ ancilla qubit, or that the procedure is non-adaptive, meaning the required sequence of quantum experiments is independent of the intermediate measurement outcomes.</span></span> <span data-ttu-id="2ded0-182">在此和即將推出的範例中，階段估計演算法的選擇非常重要，其中一項應該參考檔，例如 @"microsoft.quantum.characterization.robustphaseestimation" 和參考的發行集，以取得詳細資訊及其執行方式。</span><span class="sxs-lookup"><span data-stu-id="2ded0-182">In this and forthcoming examples where the choice of phase estimation algorithm is important, one should one should refer to the documentation such as @"microsoft.quantum.characterization.robustphaseestimation" and the referenced publications therein for more information and for their the implementation.</span></span>

> [!TIP]
> <span data-ttu-id="2ded0-183">有許多範例會使用健全的階段估計。</span><span class="sxs-lookup"><span data-stu-id="2ded0-183">There are many samples where robust phase estimation is used.</span></span> <span data-ttu-id="2ded0-184">如需瞭解各種實體系統之接地能源的階段估計，請參閱[ **H2 模擬**範例](https://github.com/microsoft/Quantum/tree/master/samples/simulation/h2/command-line)、 [ **SimpleIsing**範例](https://github.com/microsoft/Quantum/tree/master/samples/simulation/ising/simple)和[ **Hubbard 模型**範例](https://github.com/microsoft/Quantum/tree/master/samples/simulation/hubbard)。</span><span class="sxs-lookup"><span data-stu-id="2ded0-184">For phase estimation in extracting the ground state energy of various physical system, please see the [**H2 simulation** sample](https://github.com/microsoft/Quantum/tree/master/samples/simulation/h2/command-line), the [**SimpleIsing** sample](https://github.com/microsoft/Quantum/tree/master/samples/simulation/ising/simple), and the [**Hubbard model** sample](https://github.com/microsoft/Quantum/tree/master/samples/simulation/hubbard).</span></span>


### <a name="continuous-oracles"></a><span data-ttu-id="2ded0-185">連續 Oracles</span><span class="sxs-lookup"><span data-stu-id="2ded0-185">Continuous Oracles</span></span> ###

<span data-ttu-id="2ded0-186">我們也可以從上面使用的 oracle 模型一般化，以允許依 canon 類型模型化的持續時間 oracles <xref:microsoft.quantum.oracles.continuousoracle> 。</span><span class="sxs-lookup"><span data-stu-id="2ded0-186">We can also generalize from the oracle model used above to allow for continuous-time oracles, modeled by the canon type <xref:microsoft.quantum.oracles.continuousoracle>.</span></span>
<span data-ttu-id="2ded0-187">請考慮，而不是單一的單一運算子 $U $，我們有一系列的單一運算子 $U （t） $ for $t \in \mathbb{R} $，使 $U （t） U （s） $ = $U （t + s） $。</span><span class="sxs-lookup"><span data-stu-id="2ded0-187">Consider that instead of a single unitary operator $U$, we have a family of unitary operators $U(t)$ for $t \in \mathbb{R}$ such that $U(t) U(s)$ = $U(t + s)$.</span></span>
<span data-ttu-id="2ded0-188">這是比離散案例更弱的語句，因為我們可以藉 <xref:microsoft.quantum.oracles.discreteoracle> 由限制 \, 某些固定 $ \delta t $ 的 $t = m \delta t $ 來建立。</span><span class="sxs-lookup"><span data-stu-id="2ded0-188">This is a weaker statement than in the discrete case, since we can construct a <xref:microsoft.quantum.oracles.discreteoracle> by restricting $t = m\,\delta t$ for some fixed $\delta t$.</span></span>
<span data-ttu-id="2ded0-189">根據[石頭的定理](https://en.wikipedia.org/wiki/Stone%27s_theorem_on_one-parameter_unitary_groups)，$U （t） = \exp （i H t） $ for a operator $H $，其中 $ \exp $ 是矩陣指數，如 advanced matrix （高階[矩陣](xref:microsoft.quantum.concepts.matrix-advanced)）中所述。</span><span class="sxs-lookup"><span data-stu-id="2ded0-189">By [Stone's theorem](https://en.wikipedia.org/wiki/Stone%27s_theorem_on_one-parameter_unitary_groups), $U(t) = \exp(i H t)$ for some operator $H$, where $\exp$ is the matrix exponential as described in [advanced matrices](xref:microsoft.quantum.concepts.matrix-advanced).</span></span>
<span data-ttu-id="2ded0-190">$H $ 的 eigenstate $ \ket{\phi} $，讓 $H \ket{\phi} = \phi \ket{\phi} $ 也是 $U （t） $ 適用于所有 $t $、eigenstate U （t） \begin{equation} = e ^ {i \ket{\phi} t} \phi 的 \ket{\phi}。</span><span class="sxs-lookup"><span data-stu-id="2ded0-190">An eigenstate $\ket{\phi}$ of $H$ such that $H \ket{\phi} = \phi \ket{\phi}$ is then also an eigenstate of $U(t)$ for all $t$, \begin{equation} U(t) \ket{\phi} = e^{i \phi t} \ket{\phi}.</span></span>
<span data-ttu-id="2ded0-191">\end{equation}</span><span class="sxs-lookup"><span data-stu-id="2ded0-191">\end{equation}</span></span>

<span data-ttu-id="2ded0-192">您可以套用針對[貝氏階段估計](#bayesian-phase-estimation)所討論的相同分析，而此機率函式與此較一般的 oracle 模型完全相同： $ $ \Pr （\texttt{Zero} | \phi; t，\theta） = \cos ^ 2 \ left （\frac{t [\phi-\theta]} {2} \right）。</span><span class="sxs-lookup"><span data-stu-id="2ded0-192">The exact same analysis discussed for [Bayesian phase estimation](#bayesian-phase-estimation) can be applied, and the likelihood function is the precisely the same for this more general oracle model: $$ \Pr(\texttt{Zero} | \phi; t,\theta)=\cos^2\left(\frac{t[\phi -\theta]}{2}\right).</span></span>
<span data-ttu-id="2ded0-193">$ $ 此外，如果 $U $ 是 dynamical 產生器的模擬（ [Hamiltonian 模擬](xref:microsoft.quantum.libraries.applications#hamiltonian-simulation)的情況），我們會將 $ \phi $ 解讀為能源。</span><span class="sxs-lookup"><span data-stu-id="2ded0-193">$$ Moreover, if $U$ is a simulation of a dynamical generator, as is the case for [Hamiltonian simulation](xref:microsoft.quantum.libraries.applications#hamiltonian-simulation), we interpret $\phi$ as an energy.</span></span>
<span data-ttu-id="2ded0-194">因此，使用階段估計搭配連續查詢，可讓我們瞭解分子驅使分子、[材質](https://arxiv.org/abs/1510.03859)或[現場理論](https://arxiv.org/abs/1111.3633v2)的模擬[能源](https://arxiv.org/abs/quant-ph/0604193)範圍，而不需犧牲所選的實驗，方法是要求 $t $ 必須是整數。</span><span class="sxs-lookup"><span data-stu-id="2ded0-194">Thus, using phase estimation with continuous queries allows us to learn the simulated [energy spectrum of molecules](https://arxiv.org/abs/quant-ph/0604193), [materials](https://arxiv.org/abs/1510.03859) or [field theories](https://arxiv.org/abs/1111.3633v2) without having to compromise our choice of experiments by requiring $t$ to be an integer.</span></span>

### <a name="random-walk-phase-estimation"></a><span data-ttu-id="2ded0-195">隨機逐步解說階段估計</span><span class="sxs-lookup"><span data-stu-id="2ded0-195">Random Walk Phase Estimation</span></span> ###

<span data-ttu-id="2ded0-196">問 # 提供貝氏階段估計的有用近似值，其設計目的是要使用接近的配量裝置，其操作方式是針對從反復階段估計取得的資料記錄，進行隨機的引導。</span><span class="sxs-lookup"><span data-stu-id="2ded0-196">Q# provides a useful approximation of Bayesian phase estimation designed for use close to quantum devices that operates by conditioning a random walk on the data record obtained from iterative phase estimation.</span></span>
<span data-ttu-id="2ded0-197">這個方法既可調適型且完全具決定性，允許在估計階段 $ \hat{\phi} $ 中，以極低的記憶體額外負荷來進行接近優化的錯誤調整。</span><span class="sxs-lookup"><span data-stu-id="2ded0-197">This method is both adaptive and entirely deterministic, allowing for near-optimal scaling of errors in the estimated phase $\hat{\phi}$ with very low memory overheads.</span></span>

<span data-ttu-id="2ded0-198">通訊協定會使用近似的貝氏推斷方法，假設先前的散發為高斯。</span><span class="sxs-lookup"><span data-stu-id="2ded0-198">The protocol uses an approximate Bayesian inference method that assumes the prior distribution is Gaussian.</span></span>
<span data-ttu-id="2ded0-199">此高斯假設可讓我們針對實驗流量分析公式，以最小化「事後 posterior 變異數。</span><span class="sxs-lookup"><span data-stu-id="2ded0-199">This Gaussian assumption allows us to use an analytical formula for the experiment that minimizes the posterior variance.</span></span>
<span data-ttu-id="2ded0-200">然後，此演算法會根據該實驗的結果，將 $ \phi $ left 或 right 的估計值向左或向右移動預先決定的數量，並根據預先決定的數量來縮小變異數。</span><span class="sxs-lookup"><span data-stu-id="2ded0-200">The algorithm then, based on the outcome of that experiment, shifts the estimate of $\phi$ left or right by a pre-determined amount and shrinks the variance by a pre-determined amount.</span></span>
<span data-ttu-id="2ded0-201">這個平均值和變異數會提供在 $ \phi $ 之前指定高斯以進行下一個實驗所需的所有資訊。</span><span class="sxs-lookup"><span data-stu-id="2ded0-201">This mean and variance give all the information that is needed to specify a Gaussian prior on $\phi$ for the next experiment.</span></span>
<span data-ttu-id="2ded0-202">未預期的測量失敗，或 true 結果在先前的連接結尾上，可能會導致這個方法失敗。</span><span class="sxs-lookup"><span data-stu-id="2ded0-202">Unexpected measurement failures, or the true result being on the tails of the initial prior, can cause this method to fail.</span></span>
<span data-ttu-id="2ded0-203">它會藉由執行實驗來測試目前的平均值和標準差是否適用于系統，以從失敗中復原。</span><span class="sxs-lookup"><span data-stu-id="2ded0-203">It recovers from failure by performing experiments to test whether the current mean and standard deviation are appropriate for the system.</span></span>
<span data-ttu-id="2ded0-204">如果不是，則演算法會執行本逐步解說的反向步驟，而且進程會繼續進行。</span><span class="sxs-lookup"><span data-stu-id="2ded0-204">If they are not, then the algorithm does an inverse step of the walk and the process continues.</span></span>
<span data-ttu-id="2ded0-205">回溯的能力也可以讓演算法學習，即使最初的標準差是 inapropriately 小的也一樣。</span><span class="sxs-lookup"><span data-stu-id="2ded0-205">The ability to step backwards also allows the algorithm to learn even if the initial prior standard deviation is inapropriately small.</span></span>

## <a name="calling-phase-estimation-algorithms"></a><span data-ttu-id="2ded0-206">呼叫階段估計演算法</span><span class="sxs-lookup"><span data-stu-id="2ded0-206">Calling Phase Estimation Algorithms</span></span> ##

<span data-ttu-id="2ded0-207">Q # canon 所提供的每個階段估計作業，會採用一組不同的輸入，將我們所需的品質參數化為最終估計 $ \hat{\phi} $。</span><span class="sxs-lookup"><span data-stu-id="2ded0-207">Each phase estimation operation provided with the Q# canon takes a different set of inputs parameterizing the quality that we demand out of the final estimate $\hat{\phi}$.</span></span>
<span data-ttu-id="2ded0-208">不過，這些不同的輸入全都共用數個常見的輸入，因此部分應用程式在品質參數上會產生共同的簽章。</span><span class="sxs-lookup"><span data-stu-id="2ded0-208">These various inputs, however, all share several inputs in common, such that partial application over the quality parameters results in a common signature.</span></span>
<span data-ttu-id="2ded0-209">例如， <xref:microsoft.quantum.characterization.robustphaseestimation> 下一節所討論的作業具有下列簽章：</span><span class="sxs-lookup"><span data-stu-id="2ded0-209">For example, the <xref:microsoft.quantum.characterization.robustphaseestimation> operation discussed in the next section has the following signature:</span></span>

```qsharp
operation RobustPhaseEstimation(bitsPrecision : Int, oracle : DiscreteOracle, eigenstate : Qubit[])  : Double
```

<span data-ttu-id="2ded0-210">`bitsPrecision`輸入對而言是唯一的 `RobustPhaseEstimation` ，而 `oracle` 和 `eigenstate` 則是常見的。</span><span class="sxs-lookup"><span data-stu-id="2ded0-210">The `bitsPrecision` input is unique to `RobustPhaseEstimation`, while `oracle` and `eigenstate` are in common.</span></span>
<span data-ttu-id="2ded0-211">因此，在**H2Sample**中，作業可以接受具有表單輸入的反復階段估計演算法， `(DiscreteOracle, Qubit[]) => Unit` 以允許使用者指定任意階段估計演算法：</span><span class="sxs-lookup"><span data-stu-id="2ded0-211">Thus, as seen in **H2Sample**, an operation can accept an iterative phase estimation algorithm with an input of the form `(DiscreteOracle, Qubit[]) => Unit` to allow a user to specify arbitrary phase estimation algorithms:</span></span>

```qsharp
operation H2EstimateEnergy(
    idxBondLength : Int,
    trotterStepSize : Double,
    phaseEstAlgorithm : ((DiscreteOracle, Qubit[]) => Double))
: Double
```

<span data-ttu-id="2ded0-212">這些各式各樣的階段估計演算法會針對不同的屬性和輸入參數進行優化，必須加以瞭解才能為目標應用程式做出最佳選擇。</span><span class="sxs-lookup"><span data-stu-id="2ded0-212">These myriad phase estimation algorithms are optimized for different properties and input parameters, which must be understood to make the best choice for the target application.</span></span> <span data-ttu-id="2ded0-213">比方說，某些階段估計演算法是可調整的，這表示未來的步驟是由先前步驟的測量結果來傳統方式控制。</span><span class="sxs-lookup"><span data-stu-id="2ded0-213">For instance, some phase estimation algorithms are adaptive, meaning that future steps are classically controlled by the measurement results of previous steps.</span></span> <span data-ttu-id="2ded0-214">有些人需要能夠以任意實際的方式 exponentiate 其黑箱的單一 oracle，而有些則只需要整數乘冪，但只能解析階段估計的模數 $ 2 \ pi $。</span><span class="sxs-lookup"><span data-stu-id="2ded0-214">Some require the ability to exponentiate its black-box unitary oracle by arbitrary real powers, and others only require integer powers but are only able to resolve a phase estimate modulo $2\pi$.</span></span> <span data-ttu-id="2ded0-215">有些需要多個輔助 qubits，而其他則只需要一個。</span><span class="sxs-lookup"><span data-stu-id="2ded0-215">Some require many auxiliary qubits, and others require only one.</span></span>

<span data-ttu-id="2ded0-216">同樣地，使用隨機的逐步解說階段估計，會以與 canon 所提供的其他演算法大致相同的方式進行：</span><span class="sxs-lookup"><span data-stu-id="2ded0-216">Similarly, using random walk phase estimation proceeds in much the same way as for other algorithms provided with the canon:</span></span>

```qsharp
operation ApplyExampleOracle(
    eigenphase : Double,
    time : Double,
    register : Qubit[])
: Unit is Adj + Ctl {
    Rz(2.0 * eigenphase * time, register[0]);
}

operation EstimateBayesianPhase(eigenphase : Double) : Double {
    let oracle = ContinuousOracle(ApplyExampleOracle(eigenphase, _, _));
    using (eigenstate = Qubit()) {
        X(eigenstate);
        // The additional inputs here specify the mean and variance of the prior, the number of
        // iterations to perform, how many iterations to perform as a maximum, and how many
        // steps to roll back on an approximation failure.
        let est = RandomWalkPhaseEstimation(0.0, 1.0, 61, 100000, 1, oracle, [eigenstate]);
        Reset(eigenstate);
        return est;
    }
}
```
