---
title: 量子特性和統計資料
description: 瞭解如何使用階段估計的測量統計資料，來估計量副程式設計中的結果值。
author: bradben
uid: microsoft.quantum.libraries.characterization
ms.author: martinro
ms.date: 12/11/2017
ms.topic: article
no-loc:
- Q#
- $$v
ms.openlocfilehash: 72af3f5517b272d6d8159b158103b5af91d266b5
ms.sourcegitcommit: c48cdafccb3487bf93d67fa80cdc64768445b691
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 01/06/2021
ms.locfileid: "97940881"
---
# <a name="quantum-characterization-and-statistics"></a><span data-ttu-id="837c9-103">量子特性和統計資料</span><span class="sxs-lookup"><span data-stu-id="837c9-103">Quantum Characterization and Statistics</span></span> #

<span data-ttu-id="837c9-104">您必須能夠描述作業的效果，才能開發有用的量子演算法。</span><span class="sxs-lookup"><span data-stu-id="837c9-104">It is critical to be able to characterize the effects of operations in order to develop useful quantum algorithms.</span></span>
<span data-ttu-id="837c9-105">這是一項挑戰，因為每次測量量子系統都會產生最多一項資訊。</span><span class="sxs-lookup"><span data-stu-id="837c9-105">This is challenging because every measurement of a quantum system yields at most one bit of information.</span></span>
<span data-ttu-id="837c9-106">若要瞭解 eigenvalue，請單獨使用量子狀態，許多度量的結果都必須一起拼接，讓使用者可以搜集所需的許多資訊來代表這些概念。</span><span class="sxs-lookup"><span data-stu-id="837c9-106">In order to learn an eigenvalue, let alone a quantum state, the results of many measurements must be stitched together so that the user can glean the many bits of information needed to represent these concepts.</span></span>
<span data-ttu-id="837c9-107">量子狀態尤其是繁瑣語法，因為 [沒有任何複製定理](xref:microsoft.quantum.concepts.pauli#the-no-cloning-theorem) 指出沒有任何方法可從單一狀態複本學習任意的量子狀態，因為這樣做可讓您建立狀態的複本。</span><span class="sxs-lookup"><span data-stu-id="837c9-107">Quantum states are especially vexing because the [no-cloning theorem](xref:microsoft.quantum.concepts.pauli#the-no-cloning-theorem) states that there is no way to learn an arbitrary quantum state from a single copy of the state, because doing so would let you make copies of the state.</span></span>
<span data-ttu-id="837c9-108">這種從使用者開始的量子狀態模糊化會反映出來，而不會 Q# 公開或甚至定義狀態對量副程式的影響。</span><span class="sxs-lookup"><span data-stu-id="837c9-108">This obfuscation of the quantum state from the user is reflected in the fact that Q# does not expose or even define what a state *is* to quantum programs.</span></span>
<span data-ttu-id="837c9-109">因此，我們藉由將作業和狀態視為黑箱來處理量子特性;這種方法與量子特性、驗證和驗證 (QCVV) 的實驗實務很普遍。</span><span class="sxs-lookup"><span data-stu-id="837c9-109">We thus approach quantum characterization by treating operations and states as black-box; this approach shares much in common with the experimental practice of quantum characterization, verification and validation (QCVV).</span></span>

<span data-ttu-id="837c9-110">特性與先前討論過的其他程式庫不同。</span><span class="sxs-lookup"><span data-stu-id="837c9-110">Characterization is distinct from many of the other libraries discussed previously.</span></span>
<span data-ttu-id="837c9-111">這裡的目的是要瞭解系統的傳統資訊，而不是在狀態向量上執行單一轉換。</span><span class="sxs-lookup"><span data-stu-id="837c9-111">The aim here is less to learn classical information about the system, rather than to perform a unitary transformation on a state vector.</span></span>
<span data-ttu-id="837c9-112">因此，這些程式庫必須混合傳統和量子資訊的處理。</span><span class="sxs-lookup"><span data-stu-id="837c9-112">These libraries must therefore blend both classical and quantum information processing.</span></span>


## <a name="iterative-phase-estimation"></a><span data-ttu-id="837c9-113">反復階段估計</span><span class="sxs-lookup"><span data-stu-id="837c9-113">Iterative Phase Estimation</span></span> ##

<span data-ttu-id="837c9-114">以量子特性為依據來查看量副程式設計，建議使用量子階段估計的實用替代方法。</span><span class="sxs-lookup"><span data-stu-id="837c9-114">Viewing quantum programming in terms of quantum characterization suggests a useful alternative to quantum phase estimation.</span></span>
<span data-ttu-id="837c9-115">也就是說，您可以將階段估計視為 *傳統* 代理程式透過測量來學習量子系統屬性的程式，而不是準備 $n $ 量子位的暫存器來包含該階段的二進位標記法。</span><span class="sxs-lookup"><span data-stu-id="837c9-115">That is, instead of preparing an $n$-qubit register to contain a binary representation of the phase as in quantum phase estimation, we can view phase estimation as the process by which a *classical* agent learns properties of a quantum system through measurements.</span></span>
<span data-ttu-id="837c9-116">我們在量子案例中繼續進行，方法是使用階段 kickback，將黑色方塊作業的應用程式轉換成未知角度的旋轉，但會測量我們在旋轉之後的每個步驟中旋轉的 ancilla 量子位。</span><span class="sxs-lookup"><span data-stu-id="837c9-116">We proceed as in the quantum case by using phase kickback to turn applications of a black-box operation into rotations by an unknown angle, but will measure the ancilla qubit that we rotate at each step immediately following the rotation.</span></span>
<span data-ttu-id="837c9-117">這樣做的優點是，我們只需要一個額外的量子位來執行量子案例中所述的階段 kickback，我們就會在每個步驟以反復的方式學習測量結果中的階段。</span><span class="sxs-lookup"><span data-stu-id="837c9-117">This has the advantage that we only require a single additional qubit to perform the phase kickback described in the quantum case, as we then learn the phase from the measurement results at each step in an iterative fashion.</span></span>  
<span data-ttu-id="837c9-118">以下建議的每個方法都會使用不同的策略來設計實驗，並使用不同的資料處理方法來學習該階段。</span><span class="sxs-lookup"><span data-stu-id="837c9-118">Each of the methods proposed below uses a different strategy for designing experiments and different data processing methods to learn the phase.</span></span>  <span data-ttu-id="837c9-119">它們各有獨特的優點，包括嚴格的錯誤界限、將先前資訊納入的能力、容許錯誤或在記憶體上執行 limitted 傳統電腦。</span><span class="sxs-lookup"><span data-stu-id="837c9-119">They each have unique advantage ranging from having rigorous error bounds, to the abilities to incorporate prior information, tolerate errors or run on memory limitted classical computers.</span></span>

<span data-ttu-id="837c9-120">在討論反復的階段估計時，我們會考慮將單一的 $U $ 指定為黑色方塊的操作。</span><span class="sxs-lookup"><span data-stu-id="837c9-120">In discussing iterative phase estimation, we will consider a unitary $U$ given as a black-box operation.</span></span>
<span data-ttu-id="837c9-121">如同 [資料結構](xref:microsoft.quantum.libraries.data-structures)中的 oracle 一節中所述， Q# canon 會依 <xref:Microsoft.Quantum.Oracles.DiscreteOracle> 使用者定義型別（由元組類型定義）來模型作業 `((Int, Qubit[]) => Unit : Adjoint, Controlled)` 。</span><span class="sxs-lookup"><span data-stu-id="837c9-121">As described in the section on oracles in [data structures](xref:microsoft.quantum.libraries.data-structures), the Q# canon models such operations by the <xref:Microsoft.Quantum.Oracles.DiscreteOracle> user-defined type, defined by the tuple type `((Int, Qubit[]) => Unit : Adjoint, Controlled)`.</span></span>
<span data-ttu-id="837c9-122">具體而言，如果 `U : DiscreteOracle` ，則會 `U(m)` 為執行 $U ^ m $ `m : Int` 。</span><span class="sxs-lookup"><span data-stu-id="837c9-122">Concretely, if `U : DiscreteOracle`, then `U(m)` implements $U^m$ for `m : Int`.</span></span>

<span data-ttu-id="837c9-123">有了這項定義之後，反復階段估計的每個步驟都會藉由準備 $ \ket{+} $ 狀態的輔助量子位，以及我們 [假設)  ($U 的初始](xref:microsoft.quantum.concepts.matrix-advanced) 狀態 $ \ket{\phi} $ 來進行，亦即 $U (m) \ket{\phi} = e ^ {im\phi} \ ket {\ phi} $。</span><span class="sxs-lookup"><span data-stu-id="837c9-123">With this definition in place, each step of iterative phase estimation proceeds by preparing an auxiliary qubit in the $\ket{+}$ state along with the initial state $\ket{\phi}$ that we assume is an [eigenvector](xref:microsoft.quantum.concepts.matrix-advanced) of $U(m)$, i.e. $U(m)\ket{\phi}= e^{im\phi}\ket{\phi}$.</span></span>  
<span data-ttu-id="837c9-124">接著會使用受控制的應用程式， `U(m)` 以準備狀態 $ \left (R \_ 1 (m \phi) \ket{+} \right) \ket{\phi} $。</span><span class="sxs-lookup"><span data-stu-id="837c9-124">A controlled application of `U(m)` is then used which prepares the state $\left(R\_1(m \phi) \ket{+}\right)\ket{\phi}$.</span></span>
<span data-ttu-id="837c9-125">如同在量子案例中，受控制的 oracle 應用程式效果與在 `U(m)` $ \ket{+} $ 的未知階段套用 $R _1 $ 的效果完全相同，因此我們可以更簡單的方式描述 $U $ 的效果。</span><span class="sxs-lookup"><span data-stu-id="837c9-125">As in the quantum case, the effect of a controlled application of the oracle `U(m)` is precisely the same as the effect of applying $R_1$ for the unknown phase on $\ket{+}$, such that we can describe the effects of $U$ in this simpler fashion.</span></span>
<span data-ttu-id="837c9-126">然後，演算法會藉由套用 $R _1 (-m\theta) $ 以取得狀態 $ \ket{\psi} = \left (R \_ 1 (m [\phi-\theta] ) \ket{+} \right) \ket{\phi} $ $，來旋轉控制項量子位。</span><span class="sxs-lookup"><span data-stu-id="837c9-126">Optionally, the algorithm then rotates the control qubit by applying $R_1(-m\theta)$ to obtain a state $\ket{\psi}=\left(R\_1(m [\phi-\theta]) \ket{+}\right)\ket{\phi}$$.</span></span>
<span data-ttu-id="837c9-127">然後以 $X $ 基礎來測量作為控制項使用的輔助量子位 `U(m)` ，以取得單一傳統 `Result` 。</span><span class="sxs-lookup"><span data-stu-id="837c9-127">The auxiliary qubit used as a control for `U(m)` is then measured in the $X$ basis to obtain a single classical `Result`.</span></span>

<span data-ttu-id="837c9-128">此時， `Result` 透過反復階段估計所取得的值來重建階段是一個傳統的統計推斷問題。</span><span class="sxs-lookup"><span data-stu-id="837c9-128">At this point, reconstructing the phase from the `Result` values obtained through iterative phase estimation is a classical statistical inference problem.</span></span>
<span data-ttu-id="837c9-129">在指定固定的推斷方法的情況下，尋找最大化所獲得資訊的 $m $ 值只是統計資料中的問題。</span><span class="sxs-lookup"><span data-stu-id="837c9-129">Finding the value of $m$ that maximizes the information gained, given a fixed inference method, is simply a problem in statistics.</span></span>
<span data-ttu-id="837c9-130">我們強調這一點，方法是在貝氏參數估計形式的理論層級簡要描述反復的階段估計，然後再繼續描述 canon 中提供的統計演算法 Q# 來解決這個傳統推斷問題。</span><span class="sxs-lookup"><span data-stu-id="837c9-130">We emphasize this by briefly describing iterative phase estimation at a theoretical level in the Bayesian parameter estimation formalism before proceeding to describe the statistical algorithms provided in the Q# canon for solving this classical inference problem.</span></span>

### <a name="iterative-phase-estimation-without-eigenstates"></a><span data-ttu-id="837c9-131">未 Eigenstates 的反復階段估計</span><span class="sxs-lookup"><span data-stu-id="837c9-131">Iterative Phase Estimation Without Eigenstates</span></span> ###

<span data-ttu-id="837c9-132">如果提供的輸入狀態不是 eigenstate，也就是說，如果 $U (m) \ket{\phi \_ j} = e ^ {im\phi \_ j} $，則階段估計的進程會以非決定性的方式，將量子狀態引導至單一能源 eigenstate。</span><span class="sxs-lookup"><span data-stu-id="837c9-132">If an input state is provided that is not an eigenstate, which is to say that if $U(m)\ket{\phi\_j} = e^{im\phi\_j}$ then the process of phase estimation non-deterministically guides the quantum state towards a single energy eigenstate.</span></span>  <span data-ttu-id="837c9-133">最終所要聚合的 eigenstate 是最可能產生觀察到的 eigenstate `Result` 。</span><span class="sxs-lookup"><span data-stu-id="837c9-133">The eigenstate it ultimately converges to is the eigenstate that is most likely to produce the observed `Result`.</span></span>

<span data-ttu-id="837c9-134">具體來說，PE 的單一步驟會在狀態 \begin{align} \ sum_j \sqrt{\Pr ( \phi \_ j) } \ket{\phi \_ j} \mapsto \sum \_ j\frac {\ Sqrt {\ Pr ( \phi \_ j) } \sqrt{\Pr ( \text{result} | \phi \_ j) } \Ket{\phi \_ j}} {\sqrt{\Pr ( \phi \_ j) \sum \_ k \Pr ( \text{result} | \phi \_ k) }}。</span><span class="sxs-lookup"><span data-stu-id="837c9-134">Specifically, a single step of PE performs the following non-unitary transformation on a state \begin{align} \sum_j \sqrt{\Pr(\phi\_j)} \ket{\phi\_j} \mapsto \sum\_j\frac{\sqrt{\Pr(\phi\_j)}\sqrt{\Pr(\text{Result}|\phi\_j)}\ket{\phi\_j}}{\sqrt{\Pr(\phi\_j)\sum\_k \Pr(\text{Result}|\phi\_k)}}.</span></span>
<span data-ttu-id="837c9-135">\end{align}，因為此進程會逐一查看多個值，所以沒有最大 `Result` 值 $ \ prod_k \pr ( \text{result} \_ k | \phi \_ j) $ 的 eigenstates 將會以指數方式隱藏。</span><span class="sxs-lookup"><span data-stu-id="837c9-135">\end{align} As this process is iterated over multiple `Result` values, eigenstates that do not have maximal values of $\prod_k\Pr(\text{Result}\_k|\phi\_j)$ will be exponentially suppressed.</span></span>
<span data-ttu-id="837c9-136">如此一來，如果正確選擇實驗，推斷程式就會隨著單一 eigenvalue 而收斂。</span><span class="sxs-lookup"><span data-stu-id="837c9-136">As a result, the inference process will tend to converge to states with a single eigenvalue if the experiments are chosen properly.</span></span>

<span data-ttu-id="837c9-137">貝氏機率分類 ' 定理進一步建議將階段估計所產生的狀態撰寫為 \begin{align} \frac{\sqrt{\Pr ( \phi \_ j) } \sqrt{\Pr ( \text{Result} | \phi \_ j) } \ket{\phi \_ j}} {\sqrt{\Pr ( \phi j \_) \Sum \_ j \Pr ( \text{Result} | \phi \_ j) }} = \ sum_j \sqrt{\Pr ( \phi \_ j | \text{Result} ) } \ket{\phi \_ j}。</span><span class="sxs-lookup"><span data-stu-id="837c9-137">Bayes' theorem further suggests that the state that results from phase estimation be written in the form \begin{align} \frac{\sqrt{\Pr(\phi\_j)}\sqrt{\Pr(\text{Result}|\phi\_j)}\ket{\phi\_j}}{\sqrt{\Pr(\phi\_j)\sum\_j \Pr(\text{Result}|\phi\_j)}}=\sum_j \sqrt{\Pr(\phi\_j|\text{Result})} \ket{\phi\_j}.</span></span>
<span data-ttu-id="837c9-138">\end{align} 這裡 $ \Pr ( \phi \_ j | \text{Result} ) $ 可做為每個假設之歸屬的機率：</span><span class="sxs-lookup"><span data-stu-id="837c9-138">\end{align} Here $\Pr(\phi\_j|\text{Result})$ can be interpretted as the probability that one would ascribe to each hypothesis about the eigenstates given:</span></span>

1. <span data-ttu-id="837c9-139">測量之前的量子狀態知識</span><span class="sxs-lookup"><span data-stu-id="837c9-139">knowledge of the quantum state prior to measurement,</span></span>
2. <span data-ttu-id="837c9-140">$U $ 和的知識 eigenstates</span><span class="sxs-lookup"><span data-stu-id="837c9-140">knowledge of the eigenstates of $U$ and,</span></span>
3. <span data-ttu-id="837c9-141">$U $ 的特徵值知識。</span><span class="sxs-lookup"><span data-stu-id="837c9-141">knowledge of the eigenvalues of $U$.</span></span>

<span data-ttu-id="837c9-142">學習這三件事通常會在傳統電腦上以指數方式呈現。</span><span class="sxs-lookup"><span data-stu-id="837c9-142">Learning these three things is often exponentially hard on a classical computer.</span></span>
<span data-ttu-id="837c9-143">階段估計的公用程式會產生不太小的範圍，因為它可以執行這類的量子學習工作，而不需要知道任何一項。</span><span class="sxs-lookup"><span data-stu-id="837c9-143">The utility of phase estimation arises, to no small extent, from the fact that it can perform such a quantum learning task without knowing any of them.</span></span>
<span data-ttu-id="837c9-144">此原因的階段估計會出現在提供指數加速的一些量子演算法內。</span><span class="sxs-lookup"><span data-stu-id="837c9-144">Phase estimation for this reason appears within a number of quantum algorithms that provide exponential speedups.</span></span>

### <a name="bayesian-phase-estimation"></a><span data-ttu-id="837c9-145">貝氏階段估計</span><span class="sxs-lookup"><span data-stu-id="837c9-145">Bayesian Phase Estimation</span></span> ###

> [!TIP]
> <span data-ttu-id="837c9-146">如需實務貝氏階段估計的詳細資訊，請參閱 [**PhaseEstimation**](https://github.com/microsoft/Quantum/tree/main/samples/characterization/phase-estimation) 範例。</span><span class="sxs-lookup"><span data-stu-id="837c9-146">For more details on Bayesian phase estimation in practice, please see the [**PhaseEstimation**](https://github.com/microsoft/Quantum/tree/main/samples/characterization/phase-estimation) sample.</span></span>

<span data-ttu-id="837c9-147">貝氏階段估計的概念很簡單。</span><span class="sxs-lookup"><span data-stu-id="837c9-147">The idea of Bayesian phase estimation is simple.</span></span>
<span data-ttu-id="837c9-148">您可以從階段估計通訊協定收集度量統計資料，然後使用貝氏推斷處理結果並提供參數的估計值。</span><span class="sxs-lookup"><span data-stu-id="837c9-148">You collect measurement statistics from the phase estimation protocol and then you process the results using Bayesian inference and provide an estimate of the parameter.</span></span>
<span data-ttu-id="837c9-149">這項處理可讓您估計 eigenvalue 以及該預估的不確定性。</span><span class="sxs-lookup"><span data-stu-id="837c9-149">This processing gives you an estimate of the eigenvalue as well as the uncertainty in that estimate.</span></span>
<span data-ttu-id="837c9-150">它也可讓您執行自動調整的實驗，並利用先前的資訊。</span><span class="sxs-lookup"><span data-stu-id="837c9-150">It also allows you to perform adaptive experiments and utilize prior information.</span></span>
<span data-ttu-id="837c9-151">方法的缺點是，它需要計算需求。</span><span class="sxs-lookup"><span data-stu-id="837c9-151">The methods' principle drawback is that it is computationally demanding.</span></span>

<span data-ttu-id="837c9-152">若要瞭解此貝氏推斷流程的運作方式，請考慮處理單一結果的情況 `Zero` 。</span><span class="sxs-lookup"><span data-stu-id="837c9-152">To understand how this Bayesian inference process works, consider the case of processing a single `Zero` result.</span></span>
<span data-ttu-id="837c9-153">請注意，$X = \ket{+} \bra{+}-\ket {-} \bra {-} $，例如 $ \ket{+} $ 是 $X $ 的唯一正面 eigenstate 對應至 `Zero` 。</span><span class="sxs-lookup"><span data-stu-id="837c9-153">Note that $X = \ket{+}\bra{+} - \ket{-}\bra{-}$, such that $\ket{+}$ is the only positive eigenstate of $X$ corresponding to `Zero`.</span></span>
<span data-ttu-id="837c9-154">在 `Zero` 第一個量子位上觀察到輸入狀態 $ \ket{\psi}\ket{\phi} $ 的[ `PauliX` 測量](xref:microsoft.quantum.concepts.pauli)機率，因此 \begin{equation} \Pr ( \texttt{zero} | \psi) = \left | \braket{+ | \psi} \right | ^ 2。</span><span class="sxs-lookup"><span data-stu-id="837c9-154">The probability of observing `Zero` for a [`PauliX` measurement](xref:microsoft.quantum.concepts.pauli) on the first qubit given an input state $\ket{\psi}\ket{\phi}$ is thus \begin{equation} \Pr(\texttt{Zero} | \psi) = \left| \braket{+ | \psi} \right|^2.</span></span>
<span data-ttu-id="837c9-155">\end{equation} 在反復階段估計的案例中，我們有了 $ \ket{\psi} = R_1 (m [\phi-\theta] ) \ket{+} $，使 \begin{align} \Pr ( \texttt{Zero} |phim，\theta) & = \left |\braket{+ |R_1 (m [\phi-\theta] ) |+} \right | ^ 2 \\ \\ & = \left | \frac12 \left ( \bra {0} + \bra {1} \right) \left ( \ket {0} + e ^ {i m [\phi-\theta]} \ket {1} \right) \right | ^ 2 \\ \\ & = \left | \frac{1 + e ^ {i m [\phi-\theta]}} {2} \right | ^ 2 \\ \\ & = \cos ^ 2 (m [\phi-\theta]/2) \tag{★} \label{eq：階段-est-可能性}。</span><span class="sxs-lookup"><span data-stu-id="837c9-155">\end{equation} In the case of iterative phase estimation, we have that $\ket{\psi} = R_1(m [\phi-\theta]) \ket{+}$, such that \begin{align} \Pr(\texttt{Zero} | \phi; m,\theta) & = \left| \braket{+ | R_1(m [\phi-\theta]) | +} \right|^2 \\\\ & = \left| \frac12 \left( \bra{0} + \bra{1} \right) \left( \ket{0} + e^{i m [\phi-\theta]} \ket{1} \right) \right|^2 \\\\ & = \left| \frac{1 + e^{i m [\phi-\theta]}}{2} \right|^2 \\\\ & = \cos^2(m [\phi-\theta] / 2) \tag{★} \label{eq:phase-est-likelihood}.</span></span>
<span data-ttu-id="837c9-156">\end{align} 也就是，反復階段估計包含學習正弦曲線函式的震盪頻率，並能夠以該 sinusoid 所指定的偏差來翻轉硬幣。</span><span class="sxs-lookup"><span data-stu-id="837c9-156">\end{align} That is, iterative phase estimation consists of learning the oscillation frequency of a sinusoidal function, given the ability to flip a coin with a bias given by that sinusoid.</span></span>
<span data-ttu-id="837c9-157">在傳統的傳統術語中，我們稱之為 $ \eqref{eq：階段-est-可能性} $，這是反復階段估計的 *可能性函數* 。</span><span class="sxs-lookup"><span data-stu-id="837c9-157">Following traditional classical terminology, we call $\eqref{eq:phase-est-likelihood}$ the *likelihood function* for iterative phase estimation.</span></span>

<span data-ttu-id="837c9-158">觀察到 `Result` 反復階段估計的可能性函式之後，我們就可以使用貝氏機率分類的規則，以規定應該在該階段之後觀察到的階段。</span><span class="sxs-lookup"><span data-stu-id="837c9-158">Having observed a `Result` from the iterative phase estimation likelihood function, we can then use Bayes' rule to prescribe what we should believe the phase to be following that observation.</span></span>
<span data-ttu-id="837c9-159">具體而言、\begin{equation} \Pr ( \phi |d) = \frac{\Pr (d | \phi) \Pr ( \phi) } {\int \Pr (d | \phi) \Pr ( \phi) {\mathrm d} \phi} \Pr ( \phi) 、\end{equation}，其中 $d \in \\ {\texttt{Zero}，\texttt{One} \\ } $ 是 `Result` ，其中 $ \Pr ( \phi) $ 描述之前的信念與 $ \phi $。</span><span class="sxs-lookup"><span data-stu-id="837c9-159">Concretely, \begin{equation} \Pr(\phi | d) = \frac{\Pr(d | \phi) \Pr(\phi)}{\int \Pr(d | \phi) \Pr(\phi){\mathrm d}\phi} \Pr(\phi), \end{equation} where $d \in \\{\texttt{Zero}, \texttt{One}\\}$ is a `Result`, and where $\Pr(\phi)$ describes our prior beliefs about $\phi$.</span></span>
<span data-ttu-id="837c9-160">如此一來，就可以明確地反復執行反復階段估計的本質，因為「事後 posterior 散發 $ \Pr ( \phi |d) $ 描述我們在下一個的觀察之前的信念 `Result` 。</span><span class="sxs-lookup"><span data-stu-id="837c9-160">This then makes the iterative nature of iterative phase estimation explicit, as the posterior distribution $\Pr(\phi | d)$ describes our beliefs immediately preceding our observation of the next `Result`.</span></span>

<span data-ttu-id="837c9-161">在此程式中的任何時間點，我們可以將傳統控制器推斷的階段 $ \hat{\phi} $ 報告為 \begin{equation} \hat{\phi} \mathrel{： =} \expect [\phi | \text{data}] = \int \phi \Pr ( \phi |\text{data} ) {\mathrm d} \phi，\end{equation}，其中 $ \text{data} $ 代表所有取得值的完整記錄 `Result` 。</span><span class="sxs-lookup"><span data-stu-id="837c9-161">At any point during this procedure, we can report the phase $\hat{\phi}$ inferred by the classical controller as \begin{equation} \hat{\phi} \mathrel{:=} \expect[\phi | \text{data}] = \int \phi \Pr(\phi | \text{data}) {\mathrm d}\phi, \end{equation} where $\text{data}$ stands for the entire record of all `Result` values obtained.</span></span>

<span data-ttu-id="837c9-162">實際的貝氏推斷在實務棘手中。</span><span class="sxs-lookup"><span data-stu-id="837c9-162">Exact Bayesian inference is in practice intractable.</span></span>
<span data-ttu-id="837c9-163">為了瞭解這一點，我們想要學習 $n $-bit 變數 $x $。</span><span class="sxs-lookup"><span data-stu-id="837c9-163">To see this imagine we wish to learn an $n$-bit variable $x$.</span></span>
<span data-ttu-id="837c9-164">先前的散發 $ \Pr (x) $ 支援 $x $ 的 $ 2 ^ n $ 假設值。</span><span class="sxs-lookup"><span data-stu-id="837c9-164">The prior distribution $\Pr(x)$ has support over $2^n$ hypothetical values of $x$.</span></span>
<span data-ttu-id="837c9-165">這表示，如果我們需要高度精確的估計值 $x $ then 貝氏階段估計可能需要過高的記憶體和處理時間。</span><span class="sxs-lookup"><span data-stu-id="837c9-165">This means that if we need a highly accurate estimate of $x$ then Bayesian phase estimation may need prohibitive memory and processing time.</span></span>
<span data-ttu-id="837c9-166">針對某些應用程式（例如量子模擬），所需的 limitted 精確度不會妨礙其他應用程式（例如 Shor 的演算法）在其階段估計步驟內無法使用精確的貝氏推斷。</span><span class="sxs-lookup"><span data-stu-id="837c9-166">While for some applications, such as quantum simulation, the limitted accuracy required does not preclude such methods other applications, such as Shor's algorithm, cannot use exact Bayesian inference within its phase estimation step.</span></span>  <span data-ttu-id="837c9-167">基於這個理由，我們也提供近似貝氏方法的執行，例如 [隨機的逐步解說階段估計 (RWPE) ](xref:Microsoft.Quantum.Research.Characterization.RandomWalkPhaseEstimation) ，也提供非貝氏的方法，例如 [穩固的階段估計](xref:Microsoft.Quantum.Characterization.RobustPhaseEstimation)。</span><span class="sxs-lookup"><span data-stu-id="837c9-167">For this reason, we also provide implementations for approximate Bayesian methods such as [random walk phase estimation (RWPE)](xref:Microsoft.Quantum.Research.Characterization.RandomWalkPhaseEstimation) and also non-Bayesian approaches such as [robust phase estimation](xref:Microsoft.Quantum.Characterization.RobustPhaseEstimation).</span></span>

### <a name="robust-phase-estimation"></a><span data-ttu-id="837c9-168">強大的階段估計</span><span class="sxs-lookup"><span data-stu-id="837c9-168">Robust Phase Estimation</span></span> ###

<span data-ttu-id="837c9-169">在最糟的情況下，最大 *的 posteriori* 貝氏從測量結果中重建階段預估的重建會以指數方式呈現。</span><span class="sxs-lookup"><span data-stu-id="837c9-169">A maximum *a posteriori* Bayesian reconstruction of a phase estimate from measurement results is exponentially hard in the worst-case.</span></span> <span data-ttu-id="837c9-170">因此，大部分實際的階段估計演算法會犧牲部分重建的品質，在 exchange 中，有一種傳統的後置處理，而改為以所進行的度量數目來調整 polynomially。</span><span class="sxs-lookup"><span data-stu-id="837c9-170">Thus most practical phase estimation algorithms sacrifice some quality in the reconstruction, in exchange for an amount of classical post-processing that instead scales polynomially with the number of measurements made.</span></span>

<span data-ttu-id="837c9-171">使用有效率的傳統後續處理步驟的其中一個範例是 [強大的階段估計演算法](https://arxiv.org/abs/1502.02677)，其簽章和上面所述的輸入。</span><span class="sxs-lookup"><span data-stu-id="837c9-171">One such example with an efficient classical post-processing step is the [robust phase estimation algorithm](https://arxiv.org/abs/1502.02677), with its signature and inputs mentioned above.</span></span> <span data-ttu-id="837c9-172">它假設輸入的單一黑色方塊 $U $ 會封裝為 `DiscreteOracle` 類型，因此只會查詢受控制-$U $ 的整數乘冪。</span><span class="sxs-lookup"><span data-stu-id="837c9-172">It assumes that input unitary black-boxes $U$ are packaged as `DiscreteOracle` type, and therefore only queries integer powers of controlled-$U$.</span></span> <span data-ttu-id="837c9-173">如果暫存器中的輸入狀態 `Qubit[]` 是 eigenstate $U \ket{\psi} = e ^ {i\phi} \ ket {\ psi} $，健全的階段估計演算法會將 $ \hat{\phi}\in $ 的估計 $ \pi [-\pi，\phi) $ 視為 `Double` 。</span><span class="sxs-lookup"><span data-stu-id="837c9-173">If the input state in the `Qubit[]` register is an eigenstate $U\ket{\psi}=e^{i\phi}\ket{\psi}$, the robust phase estimation algorithm returns an estimate $\hat{\phi}\in[-\pi,\pi)$ of $\phi$ as a `Double`.</span></span>

<span data-ttu-id="837c9-174">強大的階段估計最重要的功能（與其他大部分的有用變異共用）是 $ \hat{\phi} $ 的重建品質在海森堡有限的情況下是有意義的。</span><span class="sxs-lookup"><span data-stu-id="837c9-174">The most important feature of robust phase estimation, which is shared with most other useful variants, is that the reconstruction quality of $\hat{\phi}$ is in some sense Heisenberg-limited.</span></span> <span data-ttu-id="837c9-175">這表示，如果 $ \hat{\phi} $ from true 值的偏差為 $ \sigma $，則 $ \sigma $ 會以反比的比例，與 $U $ 的查詢總數 $Q $，亦即 $ \sigma = \mathcal{O} (1/Q) $。</span><span class="sxs-lookup"><span data-stu-id="837c9-175">This means that if the deviation of $\hat{\phi}$ from the true value is $\sigma$, then $\sigma$ scales inversely-proportional to the total number of queries $Q$ made to controlled-$U$, i.e. $\sigma=\mathcal{O}(1/Q)$.</span></span> <span data-ttu-id="837c9-176">現在，偏差的定義會因不同的估計演算法而有所不同。</span><span class="sxs-lookup"><span data-stu-id="837c9-176">Now, the definition of deviation varies between different estimation algorithms.</span></span> <span data-ttu-id="837c9-177">在某些情況下，可能表示至少有 $ \mathcal{O} (1) $ 機率，估計錯誤 $ | \hat{\phi}-\phi | \_某些迴圈量值 $ \circ $ 上的 \circ\le \sigma $。</span><span class="sxs-lookup"><span data-stu-id="837c9-177">In some cases, it may mean that with at least $\mathcal{O}(1)$ probability, the estimation error $|\hat{\phi}-\phi|\_\circ\le \sigma$ on some circular measure $\circ$.</span></span> <span data-ttu-id="837c9-178">針對穩固的階段估計，偏差會精確地等於 $ \sigma ^ 2 = \mathbb{E} \_ \hat{\phi} [ ( \mod \_ {2 \ pi} ( \hat{\phi}-\phi + \pi) -\pi) ^ 2] $ 如果我們將定期階段解除包裝成單一有限間隔 $ (-\pi，\pi] $。</span><span class="sxs-lookup"><span data-stu-id="837c9-178">For robust phase estimation, deviation is precisely the variance $\sigma^2 = \mathbb{E}\_\hat{\phi}[(\mod\_{2\pi}(\hat{\phi}-\phi +\pi)-\pi)^2]$ if we unwrap periodic phases onto a single finite interval $(-\pi,\pi]$.</span></span> <span data-ttu-id="837c9-179">更精確地說，健全階段估計的標準差滿足到差異 $ $ \begin{align} 2.0 \pi/Q \le \sigma \le 2 \ pi/2 ^ {n} \le 10.7 \ pi/Q，\end{align} $ $，其中下限是在 asymptotically 大型 $Q $ 的限制內達到，而且即使是小型樣本大小也保證上限。</span><span class="sxs-lookup"><span data-stu-id="837c9-179">More precisely, the standard deviation in robust phase estimation satisfies the inequalities $$ \begin{align} 2.0 \pi / Q \le \sigma \le 2\pi / 2^{n} \le 10.7\pi / Q, \end{align} $$ where the lower bound is reached in the limit of asymptotically large $Q$, and the upper bound is guaranteed even for small sample sizes.</span></span>  <span data-ttu-id="837c9-180">請注意，輸入所選取的 $n $ `bitsPrecision` ，會以隱含方式定義 $Q $。</span><span class="sxs-lookup"><span data-stu-id="837c9-180">Note that $n$ selected by the `bitsPrecision` input, which implicitly defines $Q$.</span></span>

<span data-ttu-id="837c9-181">其他相關的詳細資料（例如，只有 $1 $ ancilla 量子位的小空間額外負荷）或程式是不可調整的，這表示所需的量子實驗順序與中繼測量結果無關。</span><span class="sxs-lookup"><span data-stu-id="837c9-181">Other relevant details include, say, the small space overhead of just $1$ ancilla qubit, or that the procedure is non-adaptive, meaning the required sequence of quantum experiments is independent of the intermediate measurement outcomes.</span></span> <span data-ttu-id="837c9-182">在這個範例中，您可以選擇階段估計演算法的重點，其中一個應該參考檔，例如和參考的發行集， @"microsoft.quantum.characterization.robustphaseestimation" 以取得詳細資訊和其執行。</span><span class="sxs-lookup"><span data-stu-id="837c9-182">In this and forthcoming examples where the choice of phase estimation algorithm is important, one should one should refer to the documentation such as @"microsoft.quantum.characterization.robustphaseestimation" and the referenced publications therein for more information and for their the implementation.</span></span>

> [!TIP]
> <span data-ttu-id="837c9-183">在許多範例中，會使用強大的階段預估。</span><span class="sxs-lookup"><span data-stu-id="837c9-183">There are many samples where robust phase estimation is used.</span></span> <span data-ttu-id="837c9-184">如需瞭解各種實體系統的接地狀態能源，請參閱 [ **H2 模擬** 範例](https://github.com/microsoft/Quantum/tree/main/samples/simulation/h2/command-line)、 [ **SimpleIsing** 範例](https://github.com/microsoft/Quantum/tree/main/samples/simulation/ising/simple)和 [ **Hubbard 模型** 範例](https://github.com/microsoft/Quantum/tree/main/samples/simulation/hubbard)。</span><span class="sxs-lookup"><span data-stu-id="837c9-184">For phase estimation in extracting the ground state energy of various physical system, please see the [**H2 simulation** sample](https://github.com/microsoft/Quantum/tree/main/samples/simulation/h2/command-line), the [**SimpleIsing** sample](https://github.com/microsoft/Quantum/tree/main/samples/simulation/ising/simple), and the [**Hubbard model** sample](https://github.com/microsoft/Quantum/tree/main/samples/simulation/hubbard).</span></span>


### <a name="continuous-oracles"></a><span data-ttu-id="837c9-185">連續 Oracle</span><span class="sxs-lookup"><span data-stu-id="837c9-185">Continuous Oracles</span></span> ###

<span data-ttu-id="837c9-186">我們也可以從上述使用的 oracle 模型一般化，以允許依 canon 類型模型化的持續時間 oracle <xref:Microsoft.Quantum.Oracles.ContinuousOracle> 。</span><span class="sxs-lookup"><span data-stu-id="837c9-186">We can also generalize from the oracle model used above to allow for continuous-time oracles, modeled by the canon type <xref:Microsoft.Quantum.Oracles.ContinuousOracle>.</span></span>
<span data-ttu-id="837c9-187">請考慮使用 $U $ 的單一單一運算子，而不是單一的單一運算子系列 $U (t) $ for $t \in \mathbb{R} $，如此 $U (t) U (s) $ = $U (t + s) $。</span><span class="sxs-lookup"><span data-stu-id="837c9-187">Consider that instead of a single unitary operator $U$, we have a family of unitary operators $U(t)$ for $t \in \mathbb{R}$ such that $U(t) U(s)$ = $U(t + s)$.</span></span>
<span data-ttu-id="837c9-188">這是較弱的語句，因為我們可以藉 <xref:Microsoft.Quantum.Oracles.DiscreteOracle> 由限制 \, 某些固定 $ \delta t $ 的 $t = m \delta t $ 來建立。</span><span class="sxs-lookup"><span data-stu-id="837c9-188">This is a weaker statement than in the discrete case, since we can construct a <xref:Microsoft.Quantum.Oracles.DiscreteOracle> by restricting $t = m\,\delta t$ for some fixed $\delta t$.</span></span>
<span data-ttu-id="837c9-189">藉由 [石頭的定理](https://en.wikipedia.org/wiki/Stone%27s_theorem_on_one-parameter_unitary_groups)，$U (t) = \exp (i H t) $ for a operator $H $，其中 $ \exp $ 是矩陣指數，如 [advanced 矩陣](xref:microsoft.quantum.concepts.matrix-advanced)中所述。</span><span class="sxs-lookup"><span data-stu-id="837c9-189">By [Stone's theorem](https://en.wikipedia.org/wiki/Stone%27s_theorem_on_one-parameter_unitary_groups), $U(t) = \exp(i H t)$ for some operator $H$, where $\exp$ is the matrix exponential as described in [advanced matrices](xref:microsoft.quantum.concepts.matrix-advanced).</span></span>
<span data-ttu-id="837c9-190">Eigenstate $ \ket{\phi} $ of $H $，如此一來，$H \ket{\phi} = \phi \ket{\phi} $ 接著也是 eigenstate of $U (t) $ for all $t $，\begin{equation} U (t) \ket{\phi} = e ^ {i \phi t} \ket{\phi}。</span><span class="sxs-lookup"><span data-stu-id="837c9-190">An eigenstate $\ket{\phi}$ of $H$ such that $H \ket{\phi} = \phi \ket{\phi}$ is then also an eigenstate of $U(t)$ for all $t$, \begin{equation} U(t) \ket{\phi} = e^{i \phi t} \ket{\phi}.</span></span>
<span data-ttu-id="837c9-191">\end{equation}</span><span class="sxs-lookup"><span data-stu-id="837c9-191">\end{equation}</span></span>

<span data-ttu-id="837c9-192">您可以套用針對 [貝氏階段估計](#bayesian-phase-estimation) 所討論的完全相同分析，而且這個更一般 oracle 模型的可能性函式是完全相同的： $ $ \Pr ( \texttt{zero} |phit，\theta) = \cos ^ 2 \ left ( \frac{t [\phi-\theta]} {2} \right) 。</span><span class="sxs-lookup"><span data-stu-id="837c9-192">The exact same analysis discussed for [Bayesian phase estimation](#bayesian-phase-estimation) can be applied, and the likelihood function is the precisely the same for this more general oracle model: $$ \Pr(\texttt{Zero} | \phi; t,\theta)=\cos^2\left(\frac{t[\phi -\theta]}{2}\right).</span></span>
<span data-ttu-id="837c9-193">$ $ 再者，如果 $U $ 是模擬 dynamical 產生器，就像 [Hamiltonian 模擬](xref:microsoft.quantum.libraries.applications#hamiltonian-simulation)的情況一樣，我們會將 $ \phi $ 解釋為能源。</span><span class="sxs-lookup"><span data-stu-id="837c9-193">$$ Moreover, if $U$ is a simulation of a dynamical generator, as is the case for [Hamiltonian simulation](xref:microsoft.quantum.libraries.applications#hamiltonian-simulation), we interpret $\phi$ as an energy.</span></span>
<span data-ttu-id="837c9-194">因此，搭配連續查詢使用階段估計可讓我們瞭解分子、[材質](https://arxiv.org/abs/1510.03859)或[現場理論](https://arxiv.org/abs/1111.3633v2)的模擬[能源](https://arxiv.org/abs/quant-ph/0604193)範圍，而不需要犧牲 $t $ 為整數，而不會危及我們選擇的實驗。</span><span class="sxs-lookup"><span data-stu-id="837c9-194">Thus, using phase estimation with continuous queries allows us to learn the simulated [energy spectrum of molecules](https://arxiv.org/abs/quant-ph/0604193), [materials](https://arxiv.org/abs/1510.03859) or [field theories](https://arxiv.org/abs/1111.3633v2) without having to compromise our choice of experiments by requiring $t$ to be an integer.</span></span>

### <a name="random-walk-phase-estimation"></a><span data-ttu-id="837c9-195">隨機的逐步解說階段估計</span><span class="sxs-lookup"><span data-stu-id="837c9-195">Random Walk Phase Estimation</span></span> ###

<span data-ttu-id="837c9-196">Q# 提供適用于貝氏階段估計的實用近似值，其設計目的是要透過針對從反復階段估計取得的資料記錄，進行隨機的逐步解說，以接近運作的量子裝置。</span><span class="sxs-lookup"><span data-stu-id="837c9-196">Q# provides a useful approximation of Bayesian phase estimation designed for use close to quantum devices that operates by conditioning a random walk on the data record obtained from iterative phase estimation.</span></span>
<span data-ttu-id="837c9-197">這個方法是可調整且完全具決定性的，可讓您在估計階段 $ \hat{\phi} $ 中，以極低的記憶體額外負荷來調整最接近最佳的錯誤。</span><span class="sxs-lookup"><span data-stu-id="837c9-197">This method is both adaptive and entirely deterministic, allowing for near-optimal scaling of errors in the estimated phase $\hat{\phi}$ with very low memory overheads.</span></span>

<span data-ttu-id="837c9-198">此通訊協定會使用大約的貝氏推斷方法，假設先前的散發是高斯。</span><span class="sxs-lookup"><span data-stu-id="837c9-198">The protocol uses an approximate Bayesian inference method that assumes the prior distribution is Gaussian.</span></span>
<span data-ttu-id="837c9-199">這個高斯假設可讓我們針對實驗流量分析公式，將「事後 posterior 變異數降至最低。</span><span class="sxs-lookup"><span data-stu-id="837c9-199">This Gaussian assumption allows us to use an analytical formula for the experiment that minimizes the posterior variance.</span></span>
<span data-ttu-id="837c9-200">然後，演算法會根據該實驗的結果，將 $ \phi $ 左方或右方的估計值向左或向右移動，並依預先決定的金額來縮減變異數。</span><span class="sxs-lookup"><span data-stu-id="837c9-200">The algorithm then, based on the outcome of that experiment, shifts the estimate of $\phi$ left or right by a pre-determined amount and shrinks the variance by a pre-determined amount.</span></span>
<span data-ttu-id="837c9-201">這表示和變異數會提供在下一個實驗的 $ \phi $ 之前指定高斯所需的所有資訊。</span><span class="sxs-lookup"><span data-stu-id="837c9-201">This mean and variance give all the information that is needed to specify a Gaussian prior on $\phi$ for the next experiment.</span></span>
<span data-ttu-id="837c9-202">未預期的測量失敗或真正的結果是在先前的初始連接結尾上，可能會導致此方法失敗。</span><span class="sxs-lookup"><span data-stu-id="837c9-202">Unexpected measurement failures, or the true result being on the tails of the initial prior, can cause this method to fail.</span></span>
<span data-ttu-id="837c9-203">它會藉由執行實驗來測試目前的平均值和標準差是否適用于系統，從失敗中復原。</span><span class="sxs-lookup"><span data-stu-id="837c9-203">It recovers from failure by performing experiments to test whether the current mean and standard deviation are appropriate for the system.</span></span>
<span data-ttu-id="837c9-204">如果不是，則演算法會執行逐步解說的反向步驟，並繼續進行處理。</span><span class="sxs-lookup"><span data-stu-id="837c9-204">If they are not, then the algorithm does an inverse step of the walk and the process continues.</span></span>
<span data-ttu-id="837c9-205">回溯的功能也可讓演算法學習，即使最初的標準差 inapropriately 小也是如此。</span><span class="sxs-lookup"><span data-stu-id="837c9-205">The ability to step backwards also allows the algorithm to learn even if the initial prior standard deviation is inapropriately small.</span></span>

## <a name="calling-phase-estimation-algorithms"></a><span data-ttu-id="837c9-206">呼叫階段估計演算法</span><span class="sxs-lookup"><span data-stu-id="837c9-206">Calling Phase Estimation Algorithms</span></span> ##

<span data-ttu-id="837c9-207">Canon 所提供的每個階段估計作業都會 Q# 採用一組不同的輸入，將我們所要求的品質參數化為最終估計 $ \hat{\phi} $。</span><span class="sxs-lookup"><span data-stu-id="837c9-207">Each phase estimation operation provided with the Q# canon takes a different set of inputs parameterizing the quality that we demand out of the final estimate $\hat{\phi}$.</span></span>
<span data-ttu-id="837c9-208">不過，這些不同的輸入全都共用數個輸入，因此在品質參數上的部分應用程式會產生一般簽章。</span><span class="sxs-lookup"><span data-stu-id="837c9-208">These various inputs, however, all share several inputs in common, such that partial application over the quality parameters results in a common signature.</span></span>
<span data-ttu-id="837c9-209">例如，下一 <xref:Microsoft.Quantum.Characterization.RobustPhaseEstimation> 節中所討論的作業具有下列簽章：</span><span class="sxs-lookup"><span data-stu-id="837c9-209">For example, the <xref:Microsoft.Quantum.Characterization.RobustPhaseEstimation> operation discussed in the next section has the following signature:</span></span>

```qsharp
operation RobustPhaseEstimation(bitsPrecision : Int, oracle : DiscreteOracle, eigenstate : Qubit[])  : Double
```

<span data-ttu-id="837c9-210">`bitsPrecision`輸入是唯一的 `RobustPhaseEstimation` ，但 `oracle` `eigenstate` 在一般情況下是唯一的。</span><span class="sxs-lookup"><span data-stu-id="837c9-210">The `bitsPrecision` input is unique to `RobustPhaseEstimation`, while `oracle` and `eigenstate` are in common.</span></span>
<span data-ttu-id="837c9-211">因此，如 **H2Sample** 中所示，作業可以接受具有表單輸入的反復階段估計演算法， `(DiscreteOracle, Qubit[]) => Unit` 以允許使用者指定任意階段估計演算法：</span><span class="sxs-lookup"><span data-stu-id="837c9-211">Thus, as seen in **H2Sample**, an operation can accept an iterative phase estimation algorithm with an input of the form `(DiscreteOracle, Qubit[]) => Unit` to allow a user to specify arbitrary phase estimation algorithms:</span></span>

```qsharp
operation H2EstimateEnergy(
    idxBondLength : Int,
    trotterStepSize : Double,
    phaseEstAlgorithm : ((DiscreteOracle, Qubit[]) => Double))
: Double
```

<span data-ttu-id="837c9-212">這些無數階段估計演算法已針對不同的屬性和輸入參數優化，您必須瞭解這些演算法，才能針對目標應用程式做出最佳選擇。</span><span class="sxs-lookup"><span data-stu-id="837c9-212">These myriad phase estimation algorithms are optimized for different properties and input parameters, which must be understood to make the best choice for the target application.</span></span> <span data-ttu-id="837c9-213">比方說，某些階段估計演算法是可調整的，也就是說，未來步驟的測量結果傳統方式會控制未來的步驟。</span><span class="sxs-lookup"><span data-stu-id="837c9-213">For instance, some phase estimation algorithms are adaptive, meaning that future steps are classically controlled by the measurement results of previous steps.</span></span> <span data-ttu-id="837c9-214">有些人需要能夠透過任意的實際電源來 exponentiate 其黑箱的單一 oracle，而其他則只需要整數的電源，但只能解析階段預估模數 $ 2 \ pi $。</span><span class="sxs-lookup"><span data-stu-id="837c9-214">Some require the ability to exponentiate its black-box unitary oracle by arbitrary real powers, and others only require integer powers but are only able to resolve a phase estimate modulo $2\pi$.</span></span> <span data-ttu-id="837c9-215">有些需要許多輔助量子位，有些則只需要一個。</span><span class="sxs-lookup"><span data-stu-id="837c9-215">Some require many auxiliary qubits, and others require only one.</span></span>

<span data-ttu-id="837c9-216">同樣地，使用隨機的逐步解說階段估計，與 canon 提供的其他演算法進行的方式大致相同：</span><span class="sxs-lookup"><span data-stu-id="837c9-216">Similarly, using random walk phase estimation proceeds in much the same way as for other algorithms provided with the canon:</span></span>

```qsharp
operation ApplyExampleOracle(
    eigenphase : Double,
    time : Double,
    register : Qubit[])
: Unit is Adj + Ctl {
    Rz(2.0 * eigenphase * time, register[0]);
}

operation EstimateBayesianPhase(eigenphase : Double) : Double {
    let oracle = ContinuousOracle(ApplyExampleOracle(eigenphase, _, _));
    using (eigenstate = Qubit()) {
        X(eigenstate);
        // The additional inputs here specify the mean and variance of the prior, the number of
        // iterations to perform, how many iterations to perform as a maximum, and how many
        // steps to roll back on an approximation failure.
        let est = RandomWalkPhaseEstimation(0.0, 1.0, 61, 100000, 1, oracle, [eigenstate]);
        Reset(eigenstate);
        return est;
    }
}
```
