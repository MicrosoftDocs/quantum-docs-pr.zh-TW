---
title: 中的量子演算法Q#
description: 瞭解基本的量子計算演算法，包括振幅放大、傅立葉轉換、Draper 和 Beauregard adders，以及階段估計。
author: QuantumWriter
ms.author: martinro@microsoft.com
ms.date: 12/11/2017
ms.topic: article
uid: microsoft.quantum.libraries.standard.algorithms
no-loc:
- Q#
- $$v
ms.openlocfilehash: 0b5972480061c460345057285bbfe53305acc122
ms.sourcegitcommit: 6bf99d93590d6aa80490e88f2fd74dbbee8e0371
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 08/06/2020
ms.locfileid: "87868809"
---
# <a name="quantum-algorithms"></a><span data-ttu-id="439bf-103">量子演算法</span><span class="sxs-lookup"><span data-stu-id="439bf-103">Quantum Algorithms</span></span> #

## <a name="amplitude-amplification"></a><span data-ttu-id="439bf-104">幅度放大</span><span class="sxs-lookup"><span data-stu-id="439bf-104">Amplitude Amplification</span></span> ##

<span data-ttu-id="439bf-105">*振幅放大*是量子運算的基本工具之一。</span><span class="sxs-lookup"><span data-stu-id="439bf-105">*Amplitude Amplification* is one of the fundamental tools of Quantum Computing.</span></span> <span data-ttu-id="439bf-106">這是基礎 Grover 搜尋、振幅估計和許多量子機器學習演算法的基本概念。</span><span class="sxs-lookup"><span data-stu-id="439bf-106">It is the fundamental idea that underlies Grover's search, amplitude estimation and many quantum machine learning algorithms.</span></span>  <span data-ttu-id="439bf-107">有許多變化，而在中， Q# 我們提供了以部分反射為基礎之遺忘式振幅放大的一般版本，以允許最廣泛的應用程式區域。</span><span class="sxs-lookup"><span data-stu-id="439bf-107">There are many variants, and in Q# we provide a general version based on Oblivious Amplitude Amplification with Partial Reflections to allow for the widest area of application.</span></span>

<span data-ttu-id="439bf-108">在振幅放大背後的主要概念，是藉由執行一系列反射來擴展所需結果的機率。</span><span class="sxs-lookup"><span data-stu-id="439bf-108">The central idea behind amplitude amplification is to amplify the probability of a desired outcome occurring by performing a sequence of reflections.</span></span>  <span data-ttu-id="439bf-109">這些反射會將初始狀態旋轉到想要的目標狀態，通常稱為標示的狀態。</span><span class="sxs-lookup"><span data-stu-id="439bf-109">These reflections rotate the initial state closer towards a desired target state, often called a marked state.</span></span>  <span data-ttu-id="439bf-110">具體而言，如果測量起始狀態的機率是 $ \sin ^ 2 ( \theta) $，然後在套用波幅放大 $m $ 倍，成功的機率就會變成 $ \sin ^ 2 ( # B3 2m + 1) \theta) $。</span><span class="sxs-lookup"><span data-stu-id="439bf-110">Specifically, if the probability of measuring the initial state to be in a marked state is $\sin^2(\theta)$ then after applying amplitude amplification $m$ times the probability of success becomes $\sin^2((2m+1)\theta)$.</span></span>  <span data-ttu-id="439bf-111">這表示如果 $ \theta = \ pi/[2 (2n + 1) ] $ 適用于 $n $ 的某個值，則振幅放大能夠 \\ 在 $n $ 反覆運算幅度放大之後，提高成功到 $100% $ 的機率。</span><span class="sxs-lookup"><span data-stu-id="439bf-111">This means that if $\theta = \pi/[2(2n+1)]$ for some value of $n$ then amplitude amplification is capable of boosting the probability of success to $100\\%$ after $n$ iterations of amplitude amplification.</span></span>  <span data-ttu-id="439bf-112">由於 $ \theta = \sin ^ {-1} ( \sqrt{\pr (success) } ) $ 這表示要以決定性方式取得成功所需的反復專案數，其 quadratically 低於使用隨機取樣來以非決定性的方式尋找標示的狀態所需的數目。</span><span class="sxs-lookup"><span data-stu-id="439bf-112">Since $\theta = \sin^{-1}(\sqrt{\Pr(success)})$ this means that the number of iterations needed to obtain a success deterministically is quadratically lower than the expected number needed to find a marked state non-deterministically using random sampling.</span></span>

<span data-ttu-id="439bf-113">振幅放大的每次反覆運算都需要指定兩個反映運算子。</span><span class="sxs-lookup"><span data-stu-id="439bf-113">Each iteration of Amplitude amplification requires that two reflection operators be specified.</span></span> <span data-ttu-id="439bf-114">具體而言，如果 $Q $ 是「幅度放大」會逐一查看並 $P _0 $ 是在初始子空間上的投影機運算子，而 $P _1 $ 是投影機放在標示的子空間上，然後 $Q =- ( \boldone-2P_0) # A2\boldone-2P_1) $。</span><span class="sxs-lookup"><span data-stu-id="439bf-114">Specifically, if $Q$ is the amplitude amplification iterate and $P_0$ is a projector operator onto the initial subspace and $P_1$ is the projector onto the marked subspace then $Q=-(\boldone-2P_0)(\boldone -2P_1)$.</span></span>  <span data-ttu-id="439bf-115">回想一下，投影機是具有特徵值 $ + $1 和 $0 $ 的 Hermitian 操作員，因此 $ ( \boldone-2P_0) $ 是單一的，因為它的特徵值是 unity (的根，在此案例中為 $ \pm $1) 。</span><span class="sxs-lookup"><span data-stu-id="439bf-115">Recall that a projector is a Hermitian operator that has eigenvalues $+1$ and $0$ and as a result $(\boldone -2P_0)$ is unitary because it has eigenvalues that are roots of unity (in this case $\pm 1$).</span></span> <span data-ttu-id="439bf-116">例如，假設 Grover 的搜尋案例中的初始狀態 $H ^ {\otimes n} \ket {0} $ 並標示 state $ \ket{m} $，$P _0 = H ^ {\otimes n} \ket {0} \bra {0} H ^ {\otimes n} $ 和 $P _1 = \ket{m}\bra{m} $。</span><span class="sxs-lookup"><span data-stu-id="439bf-116">As an example, consider the case of Grover's search with initial state $H^{\otimes n} \ket{0}$ and marked state $\ket{m}$, $P_0 = H^{\otimes n}\ket{0}\bra{0}H^{\otimes n}$ and $P_1= \ket{m}\bra{m}$.</span></span>  <span data-ttu-id="439bf-117">在大部分的振幅放大應用程式中 $P _0 $ 將會成為初始狀態的投影機，這表示 $P _0 = \boldone-2 \ ket {\ psi} \ bra {\ psi} $ 適用于某些向量 $ \ket{\psi} $;不過，對於遺忘式振幅 amplication $P _0 $ 通常會投射到許多配量狀態 (亦即，$P _0 $ 的 $ + $1 eigenvalue 的多重性大於 $1 $) 。</span><span class="sxs-lookup"><span data-stu-id="439bf-117">In most applications of amplitude amplification $P_0$ will be a projector onto an initial state meaning that $P_0 = \boldone -2\ket{\psi}\bra{\psi}$ for some vector $\ket{\psi}$; however, for oblivious amplitude amplication $P_0$ will typically project onto many quantum states (i.e. the multiplicity of the $+1$ eigenvalue of $P_0$ is greater than $1$).</span></span>

<span data-ttu-id="439bf-118">在振幅放大後的邏輯會直接從 $Q $ 的特徵分解。</span><span class="sxs-lookup"><span data-stu-id="439bf-118">The logic behind amplitude amplification follows directly from the eigen-decomposition of $Q$.</span></span>  <span data-ttu-id="439bf-119">具體而言，$Q $ 的特徵向量 $ （初始狀態具有非零的支援）可以顯示為 $ + $1 特徵向量的線性組合，$P _0 $ 和 $P _1 $。</span><span class="sxs-lookup"><span data-stu-id="439bf-119">Specifically, the eigenvectors of $Q$ that the initial state has non-zero support over can be shown to be linear combinations of the $+1$ eigenvectors of $P_0$ and $P_1$.</span></span>  <span data-ttu-id="439bf-120">具體而言，「幅度放大」的初始狀態 (假設它是 $P _0 $) 的 $ + $1 eigenvector，可以寫成 $ $ \ket{\psi} = \frac{-i}{\sqrt {2} } \left (e ^ {i\theta} \ ket {\ psi_ +} + e ^ {-i\theta} \ ket {\ psi_-} \right) ，$ $，其中 $ \ket{\ psi_ \pm} $ 特徵向量 $Q $ with 特徵值 $e ^ {\pm 2i \ theta} $，而且只支援 $P 特徵向量 $ 和 $P _1 $ 的 $ + $1 _0。</span><span class="sxs-lookup"><span data-stu-id="439bf-120">Specifically, the initial state for amplitude amplification (assuming it is a $+1$ eigenvector of $P_0$) can be written as $$ \ket{\psi}=\frac{-i}{\sqrt{2}}\left(e^{i\theta}\ket{\psi_+} + e^{-i\theta}\ket{\psi_-}\right), $$ where $\ket{\psi_\pm}$ are eigenvectors of $Q$ with eigenvalues $e^{\pm  2i\theta}$ and only have support on the $+1$ eigenvectors of $P_0$ and $P_1$.</span></span>  <span data-ttu-id="439bf-121">特徵值是 $e ^ {\pm i \theta} $ 的事實，意味著運算子 $Q $ 會在兩個投影機所指定的二維子空間中執行旋轉，以及旋轉角度為 $ 2 \ theta $ 的初始狀態。</span><span class="sxs-lookup"><span data-stu-id="439bf-121">The fact that the eigenvalues are $e^{\pm i \theta}$ implies that the operator $Q$ performs a rotation in a two-dimensional subspace specified by the two projectors and the initial state where the rotation angle is $2\theta$.</span></span>  <span data-ttu-id="439bf-122">這就是為什麼在 $m $ 反復 $Q $ 的成功機率為 $ \sin ^ 2 ( [2m + 1] \theta) $ 之後。</span><span class="sxs-lookup"><span data-stu-id="439bf-122">This is why after $m$ iterations of $Q$ the success probability is $\sin^2([2m+1]\theta)$.</span></span>

<span data-ttu-id="439bf-123">另一個很實用的屬性，就是 eigenvalue $ \theta $ 與在 $P _0 $ 是投影機僅限於初始狀態) 的情況下，會將初始狀態標示為 (的機率直接相關。</span><span class="sxs-lookup"><span data-stu-id="439bf-123">Another useful property that comes out of this is that the eigenvalue $\theta$ is directly related to probability that the initial state would be marked (in the case where $P_0$ is a projector onto only the initial state).</span></span>  <span data-ttu-id="439bf-124">由於 $Q $ 的 eigenphases 是 $ 2 \ theta = 2 \ sin ^ {-1} ( \sqrt{\pr (success) } ) $，因此，如果我們將階段估計套用到 $Q $，我們就可以瞭解單一量副程式成功的機率。</span><span class="sxs-lookup"><span data-stu-id="439bf-124">Since the eigenphases of $Q$ are $2\theta = 2\sin^{-1}(\sqrt{\Pr(success)})$ it then follows that if we apply phase estimation to $Q$ then we can learn the probability of success for a unitary quantum procedure.</span></span>  <span data-ttu-id="439bf-125">這項功能很有用，因為它需要 quadratically 較少的量副程式應用程式，以瞭解比其他方式需要的成功機率。</span><span class="sxs-lookup"><span data-stu-id="439bf-125">This is useful because it requires quadratically fewer applications of the quantum procedure to learn the success probability than would otherwise be needed.</span></span>

<span data-ttu-id="439bf-126">Q#引進了振幅放大，做為遺忘式振幅放大的特製化。</span><span class="sxs-lookup"><span data-stu-id="439bf-126">Q# introduces amplitude amplification as a specialization of oblivious amplitude amplification.</span></span>  <span data-ttu-id="439bf-127">遺忘式幅度放大會獲得此名字標記，因為投影機到初始 eigenspace 不一定是投影機進入初始狀態。</span><span class="sxs-lookup"><span data-stu-id="439bf-127">Oblivious amplitude amplification earns this moniker because the projector onto the initial eigenspace need not be a projector onto the initial state.</span></span>  <span data-ttu-id="439bf-128">就這一點而言，通訊協定會遺忘式為初始狀態。</span><span class="sxs-lookup"><span data-stu-id="439bf-128">In this sense, the protocol is oblivious to the initial state.</span></span>  <span data-ttu-id="439bf-129">遺忘式振幅放大的主要應用是單一 Hamiltonian 模擬方法的特定*線性組合，其中*初始狀態為未知，但會隨著模擬通訊協定中的 ancilla 暫存器而變成光子。</span><span class="sxs-lookup"><span data-stu-id="439bf-129">The key application of oblivious amplitude amplification is in certain *linear combinations of unitary* Hamiltonian simulation methods, wherein the initial state is unknown but becomes entangled with an ancilla register in the simulation protocol.</span></span>  <span data-ttu-id="439bf-130">如果要將此 ancilla 暫存器測量為固定值（例如 $0 $），則這類模擬方法會將所需的單一轉換套用到剩餘的 qubits (，稱為系統暫存器) 。</span><span class="sxs-lookup"><span data-stu-id="439bf-130">If this ancilla register were to be measured to be a fixed value, say $0$, then such simulation methods apply the desired unitary transformation to the remaining qubits (called the system register).</span></span>  <span data-ttu-id="439bf-131">不過，所有其他的測量結果都會導致失敗。</span><span class="sxs-lookup"><span data-stu-id="439bf-131">All other measurement outcomes lead to failure however.</span></span>  <span data-ttu-id="439bf-132">遺忘式振幅放大可讓您使用上述推理，將此度量的成功機率提升至 $100 \\ % $。</span><span class="sxs-lookup"><span data-stu-id="439bf-132">Oblivious amplitude amplification allows the probability of success of this measurement to be boosted to $100\\%$ using the above reasoning.</span></span>  <span data-ttu-id="439bf-133">此外，一般振幅放大會對應到系統暫存器為空白的情況。</span><span class="sxs-lookup"><span data-stu-id="439bf-133">Further, ordinary amplitude amplification corresponds to the case where the system register is empty.</span></span>  <span data-ttu-id="439bf-134">這就是為什麼會 Q# 使用遺忘式振幅放大作為其基礎的振幅放大副程式。</span><span class="sxs-lookup"><span data-stu-id="439bf-134">This is why Q# uses oblivious amplitude amplification as its fundamental amplitude amplification subroutine.</span></span>

<span data-ttu-id="439bf-135">一般常式 (`AmpAmpObliviousByReflectionPhases`) 有兩個我們呼叫和的暫存器 `ancillaRegister` `systemRegister` 。</span><span class="sxs-lookup"><span data-stu-id="439bf-135">The general routine (`AmpAmpObliviousByReflectionPhases`) has two registers that we call `ancillaRegister` and `systemRegister`.</span></span> <span data-ttu-id="439bf-136">它也會接受兩個 oracles 來進行必要的反射。</span><span class="sxs-lookup"><span data-stu-id="439bf-136">It also accepts two oracles for the necessary reflections.</span></span> <span data-ttu-id="439bf-137">`ReflectionOracle`只會在上運作， `ancillaRegister` 同時在兩個暫存器 `ObliviousOracle` 上共同運作。</span><span class="sxs-lookup"><span data-stu-id="439bf-137">The `ReflectionOracle` acts only on the `ancillaRegister` while the `ObliviousOracle` acts jointly on both registers.</span></span> <span data-ttu-id="439bf-138">的輸入 `ancillaRegister` 必須初始化為第一個反映運算子 $ \boldone-2P_1 $ 的-1 eigenstate。</span><span class="sxs-lookup"><span data-stu-id="439bf-138">The input to `ancillaRegister` must be initialized to a -1 eigenstate of the first reflection operator $\boldone -2P_1$.</span></span>

<span data-ttu-id="439bf-139">一般來說，oracle 會以計算基礎 $ \ket{0...0} $ 來準備狀態。</span><span class="sxs-lookup"><span data-stu-id="439bf-139">Typically, the oracle prepares the state in the computational basis $\ket{0...0}$.</span></span> <span data-ttu-id="439bf-140">在我們的實現中， `ancillaRegister` 一個 qubit (的 consistes `flagQubit` 會控制 `stateOracle` 和其餘所需 ancillas 的) 。</span><span class="sxs-lookup"><span data-stu-id="439bf-140">In our implementation, the `ancillaRegister` consistes of one qubit (`flagQubit`) that controls the `stateOracle` and the rest of the desired ancillas.</span></span> <span data-ttu-id="439bf-141">`stateOracle`當 `flagQubit` 為 $ \ket $ 時，就會套用 {1} 。</span><span class="sxs-lookup"><span data-stu-id="439bf-141">The `stateOracle` is applied when the `flagQubit` is $\ket{1}$.</span></span>

<span data-ttu-id="439bf-142">其中一個也可以透過 `StateOracle` 呼叫來提供 oracles， `ObliviousOracle` 而不是反映反射 `AmpAmpObliviousByOraclePhases` 。</span><span class="sxs-lookup"><span data-stu-id="439bf-142">One may also provide oracles `StateOracle` and `ObliviousOracle` instead of reflections via a call to `AmpAmpObliviousByOraclePhases`.</span></span>

<span data-ttu-id="439bf-143">如前所述，傳統的振幅放大只是這些常式的特殊案例，其中 `ObliviousOracle` 是身分識別運算子，而且沒有系統 qubits (亦即， `systemRegister`) 是空的。</span><span class="sxs-lookup"><span data-stu-id="439bf-143">As mentioned, traditional Amplitude Amplification is just a special case of these routines where `ObliviousOracle` is the identity operator and there are no system qubits (i.e., `systemRegister` is empty).</span></span> <span data-ttu-id="439bf-144">如果您想要取得部分反射的階段 (例如，針對 Grover 搜尋) ， `AmpAmpPhasesStandard` 可以使用函數。</span><span class="sxs-lookup"><span data-stu-id="439bf-144">If you wish to obtain phases for partial reflections (e.g., for Grover search), the function `AmpAmpPhasesStandard` is available.</span></span> <span data-ttu-id="439bf-145">`DatabaseSearch.qs`如需 Grover 演算法的範例執行，請參閱。</span><span class="sxs-lookup"><span data-stu-id="439bf-145">Please refer to `DatabaseSearch.qs` for a sample implementation of Grover's algorithm.</span></span>

<span data-ttu-id="439bf-146">我們會將單一 qubit 迴圈階段關聯至反映運算子階段[，如 G.H. Low、Chuang](https://arxiv.org/abs/1707.05391)中所述。</span><span class="sxs-lookup"><span data-stu-id="439bf-146">We relate the single-qubit rotation phases to the reflection operator phases as described in the paper by [G.H. Low, I. L. Chuang](https://arxiv.org/abs/1707.05391).</span></span> <span data-ttu-id="439bf-147">[Yoder、low 和 Chuang](https://arxiv.org/abs/1409.3305)中會詳細說明所使用的固定點階段，以及[低、Yoder 和 Chuang](https://arxiv.org/abs/1603.03996)中的階段。</span><span class="sxs-lookup"><span data-stu-id="439bf-147">The fixed point phases that are used are detailed in [Yoder, Low and Chuang](https://arxiv.org/abs/1409.3305) along with the phases in [Low, Yoder and Chuang](https://arxiv.org/abs/1603.03996).</span></span>

<span data-ttu-id="439bf-148">在背景中，您可以從[標準的振幅放大](https://arxiv.org/abs/quant-ph/0005055)開始，然後移至[遺忘式振幅放大](https://arxiv.org/abs/1312.1414)的簡介，最後會以[低和 Chuang](https://arxiv.org/abs/1610.06546)呈現的一般化。</span><span class="sxs-lookup"><span data-stu-id="439bf-148">For background, you could start from [Standard Amplitude Amplification](https://arxiv.org/abs/quant-ph/0005055) then move to an introduction to [Oblivious Amplitude Amplification](https://arxiv.org/abs/1312.1414) and finally generalizations presented in [Low and Chuang](https://arxiv.org/abs/1610.06546).</span></span> <span data-ttu-id="439bf-149">這整個領域的絕佳概覽簡報 (，因為它與 Hamiltonian 模擬) 是由[Dominic Berry](http://www.dominicberry.org/presentations/Durban.pdf)提供的。</span><span class="sxs-lookup"><span data-stu-id="439bf-149">A nice overview presentation of this entire area (as it relates to Hamiltonian Simulation) was given by [Dominic Berry](http://www.dominicberry.org/presentations/Durban.pdf).</span></span>

## <a name="quantum-fourier-transform"></a><span data-ttu-id="439bf-150">量子傅立葉轉換</span><span class="sxs-lookup"><span data-stu-id="439bf-150">Quantum Fourier Transform</span></span> ##

<span data-ttu-id="439bf-151">傅立葉轉換是傳統分析的基本工具，對量子計算而言也是一樣重要。</span><span class="sxs-lookup"><span data-stu-id="439bf-151">The Fourier transform is a fundamental tool of classical analysis and is just as important for quantum computations.</span></span>
<span data-ttu-id="439bf-152">此外，配量*傅立葉轉換* (QFT) 遠超過傳統電腦的效率，使其成為設計配量演算法時的第一個選擇工具。</span><span class="sxs-lookup"><span data-stu-id="439bf-152">In addition, the efficiency of the *quantum Fourier transform* (QFT) far surpasses what is possible on a classical machine making it one of the first tools of choice when designing a quantum algorithm.</span></span>

<span data-ttu-id="439bf-153">做為 QFT 的大致一般化，我們提供了作業 <xref:microsoft.quantum.canon.approximateqft> ，可讓您藉由剪除所需演算法精確度不一定需要的旋轉來進一步優化。</span><span class="sxs-lookup"><span data-stu-id="439bf-153">As an approximate generalization of the QFT, we provide the <xref:microsoft.quantum.canon.approximateqft> operation that allows for further optimizations by pruning rotations that aren't strictly necessary for the desired algorithmic accuracy.</span></span>
<span data-ttu-id="439bf-154">大約的 QFT 需要 dyadic $Z $-輪替作業和作業 <xref:microsoft.quantum.intrinsic.rfrac> <xref:microsoft.quantum.intrinsic.h> 。</span><span class="sxs-lookup"><span data-stu-id="439bf-154">The approximate QFT requires the dyadic $Z$-rotation operation <xref:microsoft.quantum.intrinsic.rfrac> as well as the <xref:microsoft.quantum.intrinsic.h> operation.</span></span>
<span data-ttu-id="439bf-155">假設輸入和輸出是以 big endian 編碼來編碼---也就是說，具有索引的 qubit `0` 會在二進位整數表示的最左邊 (最高) 位進行編碼。</span><span class="sxs-lookup"><span data-stu-id="439bf-155">The input and output are assumed to be encoded in big endian encoding---that is, the qubit with index `0` is encoded in the left-most (highest) bit of the binary integer representation.</span></span>
<span data-ttu-id="439bf-156">這會與[ket 標記法](xref:microsoft.quantum.concepts.dirac)對齊，因為 state $ \ket $ 中的三個 qubits 暫存器 {100} 對應于 state $ \ket $ 中的 $q _0 $ {1} ，同時 $q _1 $ 和 $q _2 $ 同時處於 state $ \ket {0} $。</span><span class="sxs-lookup"><span data-stu-id="439bf-156">This aligns with [ket notation](xref:microsoft.quantum.concepts.dirac), as a register of three qubits in the state $\ket{100}$ corresponds to $q_0$ being in the state $\ket{1}$ while $q_1$ and $q_2$ are both in state $\ket{0}$.</span></span>
<span data-ttu-id="439bf-157">近似值參數 $a $ 決定 $Z $-輪替的剪除層級，也就是 $a \in [0 ... n] $。</span><span class="sxs-lookup"><span data-stu-id="439bf-157">The approximation parameter $a$ determines the pruning level of the $Z$-rotations, i.e., $a \in [0..n]$.</span></span>
<span data-ttu-id="439bf-158">在此情況下，所有 $Z $-輪替 $ 2 \ pi/2 ^ k $，其中 $k > $ 會從 QFT 迴圈中移除。</span><span class="sxs-lookup"><span data-stu-id="439bf-158">In this case all $Z$-rotations $2\pi/2^k$ where $k > a$ are removed from the QFT circuit.</span></span>
<span data-ttu-id="439bf-159">已知 $k \ge \ log_2 (n) + \ log_2 (1/\epsilon) + $3。</span><span class="sxs-lookup"><span data-stu-id="439bf-159">It is known that for $k \ge \log_2(n) + \log_2(1 / \epsilon) + 3$.</span></span> <span data-ttu-id="439bf-160">其中一個可以系結 $ \\ | \operatorname{QFT}-\operatorname{AQFT} \\ | < \epsilon $。</span><span class="sxs-lookup"><span data-stu-id="439bf-160">one can bound $\\| \operatorname{QFT} - \operatorname{AQFT} \\| < \epsilon$.</span></span>
<span data-ttu-id="439bf-161">這裡 $ \\ | \cdot \\ | $ 是運算子的標準，在此案例中是 $ ( \Operatorname{qft}-\operatorname{AQFT} ) # A2\OPERATORNAME {QFT}-\operatorname{AQFT} ) ^ \dagger $ 的最大[eigenvalue](xref:microsoft.quantum.concepts.matrix-advanced)的平方根。</span><span class="sxs-lookup"><span data-stu-id="439bf-161">Here $\\|\cdot\\|$ is the operator norm which in this case is the square root of the largest [eigenvalue](xref:microsoft.quantum.concepts.matrix-advanced) of $(\operatorname{QFT} - \operatorname{AQFT})(\operatorname{QFT} - \operatorname{AQFT})^\dagger$.</span></span>

## <a name="arithmetic"></a><span data-ttu-id="439bf-162">算術</span><span class="sxs-lookup"><span data-stu-id="439bf-162">Arithmetic</span></span> ##

<span data-ttu-id="439bf-163">就像算術在傳統運算中扮演中央角色一樣，這在量子計算中也是不可或缺的。</span><span class="sxs-lookup"><span data-stu-id="439bf-163">Just as arithmetic plays a central role in classical computing, it is also indispensable in quantum computing.</span></span>  <span data-ttu-id="439bf-164">演算法（例如快速鍵的分解演算法、量子模擬方法以及許多 oracular 演算法）依賴一致的算數運算。</span><span class="sxs-lookup"><span data-stu-id="439bf-164">Algorithms such as Shor's factoring algorithm, quantum simulation methods as well as many oracular algorithms rely upon coherent arithmetic operations.</span></span>  <span data-ttu-id="439bf-165">在量子加入線路上進行算術組建的大部分方法。</span><span class="sxs-lookup"><span data-stu-id="439bf-165">Most approaches to arithmetic build upon quantum adder circuits.</span></span>  <span data-ttu-id="439bf-166">最簡單的加入程式會採用傳統輸入 $b $，並將值新增至保留整數 $ \ket{a} $ 的量子狀態。</span><span class="sxs-lookup"><span data-stu-id="439bf-166">The simplest adder takes a classical input $b$ and adds the value to a quantum state holding an integer $\ket{a}$.</span></span>  <span data-ttu-id="439bf-167">在數學上， (的對應器中，我們代表 $ \operatorname{Add} (b) $ 用於傳統輸入 $b $) 的屬性，</span><span class="sxs-lookup"><span data-stu-id="439bf-167">Mathematically, the adder (which we denote $\operatorname{Add}(b)$ for classical input $b$) has the property that</span></span>

<span data-ttu-id="439bf-168">$ $ \operatorname{Add} (b) \ket{a} = \ket{a + b}。</span><span class="sxs-lookup"><span data-stu-id="439bf-168">$$ \operatorname{Add}(b)\ket{a}=\ket{a + b}.</span></span>
<span data-ttu-id="439bf-169">$ $ 這個基本的產生程式線路比 incrementer 更多。</span><span class="sxs-lookup"><span data-stu-id="439bf-169">$$ This basic adder circuit is more of an incrementer than an adder.</span></span>
<span data-ttu-id="439bf-170">它可以轉換成具有兩個配量輸入的加入器，透過 $ $ \operatorname{Add}\ket{a}\ket{b} = \ket{a}\ket{a + b}，$ $ $n 使用 adders 的 \begin{align} \operatorname{Add} \ket{a} \ket{b} & = \Lambda \_ {a \_ 0} \Left ( \operatorname{Add} (1) \right) \Lambda \_ {a \_ 1} \left ( \operatorname{Add} (2) \right) \Lambda \_ {a \_ 2} \left ( \operatorname{Add} (4) \right) \cdots \Lambda \_ {a \_ {n-1}} \left ( \operatorname{Add} ( {{n-1}} ) \right) \ket{a}\ket{b} \\ \\ & = \ket{a} \ket{b + a}，$n $ 位整數 $a $ 和 $b $ 和加法模數 $ 2 ^ n $ 的 \end{align}。</span><span class="sxs-lookup"><span data-stu-id="439bf-170">It can be converted into an adder that has two quantum inputs via $$ \operatorname{Add}\ket{a}\ket{b}=\ket{a}\ket{a+b}, $$ using $n$ controlled applications of adders of the form \begin{align} \operatorname{Add} \ket{a} \ket{b} & = \Lambda\_{a\_0} \left(\operatorname{Add}(1) \right) \Lambda\_{a\_1} \left(\operatorname{Add}(2) \right) \Lambda\_{a\_2} \left(\operatorname{Add}(4) \right) \cdots \Lambda\_{a\_{n-1}} \left(\operatorname{Add}({{n-1}}) \right) \ket{a}\ket{b} \\\\ & = \ket{a} \ket{b + a}, \end{align} for $n$-bit integers $a$ and $b$ and addition modulo $2^n$.</span></span>  <span data-ttu-id="439bf-171">回想一下，標記法 $ \Lambda \_ x (A) $ 所參考的任何作業 $A $，到該作業的受控制版本，qubit $x $ as 控制項。</span><span class="sxs-lookup"><span data-stu-id="439bf-171">Recall that the notation $\Lambda\_x(A)$ refers, for any operation $A$, to the controlled version of that operation with the qubit $x$ as control.</span></span>

<span data-ttu-id="439bf-172">同樣地，傳統方式控管的乘法 (模組化形式，這對快速鍵的分解演算法而言是不可或缺的，) 可以使用一系列的受控制新增來執行： \begin{align} \operatorname{Mult} (a) \ket{x}\ket{b} & = \Lambda \_ {x \_ 0} \Left ( \operatorname{add} (2 ^ 0 a) \Right) \Lambda \_ {a \_ 1} \left ( \operatorname{add} (2 ^ 1a) \right) \Lambda \_ {a \_ 2} \left ( \operatorname{add} (2 ^ 2 a) \right) \cdots \Lambda \_ {x \_ {n-1}} \left ( \operatorname{add} ( {2 ^ {n-1}} a) \right) \ket{x}\ket{b} \\ \\ & = \ket{x}\ket{b + ax}。</span><span class="sxs-lookup"><span data-stu-id="439bf-172">Similarly, classically controlled multiplication (a modular form of which is essential for Shor's factoring algorithm) can be performed by using a similar series of controlled  additions: \begin{align} \operatorname{Mult}(a)\ket{x}\ket{b} & = \Lambda\_{x\_0}\left(\operatorname{Add}(2^0 a)\right) \Lambda\_{a\_1}\left(\operatorname{Add}(2^1a)\right) \Lambda\_{a\_2}\left(\operatorname{Add}(2^2 a)\right) \cdots \Lambda\_{x\_{n-1}} \left(\operatorname{Add}({2^{n-1}}a) \right)\ket{x}\ket{b} \\\\ & = \ket{x}\ket{b+ax}.</span></span>
<span data-ttu-id="439bf-173">\end{align} 有一個奧妙在配量電腦上有乘法，您可能會注意到上面的 $ \operatorname{Mult} $ 定義。</span><span class="sxs-lookup"><span data-stu-id="439bf-173">\end{align} There is a subtlety with multiplication on quantum computers that you may notice from the definition of $\operatorname{Mult}$ above.</span></span>  <span data-ttu-id="439bf-174">不同于新增，此線路的量子版本會將輸入的產品儲存在輔助暫存器中，而不是輸入暫存器中。</span><span class="sxs-lookup"><span data-stu-id="439bf-174">Unlike addition, the quantum version of this circuit stores the product of the inputs in an ancillary register rather than in the input register.</span></span>  <span data-ttu-id="439bf-175">在此範例中，會使用值 $b $ 初始化暫存器，但通常會開始保留值零。</span><span class="sxs-lookup"><span data-stu-id="439bf-175">In this example, the register is initialized with the value $b$, but typically it will start holding the value zero.</span></span>  <span data-ttu-id="439bf-176">這在中是必要的，因為一般而言，一般 $a $ 和 $x $ 不會有乘法的反向。</span><span class="sxs-lookup"><span data-stu-id="439bf-176">This is needed in because in general there is not a multiplicative inverse for general $a$ and $x$.</span></span>  <span data-ttu-id="439bf-177">由於所有的量子作業（儲存量測）都是可復原的，因此我們需要保留足夠的資訊來反轉乘法。</span><span class="sxs-lookup"><span data-stu-id="439bf-177">Since all quantum operations, save measurement, are reversible we need to keep enough information around to invert the multiplication.</span></span>  <span data-ttu-id="439bf-178">基於這個理由，結果會儲存在不同的陣列中。</span><span class="sxs-lookup"><span data-stu-id="439bf-178">For this reason the result is stored in a separate array.</span></span>  <span data-ttu-id="439bf-179">將無法復原之作業的輸出（例如乘法）儲存在個別的暫存器中，在 Charlie Bennett 之後稱為「Bennett 技巧」，而且是可還原和量子運算的基本工具。</span><span class="sxs-lookup"><span data-stu-id="439bf-179">This trick of saving the output of an irreversible operation, like multiplication, in a separate register is known as the "Bennett trick" after Charlie Bennett and is a fundamental tool in both reversible and quantum computing.</span></span>

<span data-ttu-id="439bf-180">許多配量線路已針對加法提出建議，而且每個電路都會根據 qubits (空間) 數目和所需的閘道)  (作業數目，來探索不同的取捨。</span><span class="sxs-lookup"><span data-stu-id="439bf-180">Many quantum circuits have been proposed for addition and each explores a different tradeoff in terms of the number of qubits (space) and the number of gate operations (time) required.</span></span>  <span data-ttu-id="439bf-181">我們在下方回顧兩個高空間效率的 adders，稱為 Draper 的「進行」和「Beauregard」。</span><span class="sxs-lookup"><span data-stu-id="439bf-181">We review two highly space efficient adders below known as the Draper adder and the Beauregard adder.</span></span>

### <a name="draper-adder"></a><span data-ttu-id="439bf-182">Draper 的</span><span class="sxs-lookup"><span data-stu-id="439bf-182">Draper Adder</span></span> ###

<span data-ttu-id="439bf-183">Draper 的新增項可說是其中一個最簡潔的量子 adders，因為它會直接叫用配量屬性來執行加法。</span><span class="sxs-lookup"><span data-stu-id="439bf-183">The Draper adder is arguably one of the most elegant quantum adders, as it directly invokes quantum properties to perform addition.</span></span>  <span data-ttu-id="439bf-184">Draper 加入程式背後的深入解析，是可以使用傅立葉轉換來將階段轉移轉譯成位移位。</span><span class="sxs-lookup"><span data-stu-id="439bf-184">The insight behind the Draper adder is that the Fourier transform can be used to translate phase shifts into a bit shift.</span></span>  <span data-ttu-id="439bf-185">接著，藉由套用傅立葉轉換、套用適當的階段移位，然後復原傅立葉轉換，您就可以執行合併器。</span><span class="sxs-lookup"><span data-stu-id="439bf-185">It then follows that by applying a Fourier transform, applying appropriate phase shifts, and then undoing the Fourier transform you can implement an adder.</span></span>  <span data-ttu-id="439bf-186">不同于其他許多已提議的 adders，Draper 的加入程式會明確地使用透過配量傅立葉轉換所引進的量子效果。</span><span class="sxs-lookup"><span data-stu-id="439bf-186">Unlike many other adders that have been proposed, the Draper adder explicitly uses quantum effects introduced through the quantum Fourier transform.</span></span>  <span data-ttu-id="439bf-187">它沒有自然的傳統對應。</span><span class="sxs-lookup"><span data-stu-id="439bf-187">It does not have a natural classical counterpart.</span></span>  <span data-ttu-id="439bf-188">以下提供 Draper 相應的特定步驟。</span><span class="sxs-lookup"><span data-stu-id="439bf-188">The specific steps of the Draper adder are given below.</span></span>

<span data-ttu-id="439bf-189">假設您有兩個 $n $ bit qubit 暫存器儲存 $a $ 和 $b $ 的整數，然後適用于所有 $a $ $ $ \operatorname{QFT}\ket{a} = \frac {1} {\sqrt{2 ^ n}} \sum \_ {j = 0} ^ {2 ^ n-1} e ^ {i2\pi (aj) /2 ^ n} \ket{j}。</span><span class="sxs-lookup"><span data-stu-id="439bf-189">Assume that you have two $n$-bit qubit registers storing the integers $a$ and $b$ then for all $a$ $$ \operatorname{QFT}\ket{a}= \frac{1}{\sqrt{2^n}}\sum\_{j=0}^{2^n-1} e^{i2\pi(aj)/2^n} \ket{j}.</span></span>
<span data-ttu-id="439bf-190">$ $ 如果我們定義 $ $ \ket{\phi \_ k () } = \frac {1} {\sqrt {2} } \left ( \ket {0} + e ^ {i2\pi a/2 ^ k} \ket {1} \right) ，$ $，然後在某些代數之後，您可以看到 $ $ \operatorname{QFT}\ket{a} = \ket{\phi \_ 1 () } \otimes \cdots \otimes \ket{\phi \_ n () }。</span><span class="sxs-lookup"><span data-stu-id="439bf-190">$$ If we define $$ \ket{\phi\_k(a)} = \frac{1}{\sqrt{2}}\left(\ket{0} + e^{i2\pi a /2^k}\ket{1} \right), $$ then after some algebra you can see that $$ \operatorname{QFT}\ket{a}=\ket{\phi\_1(a)}\otimes \cdots \otimes \ket{\phi\_n(a)}.</span></span>
<span data-ttu-id="439bf-191">$ $ 執行轉換程式的路徑會在觀察到輸入的總和可以寫成 $ $ \ket{a + b} = \operatorname{QFT} ^ {-1} \ket{\phi \_ 1 (a + b) } \otimes \cdots \otimes \ket{\phi \_ n (a + b) } 之後變得清楚。</span><span class="sxs-lookup"><span data-stu-id="439bf-191">$$ The path towards performing an adder then becomes clear after observing that the sum of the inputs can be written as $$ \ket{a+b}=\operatorname{QFT}^{-1}\ket{\phi\_1(a+b)}\otimes \cdots \otimes \ket{\phi\_n(a+b)}.</span></span>
<span data-ttu-id="439bf-192">$ $ $B $ 和 $a $ 的整數可以藉由使用 $b $ 作為控制項的位，在分解中的每個 qubits 上執行控制階段旋轉來新增。</span><span class="sxs-lookup"><span data-stu-id="439bf-192">$$ The integers $b$ and $a$ can then be added by performing controlled-phase rotation on each of the qubits in the decomposition using the bits of $b$ as controls.</span></span>

<span data-ttu-id="439bf-193">請注意，對於任何整數 $j $ 和 real $x $，$e ^ {i2\pi (x + j) } = e ^ {i2\pi x} $，可進一步簡化這項擴充。</span><span class="sxs-lookup"><span data-stu-id="439bf-193">This expansion can be further simplified by noting that for any integer $j$ and real number $x$, $e^{i2\pi(x+j)}=e^{i2\pi x}$.</span></span>  <span data-ttu-id="439bf-194">這是因為如果您在圓圈中旋轉 $ 360 ^ {\circ} $ 度數 ($ 2 \ pi $ radians) ，就會精確地結束。</span><span class="sxs-lookup"><span data-stu-id="439bf-194">This is because if you rotate $360^{\circ}$ degrees ($2\pi$ radians) in a circle then you end up precisely where you started.</span></span>  <span data-ttu-id="439bf-195">$E ^ {i2\pi x} $ 的 $x $ 唯一重要的部分，就是 $x $ 的小數部分。</span><span class="sxs-lookup"><span data-stu-id="439bf-195">The only important part of $x$ for $e^{i2\pi x}$ is therefore the fractional part of $x$.</span></span>  <span data-ttu-id="439bf-196">具體而言，如果我們有格式為 $x = y +0 的二進位擴充。 x \_ 0x \_ 2 \ ldots x \_ n $ then $e ^ {i2\pi x} = e ^ {i2\pi (0. x \_ 0x \_ 2 \ ldots x \_ {n-1} ) } $，因此 $ $ \ket{\phi \_ k (a + b) } = \frac {1} {\sqrt {2} } \left ( \ket {0} + e ^ {i2\pi [a/2 ^ k +0。 b \_ K\ldots b \_ 1]} \ket {1} \right) . $ $ 這表示如果我們藉由在 $ \ket{a} $ 的傅立葉轉換擴展中增加每個張量因數來執行加法，則旋轉數目會隨著 $k $ 減少而縮小。</span><span class="sxs-lookup"><span data-stu-id="439bf-196">Specifically, if we have a binary expansion of the form $x=y+0.x\_0x\_2\ldots x\_n$ then $e^{i2\pi x}=e^{i2\pi (0.x\_0x\_2\ldots x\_{n-1})}$ and hence $$\ket{\phi\_k(a+b)}=\frac{1}{\sqrt{2}}\left(\ket{0} + e^{i2\pi [a/2^k+0.b\_k\ldots b\_1]}\ket{1} \right).$$ This means that if we perform addition by incrementing each of the tensor factors in the expansion of the Fourier transform of $\ket{a}$ then the number of rotations shrinks as $k$ decreases.</span></span>  <span data-ttu-id="439bf-197">這會大幅減少在「增加項」中所需的量子閘道數目。</span><span class="sxs-lookup"><span data-stu-id="439bf-197">This substantially reduces the number of quantum gates needed in the adder.</span></span>  <span data-ttu-id="439bf-198">我們以 $ \operatorname{QFT} ^ {-1} \left ( \Phi \\ \! \operatorname{ADD}\right) \operatorname{QFT} $ 的形式，來代表傅立葉轉換、相位加法和反向傅立葉轉換步驟。</span><span class="sxs-lookup"><span data-stu-id="439bf-198">We denote the Fourier transform, phase addition and the inverse Fourier transform steps that comprise the Draper adder as $\operatorname{QFT}^{-1} \left(\phi\\\!\operatorname{ADD}\right) \operatorname{QFT}$.</span></span> <span data-ttu-id="439bf-199">以下是使用這種簡化來執行整個程式的量子線路。</span><span class="sxs-lookup"><span data-stu-id="439bf-199">A quantum circuit that uses this simplification to implement the entire process can be seen below.</span></span>

![顯示為「電路圖」的 Draper](~/media/draper.svg)

<span data-ttu-id="439bf-201">線路中的每個受控制 $e ^ {i2 \ pi/k} $ 閘道指的是受控制階段的閘道。</span><span class="sxs-lookup"><span data-stu-id="439bf-201">Each controlled $e^{i2\pi/k}$ gate in the circuit refers to a controlled-phase gate.</span></span>  <span data-ttu-id="439bf-202">這類閘道的屬性會在其作用的 qubits 上，$ \ket {00} \mapsto \ket {00} $ 但 $ \ket {11} \mapsto e ^ {i2 \ pi/k} \ ket {11} $。</span><span class="sxs-lookup"><span data-stu-id="439bf-202">Such gates have the property that on the pair of qubits on which they act, $\ket{00}\mapsto \ket{00}$ but $\ket{11}\mapsto e^{i2\pi/k}\ket{11}$.</span></span>  <span data-ttu-id="439bf-203">此線路可讓我們使用除了儲存輸入和輸出所需的其他 qubits 來執行加法。</span><span class="sxs-lookup"><span data-stu-id="439bf-203">This circuit allows us to perform addition using no additional qubits apart from those needed to store the inputs and the outputs.</span></span>

### <a name="beauregard-adder"></a><span data-ttu-id="439bf-204">Beauregard 的</span><span class="sxs-lookup"><span data-stu-id="439bf-204">Beauregard Adder</span></span> ###

<span data-ttu-id="439bf-205">Beauregard 的加入程式是一種配量模組化的「配量」，它會使用 Draper 加入程式來對任意值 $N $ 的正整數執行加法模數 $N $。</span><span class="sxs-lookup"><span data-stu-id="439bf-205">The Beauregard adder is a quantum modular adder that uses the Draper adder in order to perform addition modulo $N$ for an arbitrary value positive integer $N$.</span></span>  <span data-ttu-id="439bf-206">量子模組化 adders （例如 Beauregard 的加入器）的重要性，會從其在快速鍵的演算法中用於分解的模組乘冪步驟中，被視為很大的範圍。</span><span class="sxs-lookup"><span data-stu-id="439bf-206">The significance of quantum modular adders, such as the Beauregard adder, stems to a large extent from their use in the modular exponentiation step within Shor's algorithm for factoring.</span></span>  <span data-ttu-id="439bf-207">配量模組化的加入器對於配量輸入 $ \ket{b} $ 和傳統輸入 $a $ 具有下列動作，其中 $a $ 和 $b $ 會承諾為整數 mod $N $，表示它們是在間隔 $ [0，\ldots，N-1] $ 中。</span><span class="sxs-lookup"><span data-stu-id="439bf-207">A quantum modular adder has the following action for quantum input $\ket{b}$ and classical input $a$ where $a$ and $b$ are promised to be integers mod $N$, meaning that they are in the interval $[0,\ldots, N-1]$.</span></span>

<span data-ttu-id="439bf-208">$ $ \ket{b}\rightarrow \ket{b + a \text{mod} N} = \begin{cases} \ket{b + a}、& b + a < N \\ \\ \ket{b + a-n}、& (b + a) \ge N \end{cases}。</span><span class="sxs-lookup"><span data-stu-id="439bf-208">$$ \ket{b}\rightarrow \ket{b+a \text{ mod }N}=\begin{cases} \ket{b+a},& b+a < N\\\\ \ket{b+a-N},& (b+a)\ge N \end{cases}.</span></span>
$$

<span data-ttu-id="439bf-209">Beauregard 的新增載入項會使用 Draper 加入或更具體的 $ \phi \\ \! \operatorname{ADD} $，在階段中新增 $a $ 和 $b $。</span><span class="sxs-lookup"><span data-stu-id="439bf-209">The Beauregard adder uses the Draper adder, or more specifically $\phi\\\!\operatorname{ADD}$, to add $a$ and $b$ in phase.</span></span>  <span data-ttu-id="439bf-210">然後，它會使用相同的作業來識別是否 $a + b <N $，方法是減去 $N $，並在 $a + b-N<$0 時進行測試。</span><span class="sxs-lookup"><span data-stu-id="439bf-210">It then uses the same operation to identify whether $a+b <N$ by subtracting $N$ and testing if $a+b-N<0$.</span></span>  <span data-ttu-id="439bf-211">線路會將這項資訊儲存在輔助 qubit 中，然後在 $a + b<N $ 時，將 $N $ 返回註冊。</span><span class="sxs-lookup"><span data-stu-id="439bf-211">The circuit stores this information in an ancillary qubit and then adds $N$ back the register if $a+b<N$.</span></span>  <span data-ttu-id="439bf-212">最後，它會藉由 uncomputing 此輔助元件來結束， (需要此步驟，以確保在呼叫加入器) 之後，可以取消配置 ancilla。</span><span class="sxs-lookup"><span data-stu-id="439bf-212">It then concludes by uncomputing this ancillary bit (this step is needed to ensure that the ancilla can be de-allocated after calling the adder).</span></span>  <span data-ttu-id="439bf-213">以下提供 Beauregard 對應程式的線路。</span><span class="sxs-lookup"><span data-stu-id="439bf-213">The circuit for the Beauregard adder is given below.</span></span>

![顯示為「電路圖」的 Beauregard](~/media/beau.svg)

<span data-ttu-id="439bf-215">這裡的閘道 $ \Phi \\ \! \operatorname{ADD} $ 採用與 $ \Phi \operatorname{ADD} $ 相同的形式 \\ \! ，但在此內容中，輸入是傳統而不是配量。</span><span class="sxs-lookup"><span data-stu-id="439bf-215">Here the gate $\Phi\\\!\operatorname{ADD}$ takes the same form as $\phi\\\!\operatorname{ADD}$ except that in this context the input is classical rather than quantum.</span></span>  <span data-ttu-id="439bf-216">這可讓 $ \Phi \Operatorname{ADD} $ 中受控制的階段 \\ \! 取代為階段閘道，然後將其編譯成較少的作業，以減少 qubits 數目和加入程式所需的閘道數目。</span><span class="sxs-lookup"><span data-stu-id="439bf-216">This allows the controlled phases in $\Phi\\\!\operatorname{ADD}$ to be replaced with phase gates that can then be compiled together into fewer operations to reduce both the number of qubits and number of gates needed for the adder.</span></span>

<span data-ttu-id="439bf-217">如需詳細資訊，請參閱[Roetteler、Beth](http://doi.org/10.1007/s00200-008-0072-2 )和[Coppersmith](https://arxiv.org/abs/quant-ph/0201067)。</span><span class="sxs-lookup"><span data-stu-id="439bf-217">For more details, please refer to [M. Roetteler, Th. Beth](http://doi.org/10.1007/s00200-008-0072-2 ) and [D. Coppersmith](https://arxiv.org/abs/quant-ph/0201067).</span></span>

### <a name="quantum-phase-estimation"></a><span data-ttu-id="439bf-218">量子相位估算法</span><span class="sxs-lookup"><span data-stu-id="439bf-218">Quantum Phase Estimation</span></span> ###

<span data-ttu-id="439bf-219">配量傅立葉轉換的一個特別重要應用，是瞭解單一運算子的特徵值，這是一個稱為「*階段估計*」的問題。</span><span class="sxs-lookup"><span data-stu-id="439bf-219">One particularly important application of the quantum Fourier transform is to learn the eigenvalues of unitary operators, a problem known as *phase estimation*.</span></span>
<span data-ttu-id="439bf-220">請考慮使用單一 $U $ 和 state $ \ket{\phi} $，讓 $ \ket{\phi} $ 是 $U $ 的 eigenstate，其中包含未知的 eigenvalue $ \phi $、\begin{equation} U\ket {\ phi} = \phi\ket{\phi}。</span><span class="sxs-lookup"><span data-stu-id="439bf-220">Consider a unitary $U$ and a state $\ket{\phi}$ such that $\ket{\phi}$ is an eigenstate of $U$ with unknown eigenvalue $\phi$, \begin{equation} U\ket{\phi} = \phi\ket{\phi}.</span></span>
<span data-ttu-id="439bf-221">\end{equation} 如果我們只有 $U $ 做為 oracle 的存取權，我們就可以藉由使用對受控制作業的目標所套用的 $Z $ 旋轉，來學習階段 $ \phi $，將其傳播回控制項上。</span><span class="sxs-lookup"><span data-stu-id="439bf-221">\end{equation} If we only have access to $U$ as an oracle, then we can learn the phase $\phi$ by utilizing that $Z$ rotations applied to the target of a controlled operation propagate back onto the control.</span></span>

<span data-ttu-id="439bf-222">假設 $V $ 是受控制的 $U $ 應用程式，因此 \begin{align} V ( \ket {0} \otimes \ket{\phi} ) & = \ket {0} \otimes \ket{\phi} \textrm{ \\ \\ 和} V ( \ket {1} \otimes \ket{\phi} ) & = e ^ {i \phi} \ket {1} \otimes \ket{\phi}。</span><span class="sxs-lookup"><span data-stu-id="439bf-222">Suppose that $V$ is a controlled application of $U$, such that \begin{align} V (\ket{0} \otimes \ket{\phi}) & =            \ket{0} \otimes \ket{\phi} \\\\ \textrm{ and } V (\ket{1} \otimes \ket{\phi}) & = e^{i \phi} \ket{1} \otimes \ket{\phi}.</span></span>
<span data-ttu-id="439bf-223">\end{align} Then，by 線性，\begin{align} V ( \ket{+} \otimes \ket{\phi} ) & = \frac{ ( \ket {0} \otimes \ket{\phi} ) + e ^ {i \phi} ( \ket {1} \otimes \ket{\phi} ) } {\sqrt {2} }。</span><span class="sxs-lookup"><span data-stu-id="439bf-223">\end{align} Then, by linearity, \begin{align} V(\ket{+} \otimes \ket{\phi}) & = \frac{ (\ket{0} \otimes \ket{\phi}) + e^{i \phi} (\ket{1} \otimes \ket{\phi}) }{\sqrt{2}}.</span></span>
<span data-ttu-id="439bf-224">\end{align} 我們可以收集詞彙，以尋找 \begin{align} V ( \ket{+} \otimes \ket{\phi} ) & = \frac{\ket {0} + e ^ {i \phi} \ket {1} } {\sqrt {2} } \otimes \ket{\phi} \\ \\ & = (R_1 ( \phi) \ket{+} ) \otimes \ket{\phi}，\end{align}，其中 $R _1 $ 是作業所套用的單一 <xref:microsoft.quantum.intrinsic.r1> 。</span><span class="sxs-lookup"><span data-stu-id="439bf-224">\end{align} We can collect terms to find that \begin{align} V(\ket{+} \otimes \ket{\phi}) & = \frac{\ket{0} + e^{i \phi} \ket{1}}{\sqrt{2}} \otimes \ket{\phi} \\\\ & = (R_1(\phi) \ket{+}) \otimes \ket{\phi}, \end{align} where $R_1$ is the unitary applied by the <xref:microsoft.quantum.intrinsic.r1> operation.</span></span>
<span data-ttu-id="439bf-225">以不同的方式放置，套用 $V $ 的效果與將 $R _1 $ 與未知的角度一起套用，即使我們只有以 oracle 的方式存取 $V $ 也一樣。</span><span class="sxs-lookup"><span data-stu-id="439bf-225">Put differently, the effect of applying $V$ is precisely the same as applying $R_1$ with an unknown angle, even though we only have access to $V$ as an oracle.</span></span>
<span data-ttu-id="439bf-226">因此，在本討論的其餘部分中，我們將討論以 $R _1 ( \phi) $ 的階段估計，我們使用所謂的*階段 kickback*來執行這項工作。</span><span class="sxs-lookup"><span data-stu-id="439bf-226">Thus, for the rest of this discussion we will discuss phase estimation in terms of $R_1(\phi)$, which we implement by using so-called *phase kickback*.</span></span>

<span data-ttu-id="439bf-227">由於控制項和目標暫存器在此程式之後仍會 untangled，因此我們可以重複使用 $ \ket{\phi} $ 作為受控制應用程式的目標 $U ^ $2 來準備第二個控制項 qubit 的狀態 $R _1 (2 \phi) \ket{+} $。</span><span class="sxs-lookup"><span data-stu-id="439bf-227">Since the control and target register remain untangled after this process, we can reuse $\ket{\phi}$ as the target of a controlled application of $U^2$ to prepare a second control qubit in the state $R_1(2 \phi) \ket{+}$.</span></span>
<span data-ttu-id="439bf-228">以這種方式繼續進行，我們可以取得表單 \begin{align} \ket{\psi} & = \ sum_ {j = 0} ^ n R_1 (2 ^ j \phi) \ket{+} \\ \\ & \propto \ bigotimes_ {j = 0} ^ {n} \left ( \ket {0} + \exp (i 2 ^ {j} \phi) \ket {1} \right) \\ \\ & \propto \ sum_ {k = 0} ^ {2 ^ n-1} \exp (i \phi k) \ket{k} \end{align}，其中 $n $ 是我們需要的精確度位數。我們已使用 $ {} \propto {} $ 來表示我們已抑制 $1/\sqrt{2 ^ n} $ 的正規化因數。</span><span class="sxs-lookup"><span data-stu-id="439bf-228">Continuing in this way, we can obtain a register of the form \begin{align} \ket{\psi} & = \sum_{j = 0}^n R_1(2^j \phi) \ket{+} \\\\ & \propto \bigotimes_{j=0}^{n} \left(\ket{0} + \exp(i 2^{j} \phi) \ket{1}\right) \\\\ & \propto \sum_{k = 0}^{2^n - 1} \exp(i \phi k) \ket{k} \end{align} where $n$ is the number of bits of precision that we require, and where we have used ${} \propto {}$ to indicate that we have suppressed the normalization factor of $1 / \sqrt{2^n}$.</span></span>

<span data-ttu-id="439bf-229">如果我們假設 $ \phi = 2 \pi p/2 ^ k $ 適用于 integer $p $，則我們會將它辨識為 $ \ket{\psi} = \operatorname{QFT} \ket{p_0 p_1 \dots .. p_n} $，其中 $p _j $ 是 $2 \textrm{th}} \pi $ 的 $j ^ {\phi $ bit。</span><span class="sxs-lookup"><span data-stu-id="439bf-229">If we assume that $\phi = 2 \pi p / 2^k$ for an integer $p$, then we recognize this as $\ket{\psi} = \operatorname{QFT} \ket{p_0 p_1 \dots p_n}$, where $p_j$ is the $j^{\textrm{th}}$ bit of $2 \pi \phi$.</span></span>
<span data-ttu-id="439bf-230">套用配量傅立葉轉換的 adjoint 時，我們會取得編碼為配量狀態之階段的二進位標記法。</span><span class="sxs-lookup"><span data-stu-id="439bf-230">Applying the adjoint of the quantum Fourier transform, we therefore obtain the binary representation of the phase encoded as a quantum state.</span></span>

<span data-ttu-id="439bf-231">在中， Q# 這是由作業所執行 <xref:microsoft.quantum.characterization.quantumphaseestimation> ，它會採用 <xref:microsoft.quantum.oracles.discreteoracle> $U ^ m $ 的實作為 $m $ 的正整數函式來執行應用程式。</span><span class="sxs-lookup"><span data-stu-id="439bf-231">In Q#, this is implemented by the <xref:microsoft.quantum.characterization.quantumphaseestimation> operation, which takes a <xref:microsoft.quantum.oracles.discreteoracle> implementing application of $U^m$ as a function of positive integers $m$.</span></span>
