---
title: 標準程式庫中的應用程式 Q#
description: 瞭解量子運算中的兩個基本應用程式-Hamiltonian 模擬和 Shor 的搜尋演算法。
author: QuantumWriter
uid: microsoft.quantum.libraries.applications
ms.author: martinro
ms.date: 12/11/2017
ms.topic: article
no-loc:
- Q#
- $$v
ms.openlocfilehash: 115cd65621afd8272887b36163b066a4e6a554d7
ms.sourcegitcommit: 9b0d1ffc8752334bd6145457a826505cc31fa27a
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 09/21/2020
ms.locfileid: "90835650"
---
# <a name="applications"></a><span data-ttu-id="a79ee-103">應用程式</span><span class="sxs-lookup"><span data-stu-id="a79ee-103">Applications</span></span> #

## <a name="hamiltonian-simulation"></a><span data-ttu-id="a79ee-104">哈密頓模擬</span><span class="sxs-lookup"><span data-stu-id="a79ee-104">Hamiltonian Simulation</span></span> ##

<span data-ttu-id="a79ee-105">模擬量子系統是最令人興奮的量子計算應用程式之一。</span><span class="sxs-lookup"><span data-stu-id="a79ee-105">The simulation of quantum systems is one of the most exciting applications of quantum computation.</span></span>
<span data-ttu-id="a79ee-106">在傳統電腦上，模擬量子機制的困難之處在于，通常會以其狀態向量表示的維度 $N $ 來進行調整。</span><span class="sxs-lookup"><span data-stu-id="a79ee-106">On a classical computer, the difficulty of simulating quantum mechanics, in general, scales with the dimension $N$ of its state-vector representation.</span></span>
<span data-ttu-id="a79ee-107">當此表示以指數方式成長時，$n $ 量子位 $N = 2 ^ n $ 的特性，也就是 [已知的特性，也](xref:microsoft.quantum.concepts.multiple-qubits)就是在傳統硬體上進行量子模擬的棘手。</span><span class="sxs-lookup"><span data-stu-id="a79ee-107">As this representation grows exponentially with the number of $n$ qubits $N=2^n$, a trait known also known as the [curse of dimensionality](xref:microsoft.quantum.concepts.multiple-qubits), quantum simulation on classical hardware is intractable.</span></span>

<span data-ttu-id="a79ee-108">不過，在量子硬體上的情況可能會非常不同。</span><span class="sxs-lookup"><span data-stu-id="a79ee-108">However, the situation can be very different on quantum hardware.</span></span> <span data-ttu-id="a79ee-109">量子模擬最常見的變化，就是所謂與時間無關的 Hamiltonian 模擬問題。</span><span class="sxs-lookup"><span data-stu-id="a79ee-109">The most common variation of quantum simulation is called the time-independent Hamiltonian simulation problem.</span></span> <span data-ttu-id="a79ee-110">其中會提供系統 Hamiltonian 的描述，$H $ （即 Hermitian 矩陣），以及一些在量子電腦上 $n $ 量子位編碼的初始量子狀態 $ \ket{\psi (0) } $。</span><span class="sxs-lookup"><span data-stu-id="a79ee-110">There, one is provided with a description of the system Hamiltonian $H$, which is a Hermitian matrix, and some initial quantum state $\ket{\psi(0)}$ that is encoded in some basis on $n$ qubits on a quantum computer.</span></span> <span data-ttu-id="a79ee-111">當封閉式系統中的量子狀態演進時，薛丁格方程式 $ $ \begin{align} i\frac {d \ket{\psi (t) }} {d t} & = H \ket{\psi (t) } \end{align} $ $ 的目標是要在一段固定時間執行單一的時間演進運算子 $U (t) = e ^ {-iHt} $，其中 $ \ket{\psi (t) } = U (t) \ket{\psi (0) } $t $ 可解決薛丁格方程式。</span><span class="sxs-lookup"><span data-stu-id="a79ee-111">As quantum states in closed systems evolve under the Schrödinger equation $$ \begin{align} i\frac{d \ket{\psi(t)}}{d t} & = H \ket{\psi(t)}, \end{align} $$ the goal is to implement the unitary time-evolution operator $U(t)=e^{-iHt}$ at some fixed time $t$, where $\ket{\psi(t)}=U(t)\ket{\psi(0)}$ solves the Schrödinger equation.</span></span>
<span data-ttu-id="a79ee-112">類似，時間相依的 Hamiltonian 模擬問題可解決相同的方程式，但 $H (t) $ 現在是時間的函式。</span><span class="sxs-lookup"><span data-stu-id="a79ee-112">Analogously, the time-dependent Hamiltonian simulation problem solves the same equation, but with $H(t)$ now a function of time.</span></span>

<span data-ttu-id="a79ee-113">Hamiltonian 模擬是許多其他量子模擬問題的主要元件，而 Hamiltonian 模擬問題的解決方案則是描述一系列基本量子閘道的演算法，可合成將逼近單一 $ \tilde{U} $，並 \\ 在 \tilde{U} 的標準中使用 error $ | \le-U (t) \\ | \epsilon 光譜 $。 [spectral norm](xref:microsoft.quantum.concepts.matrix-advanced)</span><span class="sxs-lookup"><span data-stu-id="a79ee-113">Hamiltonian simulation is a major component of many other quantum simulation problems, and solutions to Hamiltonian simulation problem are algorithms that describes a sequence of primitive quantum gates for synthesizing an approximating unitary $\tilde{U}$ with error $\\|\tilde{U} - U(t)\\| \le \epsilon$ in the [spectral norm](xref:microsoft.quantum.concepts.matrix-advanced).</span></span> <span data-ttu-id="a79ee-114">這些演算法的複雜性非常強烈，因為量子電腦可以存取感興趣的 Hamiltonian 描述。</span><span class="sxs-lookup"><span data-stu-id="a79ee-114">The complexity of these algorithms depend very strongly on how a description of the Hamiltonian of interest is made accessible by a quantum computer.</span></span> <span data-ttu-id="a79ee-115">例如，在最糟的情況下，如果要將 $n $ 量子位上的 $H $ 做為 $ 2 ^ n \times 2 ^ n $ 數位的清單，每個矩陣專案都有一個清單，只要讀取資料已需要指數時間即可。</span><span class="sxs-lookup"><span data-stu-id="a79ee-115">For instance, in the worst-case, if $H$ acting on $n$ qubits were to be provided as a list of $2^n \times 2^n$ numbers, one for each matrix element, simply reading the data would already require exponential time.</span></span> <span data-ttu-id="a79ee-116">在最佳情況下，您可以假設存取 $O \ket{t}\ket{\psi (0) } = \ket{t}U (t) \ket{\psi (0) } $ 完整解決問題的黑箱單一。</span><span class="sxs-lookup"><span data-stu-id="a79ee-116">In the best case, one could assume access to a black-box unitary that $O\ket{t}\ket{\psi(0)}=\ket{t}U(t)\ket{\psi(0)}$ trivially solves the problem.</span></span> <span data-ttu-id="a79ee-117">這兩種輸入模型都不太有趣，前者是因為它不如傳統的方法好用，而後者則是以黑色方塊隱藏其實作為基本閘道的複雜度，這可能是量子位數目的指數。</span><span class="sxs-lookup"><span data-stu-id="a79ee-117">Neither of these input models are particularly interesting -- the former as it is no better than classical approaches, and the latter as the black-box hides the primitive gate complexity of its implementation, which could be exponential in the number of qubits.</span></span>

### <a name="descriptions-of-hamiltonians"></a><span data-ttu-id="a79ee-118">Hamiltonian 的描述</span><span class="sxs-lookup"><span data-stu-id="a79ee-118">Descriptions of Hamiltonians</span></span> ###

<span data-ttu-id="a79ee-119">因此需要輸入格式的其他假設。</span><span class="sxs-lookup"><span data-stu-id="a79ee-119">Additional assumptions of the format of the input are therefore required.</span></span> <span data-ttu-id="a79ee-120">在可充分描述的輸入模型之間必須有足夠的平衡，以包含有趣的 Hamiltonian，例如實際的實體系統或有趣的計算問題，以及足以在量子電腦上有效率地而且實作的輸入模型。</span><span class="sxs-lookup"><span data-stu-id="a79ee-120">A fine balance must be struck between input models that are sufficiently descriptive to encompass interesting Hamiltonians, such as those for realistic physical systems or interesting computational problems, and input models that are sufficiently restrictive to be efficiently implementable on a quantum computer.</span></span> <span data-ttu-id="a79ee-121">在文獻中可以找到各種非一般的輸入模型，其範圍從量子到傳統。</span><span class="sxs-lookup"><span data-stu-id="a79ee-121">A variety of non-trivial input model may be found in the literature, and they range from quantum to classical.</span></span> 

<span data-ttu-id="a79ee-122">作為量子輸入模型的範例，以 [範例為基礎的 Hamiltonian 模擬](http://www.nature.com/articles/s41534-017-0013-7) 會假設以黑色方塊存取產生密度對照表 $ \rho $ 複本的量子作業，這會被視為 Hamiltonian $H $。</span><span class="sxs-lookup"><span data-stu-id="a79ee-122">As examples of quantum input models, [sample-based Hamiltonian simulation](http://www.nature.com/articles/s41534-017-0013-7) assumes black-box access to quantum operations that produce copies of a density matrix $\rho$, which are taken to be the Hamiltonian $H$.</span></span> <span data-ttu-id="a79ee-123">在 [單一存取模型](https://arxiv.org/abs/1202.5822) 中，Hamiltonian 會改為分解為 unitaries $ $ \begin{align} H & = \sum ^ {d-1} \_ {j = 0} a \_ j \hat{U} \_ j、\end{align} $ $ （其中 $a \_ j>$0 為係數）和 $ \hat{U} \_ j $ 為 unitaries。</span><span class="sxs-lookup"><span data-stu-id="a79ee-123">In the [unitary access model](https://arxiv.org/abs/1202.5822) one supposes that the Hamiltonian instead decomposes into a sum of unitaries $$ \begin{align} H & = \sum^{d-1}\_{j=0} a\_j \hat{U}\_j, \end{align} $$ where $a\_j>0$ are coefficients, and $\hat{U}\_j$ are unitaries.</span></span> <span data-ttu-id="a79ee-124">然後，假設一個人可以用黑色方塊存取單一 oracle $V = \sum ^ {d-1} \_ {j = 0} \Ket{j}\bra{j}\otimes \hat{U} \_ j $，以選取所需的 $ \hat{U} \_ j $，和 oracle $A \ket {0} = \sum ^ {d-1} \_ {j = 0} \sqrt{a \_ j/\ sum ^ {d-1} \_ {k = 0} \Alpha \_ j} \ket{j} $，可建立這些係數的量子狀態編碼。</span><span class="sxs-lookup"><span data-stu-id="a79ee-124">It is then assumed that one has black-box access to the unitary oracle $V=\sum^{d-1}\_{j=0}\ket{j}\bra{j}\otimes \hat{U}\_j$ that selects the desired $\hat{U}\_j$, and the oracle $A\ket{0}=\sum^{d-1}\_{j=0}\sqrt{a\_j/\sum^{d-1}\_{k=0}\alpha\_j}\ket{j}$ that create a quantum state encoding these coefficients.</span></span> <span data-ttu-id="a79ee-125">在 [稀疏 Hamiltonian 模擬](https://arxiv.org/abs/quant-ph/0301023)的情況下，會假設 Hamiltonian 是一種疏鬆陣列，而且每個資料列中都只有 $d = \mathcal{O} ( \Text{polylog} (N) # B3 $ 非零的元素。</span><span class="sxs-lookup"><span data-stu-id="a79ee-125">In the case of [sparse Hamiltonian simulation](https://arxiv.org/abs/quant-ph/0301023), one assumes that the Hamiltonian is a sparse matrix with only $d=\mathcal{O}(\text{polylog}(N))$ non-zero element in every row.</span></span> <span data-ttu-id="a79ee-126">此外，也假設有一個有效率的量子電路，可輸出這些非零元素的位置，以及它們的值。</span><span class="sxs-lookup"><span data-stu-id="a79ee-126">Moreover, one assumes the existence of efficient quantum circuits that output the location of these non-zero elements, as well as the their values.</span></span> <span data-ttu-id="a79ee-127">[Hamiltonian 模擬演算法](xref:microsoft.quantum.more-information)的複雜度是以這些黑色方塊的查詢數目來評估，而基本閘道的複雜度則很大，因此非常適合用來執行這些黑色方塊的困難之處。</span><span class="sxs-lookup"><span data-stu-id="a79ee-127">The complexity of [Hamiltonian simulation algorithms](xref:microsoft.quantum.more-information) is evaluated in terms of number of queries to these black-boxes, and the primitive gate complexity then depends very much on the difficulty of implementing these black-boxes.</span></span>

> [!NOTE]
> <span data-ttu-id="a79ee-128">Big-O 標記法通常用來描述演算法的複雜度調整。</span><span class="sxs-lookup"><span data-stu-id="a79ee-128">The big-O notation is commonly used to describe the complexity scaling of algorithms.</span></span> <span data-ttu-id="a79ee-129">假設有兩個實際函式 $f、g $、運算式 $g (x) = \mathcal{O} (f (x) # B6 $ 表示有絕對的正常數 $x \_ 0，c>$0，因此 $g (x) \le c f (x) $ 表示所有 $x \ge x \_ $0。</span><span class="sxs-lookup"><span data-stu-id="a79ee-129">Given two real functions $f,g$, the expression $g(x)=\mathcal{O}(f(x))$ means that there exists an absolute positive constant $x\_0, c>0$ such that $g(x) \le c f(x)$ for all $x\ge x\_0$.</span></span> 

<span data-ttu-id="a79ee-130">在量子電腦上執行的大部分實際應用程式中，這些黑色方塊必須有效率地而且實作，也就是 $ \mathcal{O} ( \text{polylog} (N) # B3 $ 基本量子閘道。</span><span class="sxs-lookup"><span data-stu-id="a79ee-130">In most practical applications to be implemented on a quantum computer, these black-boxes must be efficiently implementable, that is with $\mathcal{O}(\text{polylog}(N))$ primitive quantum gates.</span></span> <span data-ttu-id="a79ee-131">更強、有效率的 simulable Hamiltonian 必須有充分的稀疏傳統描述。</span><span class="sxs-lookup"><span data-stu-id="a79ee-131">More strongly, efficiently simulable Hamiltonians must have some sufficiently sparse classical description.</span></span> <span data-ttu-id="a79ee-132">在這種情況下，假設 Hamiltonian 分解為 Hermitian parts $ $ \begin{align} H & = \sum ^ {d-1} _ {j = 0} H_j 的總和。</span><span class="sxs-lookup"><span data-stu-id="a79ee-132">In one such formulation, it is assumed that the Hamiltonian decomposes into a sum of Hermitian parts $$ \begin{align} H & = \sum^{d-1}_{j=0} H_j.</span></span>
<span data-ttu-id="a79ee-133">\end{align} $ $ 再者，假設每個部分（Hamiltonian $H \_ j $）很容易模擬。</span><span class="sxs-lookup"><span data-stu-id="a79ee-133">\end{align} $$ Moreover, it is assumed that each part, a Hamiltonian $H\_j$, is easy to simulate.</span></span> <span data-ttu-id="a79ee-134">這表示，任何時間 $t $ 的單一 $e ^ {-iH \_ j t} $，都可以使用 $ \mathcal{O} (1) $ 基本量子閘道進行精確的實作為。</span><span class="sxs-lookup"><span data-stu-id="a79ee-134">This means that the unitary $e^{-iH\_j t}$ for any time $t$ may be implemented exactly using $\mathcal{O}(1)$ primitive quantum gates.</span></span> <span data-ttu-id="a79ee-135">比方說，在特殊情況下，這種情況是成立的，其中每個 $H \_ j $ 都是本機 Pauli 運算子，也就是說，它們屬於 $ \mathcal{O} (1) $ 非身分識別 Pauli 運算子的 tensor 產品，其會在空間關閉量子位時採取行動。</span><span class="sxs-lookup"><span data-stu-id="a79ee-135">For instance, this is true in the special case where each $H\_j$ are local Pauli operators, meaning that they are of tensor products of $\mathcal{O}(1)$ non-identity Pauli operators that act on spatially close qubits.</span></span> <span data-ttu-id="a79ee-136">此模型特別適用于具有系結和本機互動的實體系統，因為詞彙數目 $d = \mathcal{O} ( \text{polylog} (N) # B3 $，而且可能會在多項式時間清楚地寫下（即傳統方式所述）。</span><span class="sxs-lookup"><span data-stu-id="a79ee-136">This model is particularly applicable to physical systems with bounded and local interaction, as the number of terms is $d=\mathcal{O}(\text{polylog}(N))$, and may clearly be written down, i.e. classically described, in polynomial time.</span></span>

> [!TIP]
> <span data-ttu-id="a79ee-137">您可以使用 Dynamical 產生器表示程式庫，來描述分解為部分的總和的 hamiltonian。</span><span class="sxs-lookup"><span data-stu-id="a79ee-137">Hamiltonians that decompose into a sum of parts may be described using the Dynamical Generator Representation library.</span></span> <span data-ttu-id="a79ee-138">如需詳細資訊，請參閱 [資料結構](xref:microsoft.quantum.libraries.data-structures)中的 Dynamical 產生器標記法一節。</span><span class="sxs-lookup"><span data-stu-id="a79ee-138">For more information, see the Dynamical Generator Representation section in [data structures](xref:microsoft.quantum.libraries.data-structures).</span></span>

### <a name="simulation-algorithms"></a><span data-ttu-id="a79ee-139">模擬演算法</span><span class="sxs-lookup"><span data-stu-id="a79ee-139">Simulation Algorithms</span></span> ###

<span data-ttu-id="a79ee-140">量子模擬演算法會將 Hamiltonian 的指定描述轉換成一系列的基本量子閘道，這是指 Hamiltonian 所說的整體大約時間演進。</span><span class="sxs-lookup"><span data-stu-id="a79ee-140">A quantum simulation algorithm converts a given description of a Hamiltonian into a sequence of primitive quantum gates that, as a whole, approximate time-evolution by said Hamiltonian.</span></span>

<span data-ttu-id="a79ee-141">在 Hamiltonian 分解為 Hermitian 元件總和的特殊情況下，Trotter-Suzuki 分解是一個特別簡單且直覺的演算法，用來模擬 Hamiltonian，以分解成 Hermitian 元件的總和。</span><span class="sxs-lookup"><span data-stu-id="a79ee-141">In the special case where the Hamiltonian decomposes into a sum of Hermitian parts, the Trotter-Suzuki decomposition is a particularly simple and intuitive algorithm for simulating Hamiltonians that decompose into a sum of Hermitian components.</span></span> <span data-ttu-id="a79ee-142">比方說，這個系列的第一個訂單整合者近似 $ $ \begin{align} U (t) & = \left ( e ^ {-iH \_ 0 t/r} e ^ {-iH \_ 1 t/r} \cdots e ^ {-iH \_ {d-1} t/r} \right) ^ {r} + \mathcal{O} (d ^ 2 \ max_j \\ |H \_ j \\ | ^ 2 t ^ 2/r) ，使用 $r d $ 詞彙的產品 \end{align} $ $。</span><span class="sxs-lookup"><span data-stu-id="a79ee-142">For instance, a first-order integrator of this family approximates $$ \begin{align} U(t) & = \left( e^{-iH\_0 t / r} e^{-iH\_1 t / r} \cdots e^{-iH\_{d-1} t / r} \right)^{r} + \mathcal{O}(d^2 \max_j\\|H\_j\\|^2 t^2/r), \end{align} $$ using a product of $r d$ terms.</span></span> 

> [!TIP]
> <span data-ttu-id="a79ee-143">範例中涵蓋了 Trotter Suzuki 模擬演算法的應用程式。</span><span class="sxs-lookup"><span data-stu-id="a79ee-143">Applications of the Trotter-Suzuki simulation algorithm are covered in the samples.</span></span>
> <span data-ttu-id="a79ee-144">針對 Ising 模型，只使用每部目的電腦提供的內部作業，請參閱[ **SimpleIsing**範例](https://github.com/microsoft/Quantum/blob/main/samples/simulation/ising/simple)。</span><span class="sxs-lookup"><span data-stu-id="a79ee-144">For the Ising model using only the intrinsic operations provided by each target machine, please see the [**SimpleIsing** sample](https://github.com/microsoft/Quantum/blob/main/samples/simulation/ising/simple).</span></span>
> <span data-ttu-id="a79ee-145">如需使用 Trotter Suzuki 程式庫控制結構的 Ising 模型，請參閱[ **IsingTrotter**範例](https://github.com/microsoft/Quantum/tree/main/samples/simulation/ising/trotter-evolution)。</span><span class="sxs-lookup"><span data-stu-id="a79ee-145">For the Ising model using the Trotter-Suzuki library control structure, please see the [**IsingTrotter** sample](https://github.com/microsoft/Quantum/tree/main/samples/simulation/ising/trotter-evolution).</span></span>
> <span data-ttu-id="a79ee-146">如需使用 Trotter Suzuki 程式庫控制結構的分子 Hydrogen，請參閱[ **H2 模擬**範例](https://github.com/microsoft/Quantum/tree/main/samples/simulation/h2/command-line)。</span><span class="sxs-lookup"><span data-stu-id="a79ee-146">For molecular Hydrogen using the Trotter-Suzuki library control structure, please see the [**H2 simulation** sample](https://github.com/microsoft/Quantum/tree/main/samples/simulation/h2/command-line).</span></span>

<span data-ttu-id="a79ee-147">在許多情況下，我們想要執行模擬演算法，但對其執行的細節不感興趣。</span><span class="sxs-lookup"><span data-stu-id="a79ee-147">In many cases, we would like to implement the simulation algorithm, but are not interested in the details of its implementation.</span></span> <span data-ttu-id="a79ee-148">例如，第二個訂單的整合者近似 $ $ \begin{align} U (t) & = \left ( e ^ {-iH \_ 0 t/2r} e ^ {-iH \_ 1 t/2r} \cdots e ^ {-iH \_ {d-1} t/2r} e ^ {-iH \_ {d-1} t/2r} \cdots e ^ {-iH \_ 1 t/2r} e ^ {-iH \_ 0 t/2r} \right) ^ {r} + \mathcal{O} (d ^ 3 \ max_j \\ |H \_ j \\ | ^ 3 t ^ 3/r ^ 2) ，\end{align} $ $ （使用 $ 2rd $ 詞彙的產品）。</span><span class="sxs-lookup"><span data-stu-id="a79ee-148">For instance, the second-order integrator approximates $$ \begin{align} U(t) & = \left( e^{-iH\_0 t / 2r} e^{-iH\_1 t / 2r} \cdots e^{-iH\_{d-1} t / 2r} e^{-iH\_{d-1} t / 2r}  \cdots e^{-iH\_1 t / 2r} e^{-iH\_0 t / 2r} \right)^{r} + \mathcal{O}(d^3 \max_j\\|H\_j\\|^3 t^3/r^2), \end{align} $$ using a product of $2rd$ terms.</span></span> <span data-ttu-id="a79ee-149">較大的訂單會牽涉到更多的詞彙，而優化的變異可能需要指數的高度非一般排序。</span><span class="sxs-lookup"><span data-stu-id="a79ee-149">Larger orders will involve even more terms and optimized variants may require highly non-trivial orderings on the exponentials.</span></span> <span data-ttu-id="a79ee-150">其他先進的演算法也可能牽涉到在中繼步驟中使用 ancilla 量子位。</span><span class="sxs-lookup"><span data-stu-id="a79ee-150">Other advanced algorithms may also involve the use of ancilla qubits in intermediate steps.</span></span> <span data-ttu-id="a79ee-151">因此，我們會將模擬演算法封裝在 canon 中做為使用者定義型別</span><span class="sxs-lookup"><span data-stu-id="a79ee-151">Thus we package simulation algorithms in the canon as the user-defined type</span></span>

```qsharp
newtype SimulationAlgorithm = ((Double, EvolutionGenerator, Qubit[]) => Unit is Adj + Ctl);
```

<span data-ttu-id="a79ee-152">第一個參數 `Double` 是模擬的時間，第二個參數是 `EvolutionGenerator` 在 [資料結構](xref:microsoft.quantum.libraries.data-structures)的「Dynamical 產生器表示」區段中，是與時間無關 Hamiltonian 封裝的傳統描述，其中包含有關 Hamiltonian 中每個詞彙如何由量子電路模擬的指示。</span><span class="sxs-lookup"><span data-stu-id="a79ee-152">The first parameter `Double` is the time of simulation, the second parameter `EvolutionGenerator`, covered in the Dynamical Generator Representation section of [data-structures](xref:microsoft.quantum.libraries.data-structures), is a classical description of a time-independent Hamiltonian packaged with instructions on how each term in the Hamiltonian may be simulated by a quantum circuit.</span></span> <span data-ttu-id="a79ee-153">這種形式的類型近似于單一作業 $e ^ {-iHt} $ on 第三個參數 `Qubit[]` ，也就是儲存模擬系統之量子狀態的註冊。</span><span class="sxs-lookup"><span data-stu-id="a79ee-153">Types of this form approximate the unitary operation $e^{-iHt}$ on the third parameter `Qubit[]`, which is the register storing the quantum state of the simulated system.</span></span> <span data-ttu-id="a79ee-154">同樣地，在時間相依的情況下，我們會以類型來定義使用者定義型別 `EvolutionSchedule` ，而這是時間相依 Hamiltonian 的傳統描述。</span><span class="sxs-lookup"><span data-stu-id="a79ee-154">Similarly for the time-dependent case, we define a user-defined type with an `EvolutionSchedule` type instead, which is a classical description of a time-dependent Hamiltonian.</span></span>

```qsharp
newtype TimeDependentSimulationAlgorithm = ((Double, EvolutionSchedule, Qubit[]) => Unit : Adjoint, Controlled);
```

<span data-ttu-id="a79ee-155">例如，您可以使用下列 canon 函式來呼叫 Trotter Suzuki 分解，並以參數 `trotterStepSize` 修改每個指數中的模擬持續時間，以及所 `trotterOrder` 需的整合程式順序。</span><span class="sxs-lookup"><span data-stu-id="a79ee-155">As an example, the Trotter-Suzuki decomposition may be called using the following canon functions, with parameters `trotterStepSize` modifying the duration of simulation in each exponential, and `trotterOrder` for the order of the desired integrator.</span></span>

```qsharp
function TrotterSimulationAlgorithm(
    trotterStepSize : Double, 
    trotterOrder : Int) 
: SimulationAlgorithm {
    ...
}

function TimeDependentTrotterSimulationAlgorithm(
    trotterStepSize : Double, 
    trotterOrder : Int) 
: TimeDependentSimulationAlgorithm {
    ...
}
```

> [!TIP]
> <span data-ttu-id="a79ee-156">範例中涵蓋模擬程式庫的應用程式。</span><span class="sxs-lookup"><span data-stu-id="a79ee-156">Applications of the simulation library are covered in the samples.</span></span> <span data-ttu-id="a79ee-157">如需使用 Ising 模型中的階段估計 `SimulationAlgorithm` ，請參閱[ **IsingPhaseEstimation**範例](https://github.com/microsoft/Quantum/tree/main/samples/simulation/ising/phase-estimation)。</span><span class="sxs-lookup"><span data-stu-id="a79ee-157">For phase estimation in the Ising model using `SimulationAlgorithm`, please see the [**IsingPhaseEstimation** sample](https://github.com/microsoft/Quantum/tree/main/samples/simulation/ising/phase-estimation).</span></span>
> <span data-ttu-id="a79ee-158">如需使用 Ising 模型中的 adiabatic 狀態準備 `TimeDependentSimulationAlgorithm` ，請參閱[ **AdiabaticIsing**範例](https://github.com/microsoft/Quantum/tree/main/samples/simulation/ising/adiabatic)。</span><span class="sxs-lookup"><span data-stu-id="a79ee-158">For adiabatic state preparation in the Ising model using `TimeDependentSimulationAlgorithm`, please see the [**AdiabaticIsing** sample](https://github.com/microsoft/Quantum/tree/main/samples/simulation/ising/adiabatic).</span></span>


### <a name="adiabatic-state-preparation--phase-estimation"></a><span data-ttu-id="a79ee-159">Adiabatic 狀態準備 & 階段估計</span><span class="sxs-lookup"><span data-stu-id="a79ee-159">Adiabatic State Preparation & Phase Estimation</span></span> ###

<span data-ttu-id="a79ee-160">Hamiltonian 模擬的一個常見應用是 adiabatic 狀態準備。</span><span class="sxs-lookup"><span data-stu-id="a79ee-160">One common application of Hamiltonian simulation is adiabatic state preparation.</span></span> <span data-ttu-id="a79ee-161">在這裡，有一個提供兩個 Hamiltonian $H \_ {\text{start}} $ 和 $H \_ {\text{end}} $，而量子 state $ \ket{\psi (0) } $ 是開始 Hamiltonian $H \_ {\text{start}} $ 的基礎狀態。</span><span class="sxs-lookup"><span data-stu-id="a79ee-161">Here, one is provided with two Hamiltonians $H\_{\text{start}}$ and $H\_{\text{end}}$, and a quantum state $\ket{\psi(0)}$ that is a ground state of the start Hamiltonian $H\_{\text{start}}$.</span></span> <span data-ttu-id="a79ee-162">通常 \_ 會選擇 $H {\text{start}} $，讓 $ \ket{\psi (0) } $ 很容易從計算基礎狀態 $ \ket{0\cdots 0} $ 進行準備。</span><span class="sxs-lookup"><span data-stu-id="a79ee-162">Typically, $H\_{\text{start}}$ is chosen such that $\ket{\psi(0)}$ is easy to prepare from a computational basis state $\ket{0\cdots 0}$.</span></span> <span data-ttu-id="a79ee-163">藉由在與時間相依的模擬問題之間進行插即插 Hamiltonian，可讓您在最終 Hamiltonian $H {\text{end}} $ 的基礎狀態下，得到很高的機率 \_ 。</span><span class="sxs-lookup"><span data-stu-id="a79ee-163">By interpolating between these Hamiltonians in the time-dependent simulation problem sufficiently slowly, it is possible to end up, with high probability, in a ground state of the final Hamiltonian $H\_{\text{end}}$.</span></span> <span data-ttu-id="a79ee-164">雖然準備良好的 Hamiltonian 地面狀態，還是可以透過這種方式來進行，方法是在與時間相依的 Hamiltonian 模擬演算法上呼叫做為副程式，其他概念上不同的方法（例如 variational 量子 eigensolver）也是可行的。</span><span class="sxs-lookup"><span data-stu-id="a79ee-164">Though preparing good approximations to Hamiltonian ground states could proceed in this manner by calling upon on time-dependent Hamiltonian simulation algorithms as a subroutine, other conceptually different approaches such as the variational quantum eigensolver are possible.</span></span>

<span data-ttu-id="a79ee-165">但量子化學中的另一個應用程式，是估計 Hamiltonian 的地面狀態能源，代表化學反應的中繼步驟。</span><span class="sxs-lookup"><span data-stu-id="a79ee-165">Yet another application ubiquitous in quantum chemistry is estimating the ground state energy of Hamiltonians representing the intermediate steps of chemical reaction.</span></span> <span data-ttu-id="a79ee-166">例如，這種配置可以依賴 adiabatic 狀態準備來建立地面狀態，然後將時間獨立的 Hamiltonian 模擬納入階段估計的特性，以將這項能源與部分有限的錯誤和成功機率進行解壓縮。</span><span class="sxs-lookup"><span data-stu-id="a79ee-166">Such a scheme could, for instance, rely on adiabatic state preparation to create the ground state, and then incorporate time-independent Hamiltonian simulation as a subroutine in phase estimation characterization to extract this energy with some finite error and probability of success.</span></span> 

<span data-ttu-id="a79ee-167">將模擬演算法抽象化為使用者定義型別 `SimulationAlgorithm` ，並 `TimeDependentSimulationAlgorithm` 讓我們能夠方便地將其功能納入更複雜的量子演算法。</span><span class="sxs-lookup"><span data-stu-id="a79ee-167">Abstracting simulation algorithms as the user-defined types `SimulationAlgorithm` and `TimeDependentSimulationAlgorithm` allow us to conveniently incorporate their functionality into more sophisticated quantum algorithms.</span></span> <span data-ttu-id="a79ee-168">這應採用我們針對這些常用的副程式進行相同的動作。</span><span class="sxs-lookup"><span data-stu-id="a79ee-168">This motivates us to do the same for these commonly used subroutines.</span></span>

<span data-ttu-id="a79ee-169">因此，我們定義了方便的函式</span><span class="sxs-lookup"><span data-stu-id="a79ee-169">Thus we define the convenient function</span></span>

```qsharp
function InterpolatedEvolution(
        interpolationTime : Double, 
        evolutionGeneratorStart : EvolutionGenerator,
        evolutionGeneratorEnd : EvolutionGenerator,
        timeDependentSimulationAlgorithm : TimeDependentSimulationAlgorithm)
: (Qubit[] => Unit is Adj + Ctl) {
        ...
}
 
```

<span data-ttu-id="a79ee-170">這會傳回單一作業，以實行 adiabatic 狀態準備的所有步驟。</span><span class="sxs-lookup"><span data-stu-id="a79ee-170">This returns a unitary operation that implements all steps of adiabatic state preparation.</span></span> <span data-ttu-id="a79ee-171">第一個參數會定義在這段時間，我們會在 `interpolatedTime` 第二個參數所描述的開始 Hamiltonian `evolutionGeneratorStart` 和第三個參數所描述的 end Hamiltonian 之間，以線性方式插補 `evolutionGeneratorEnd` 。</span><span class="sxs-lookup"><span data-stu-id="a79ee-171">The first parameter `interpolatedTime` defines the time over which we linearly interpolate between the start Hamiltonian described by the second parameter `evolutionGeneratorStart` and the end Hamiltonian described by the third parameter `evolutionGeneratorEnd`.</span></span> <span data-ttu-id="a79ee-172">第四個參數 `timeDependentSimulationAlgorithm` 是可選擇模擬演算法的參數。</span><span class="sxs-lookup"><span data-stu-id="a79ee-172">The fourth parameter `timeDependentSimulationAlgorithm` is where one makes the choice of simulation algorithm.</span></span> <span data-ttu-id="a79ee-173">請注意，如果 `interpolatedTime` 夠長，則初始的接地狀態會在時間相依模擬的整個持續期間維持 Hamiltonian 的瞬間狀態，因而結束于結束 Hamiltonian 的接地狀態。</span><span class="sxs-lookup"><span data-stu-id="a79ee-173">Note that if `interpolatedTime` is long enough, an initial ground state remains an instantaneous ground state of the Hamiltonian over the entire duration of time-dependent simulation, and thus ends in the ground state of the end Hamiltonian.</span></span>

<span data-ttu-id="a79ee-174">我們也會定義一個實用的作業，以自動執行一般量子化學實驗的所有步驟。</span><span class="sxs-lookup"><span data-stu-id="a79ee-174">We also define a helpful operation that automatically performs all steps of a typical quantum chemistry experiment.</span></span> <span data-ttu-id="a79ee-175">比方說，我們有下列各項，這會傳回 adiabatic 狀態準備所產生之狀態的能源預估：</span><span class="sxs-lookup"><span data-stu-id="a79ee-175">For instance we have the following, which returns an energy estimate of the state produced by adiabatic state preparation:</span></span>

```qsharp
operation EstimateAdiabaticStateEnergy(
    nQubits : Int,
    statePrepUnitary : (Qubit[] => Unit),
    adiabaticUnitary : (Qubit[] => Unit),
    qpeUnitary: (Qubit[] => Unit is Adj + Ctl),
    phaseEstAlgorithm : ((DiscreteOracle, Qubit[]) => Double))
: Double {
...
}
```

<span data-ttu-id="a79ee-176">`nQubits` 這是用來編碼初始量子狀態的量子位數目。</span><span class="sxs-lookup"><span data-stu-id="a79ee-176">`nQubits` is the number of qubits used to encode the initial quantum state.</span></span> <span data-ttu-id="a79ee-177">`statePrepUnitary` 從計算基礎 $ \ket{0\cdots 0} $ 準備開始狀態。</span><span class="sxs-lookup"><span data-stu-id="a79ee-177">`statePrepUnitary` prepares the start state from the computational basis $\ket{0\cdots 0}$.</span></span> <span data-ttu-id="a79ee-178">`adiabaticUnitary` 是實 adiabatic 狀態準備的單一作業，例如函數所產生的  `InterpolatedEvolution` 。</span><span class="sxs-lookup"><span data-stu-id="a79ee-178">`adiabaticUnitary` is the unitary operation that implements adiabatic state preparation, such as produced by the  `InterpolatedEvolution` function.</span></span> <span data-ttu-id="a79ee-179">`qpeUnitary` 這是用來對產生的量子狀態執行階段估計的單一作業。</span><span class="sxs-lookup"><span data-stu-id="a79ee-179">`qpeUnitary` is the unitary operation that is used to perform phase estimation on the resulting quantum state.</span></span> <span data-ttu-id="a79ee-180">`phaseEstAlgorithm` 是我們選擇的階段估計演算法。</span><span class="sxs-lookup"><span data-stu-id="a79ee-180">`phaseEstAlgorithm` is our choice of phase estimation algorithm.</span></span>

> [!TIP]
> <span data-ttu-id="a79ee-181">範例中涵蓋 adiabatic 狀態準備的應用程式。</span><span class="sxs-lookup"><span data-stu-id="a79ee-181">Applications of adiabatic state preparation are covered in the samples.</span></span> <span data-ttu-id="a79ee-182">針對使用手動執行 adiabatic 狀態準備和使用函式的 Ising 模型 `AdiabaticEvolution` ，請參閱[ **AdiabaticIsing**範例](https://github.com/microsoft/Quantum/tree/main/samples/simulation/ising/adiabatic)。</span><span class="sxs-lookup"><span data-stu-id="a79ee-182">For the Ising model using a manual implementation of adiabatic state preparation versus using the `AdiabaticEvolution` function, please see the [**AdiabaticIsing** sample](https://github.com/microsoft/Quantum/tree/main/samples/simulation/ising/adiabatic).</span></span>
> <span data-ttu-id="a79ee-183">如需 Ising 模型中的階段估計和 adiabatic 狀態準備，請參閱[ **IsingPhaseEstimation**範例](https://github.com/microsoft/Quantum/tree/main/samples/simulation/ising/phase-estimation)。</span><span class="sxs-lookup"><span data-stu-id="a79ee-183">For phase estimation and adiabatic state preparation in the Ising model, please see the [**IsingPhaseEstimation** sample](https://github.com/microsoft/Quantum/tree/main/samples/simulation/ising/phase-estimation).</span></span>

> [!TIP]
> <span data-ttu-id="a79ee-184">[分子 Hydrogen 的模擬](https://github.com/microsoft/Quantum/tree/main/samples/simulation/h2/command-line)是有趣且簡短的範例。</span><span class="sxs-lookup"><span data-stu-id="a79ee-184">The [simulation of molecular Hydrogen](https://github.com/microsoft/Quantum/tree/main/samples/simulation/h2/command-line) is an interesting and brief sample.</span></span> <span data-ttu-id="a79ee-185">[O'Malley](https://arxiv.org/abs/1512.06860)中所報告的模型和實驗性結果。</span><span class="sxs-lookup"><span data-stu-id="a79ee-185">The model and experimental results reported in [O'Malley et. al.](https://arxiv.org/abs/1512.06860)</span></span> <span data-ttu-id="a79ee-186">只需要 Pauli 矩陣，並採用表單 $ \hat H = g \_ {0} I \_ 0I \_ 1 + g \_ 1 {z \_ 0} + g \_ 2 {Z \_ 1} + g \_ 3 {z \_ 0} {z 1} + g \_ \_ 4 {y 0} { \_ Y 1} \_ + g \_ 5 {x \_ 0} {X \_ 1} $。</span><span class="sxs-lookup"><span data-stu-id="a79ee-186">only requires Pauli matrices and takes the form $\hat H = g\_{0}I\_0I\_1+g\_1{Z\_0}+g\_2{Z\_1}+g\_3{Z\_0}{Z\_1}+g\_4{Y\_0}{Y\_1}+g\_5{X\_0}{X\_1}$.</span></span> <span data-ttu-id="a79ee-187">這是有效的 Hamiltonian，只需要2個量子位，其中 $g $ 的常數會從兩個 Hydrogen 原子之間的距離 $R $ 計算。</span><span class="sxs-lookup"><span data-stu-id="a79ee-187">This is an effective Hamiltonian only requiring only 2 qubits, where the constants $g$ are computed from the distance $R$ between the two Hydrogen atoms.</span></span> <span data-ttu-id="a79ee-188">使用 canon 函式，Paulis 會轉換成 unitaries，然後使用 Trotter-Suzuki 分解在短時間內演進。</span><span class="sxs-lookup"><span data-stu-id="a79ee-188">Using canon functions, the Paulis are converted to unitaries and then evolved over short periods of time using the Trotter-Suzuki decomposition.</span></span> <span data-ttu-id="a79ee-189">在不使用 adiabatic 狀態準備的情況下，您可以建立 $H _2 $ 地面狀態的良好近似值，因此可以直接藉由利用 canon 的階段估計來找到地面狀態能源。</span><span class="sxs-lookup"><span data-stu-id="a79ee-189">A good approximation to the $H_2$ ground state can be created without using adiabatic state preparation, and so the ground state energy may be found directly by utilizing phase estimation from the canon.</span></span>

## <a name="shors-algorithm"></a><span data-ttu-id="a79ee-190">秀爾演算法</span><span class="sxs-lookup"><span data-stu-id="a79ee-190">Shor's Algorithm</span></span> ##
<span data-ttu-id="a79ee-191">Shor 的演算法仍是量子運算中最重要的一項發展，因為它展示了量子電腦可用來解決重要的問題，目前傳統方式棘手的問題。</span><span class="sxs-lookup"><span data-stu-id="a79ee-191">Shor's algorithm remains one of the most significant developments in quantum computing because it showed that quantum computers could be used to solve important, currently classically intractable problems.</span></span>
<span data-ttu-id="a79ee-192">Shor 的演算法提供快速的方式，讓您使用量子電腦來將大型數位納入考慮，這是一種稱為「 *分解*」的問題。</span><span class="sxs-lookup"><span data-stu-id="a79ee-192">Shor's algorithm provides a fast way to factor large numbers using a quantum computer, a problem called *factoring*.</span></span>
<span data-ttu-id="a79ee-193">許多當日 cryptosystems 的安全性是根據假設沒有快速演算法可進行分解。</span><span class="sxs-lookup"><span data-stu-id="a79ee-193">The security of many present-day cryptosystems is based on the assumption that no fast algorithm exists for factoring.</span></span>
<span data-ttu-id="a79ee-194">因此，Shor 的演算法對於我們在量子後世界中的安全性考慮有深遠的影響。</span><span class="sxs-lookup"><span data-stu-id="a79ee-194">Thus Shor's algorithm has had a profound impact on how we think about security in a post-quantum world.</span></span>

<span data-ttu-id="a79ee-195">Shor 的演算法可視為混合式演算法。</span><span class="sxs-lookup"><span data-stu-id="a79ee-195">Shor's algorithm can be thought of as a hybrid algorithm.</span></span>
<span data-ttu-id="a79ee-196">量子電腦是用來執行稱為「期間尋找」的計算困難工作。</span><span class="sxs-lookup"><span data-stu-id="a79ee-196">The quantum computer is used to perform a computationally hard task known as period finding.</span></span>
<span data-ttu-id="a79ee-197">然後會傳統方式處理期間尋找的結果，以估計因素。</span><span class="sxs-lookup"><span data-stu-id="a79ee-197">The results from period finding are then classically processed to estimate the factors.</span></span>
<span data-ttu-id="a79ee-198">我們將在下面兩個步驟中複習。</span><span class="sxs-lookup"><span data-stu-id="a79ee-198">We review these two steps below.</span></span>

### <a name="period-finding"></a><span data-ttu-id="a79ee-199">期間尋找</span><span class="sxs-lookup"><span data-stu-id="a79ee-199">Period Finding</span></span> ###

<span data-ttu-id="a79ee-200">瞭解量子傅立葉轉換和階段估計的運作方式 (查看 [量子演算法](xref:microsoft.quantum.libraries.standard.algorithms)) ，我們可以使用這些工具來解決傳統方式的硬運算問題，稱為「 *期間尋找*」。</span><span class="sxs-lookup"><span data-stu-id="a79ee-200">Having seen how the quantum Fourier transform and phase estimation work (see [Quantum algorithms](xref:microsoft.quantum.libraries.standard.algorithms)), we can use these tools to solve a classically hard computational problem called *period finding*.</span></span>  <span data-ttu-id="a79ee-201">在下一節中，我們將瞭解如何套用期間尋找以進行分解。</span><span class="sxs-lookup"><span data-stu-id="a79ee-201">In the next section, we will see how to apply period finding to factoring.</span></span>

<span data-ttu-id="a79ee-202">假設有兩個整數 $a $ 和 $N $，其中 $a<N $，則期間尋找的目標（也稱為訂單尋找）是尋找 _order_ $r $ of $a $ 模數 $N $，其中 $r $ 會定義為最小的正整數，例如 $a ^ r \equiv 1 \text{Mod} N $。</span><span class="sxs-lookup"><span data-stu-id="a79ee-202">Given two integers $a$ and $N$, where $a<N$, the goal of period finding, also called order finding, is to find the _order_ $r$ of $a$ modulo $N$, where $r$ is defined to be the least positive integer such that $a^r \equiv 1 \text{ mod } N$.</span></span>  

<span data-ttu-id="a79ee-203">若要使用量子電腦來尋找訂單，我們可以使用適用于下列單一運算子的階段估計演算法 $U _a $： $ $ U_a \ket{x} \equiv \ket{ (ax) \text{mod} N}。 $ $ 特徵向量 $U _a $ 適用于 integer $s $ 和 $ 0 \ leq s \leq r-$1，$ $ \ket{x_s} \equiv 1/\sqrt{r} \sum \_ {k = 0} ^ {r-1} e ^ {\frac{-2\pi i sk} {r}} \ket{a ^ k\text {mod} N}，$ $ 是 _eigenstates_ of $U _a $。</span><span class="sxs-lookup"><span data-stu-id="a79ee-203">To find the order using a quantum computer, we can use the phase estimation algorithm applied to the following unitary operator $U_a$: $$ U_a\ket{x} \equiv \ket{(ax)\text{ mod }N} .$$ The eigenvectors of $U_a$ are for integer $s$ and $0\leq s \leq r - 1$, $$\ket{x_s} \equiv 1 / \sqrt{r} \sum\_{k=0}^{r-1} e^{\frac{-2\pi i sk}{r}} \ket{a^k\text{ mod }N},$$ are _eigenstates_ of $U_a$.</span></span>
<span data-ttu-id="a79ee-204">$U _a $ 的特徵值為 $ $ U \_ a \ket{x \_ s} = e ^ {2 \ pi i s/r} \ket{x \_ s}。</span><span class="sxs-lookup"><span data-stu-id="a79ee-204">The eigenvalues of $U_a$ are $$ U\_a \ket{x\_s} = e^{2\pi i s / r} \ket{x\_s} .</span></span> $$

<span data-ttu-id="a79ee-205">因此，階段估計會輸出特徵值 $e ^ {2 \ pi i s/r} $，$r $ 可使用 $s/r $ 的 [接續分數](https://en.wikipedia.org/wiki/Continued_fraction) 有效率地學習。</span><span class="sxs-lookup"><span data-stu-id="a79ee-205">Phase estimation thus outputs the eigenvalues $e^{2\pi i s / r}$ from which $r$ can be learned efficiently using [continued fractions](https://en.wikipedia.org/wiki/Continued_fraction) from $s / r$.</span></span>

<span data-ttu-id="a79ee-206">量子期間尋找的電路圖為：</span><span class="sxs-lookup"><span data-stu-id="a79ee-206">The circuit diagram for quantum period finding is:</span></span>

![量子期間尋找的電路圖](~/media/QPE.svg)

<span data-ttu-id="a79ee-208">這裡 $ 2n $ 量子位會初始化為 $ \ket {0} $，$n $ 量子位會初始化為 $ \ket {1} $。</span><span class="sxs-lookup"><span data-stu-id="a79ee-208">Here $2n$ qubits are initialized to $\ket{0}$ and $n$ qubits are initialized to $\ket{1}$.</span></span>
<span data-ttu-id="a79ee-209">讀者可能會想知道為何將 eigenstates 的量子暫存器初始化為 $ \ket {1} $。</span><span class="sxs-lookup"><span data-stu-id="a79ee-209">The reader again may wonder why the quantum register to hold the eigenstates is initialized to $\ket{1}$.</span></span>
<span data-ttu-id="a79ee-210">因為您事先不知道 order $r $，所以我們實際上無法直接準備 $ \ket{x_s} $ 狀態。</span><span class="sxs-lookup"><span data-stu-id="a79ee-210">As one does not know the order $r$ in advance, we cannot actually prepare $\ket{x_s}$ states directly.</span></span>
<span data-ttu-id="a79ee-211">幸運的是，$ 1/\ sqrt {r} \sum \_ {s = 0} ^ {r-1} \ket{x \_ s} = \ket {1} $。</span><span class="sxs-lookup"><span data-stu-id="a79ee-211">Luckily, it turns out that $1/\sqrt{r} \sum\_{s=0}^{r-1} \ket{x\_s} = \ket{1}$.</span></span>
<span data-ttu-id="a79ee-212">我們不需要實際準備 $ \ket{x} $！</span><span class="sxs-lookup"><span data-stu-id="a79ee-212">We don't need to actually prepare $\ket{x}$!</span></span>
<span data-ttu-id="a79ee-213">我們可以準備在 state $ \ket $ 中 $n $ 量子位的量子暫存器 {1} 。</span><span class="sxs-lookup"><span data-stu-id="a79ee-213">We can just prepare a quantum register of $n$ qubits in state $\ket{1}$.</span></span> 

<span data-ttu-id="a79ee-214">線路包含 QFT 和數個控制的閘道。</span><span class="sxs-lookup"><span data-stu-id="a79ee-214">The circuit contains the QFT and several controlled gates.</span></span>
<span data-ttu-id="a79ee-215">[先前](xref:microsoft.quantum.libraries.standard.algorithms)已說明過 QFT 閘道。</span><span class="sxs-lookup"><span data-stu-id="a79ee-215">The QFT gate has been described [previously](xref:microsoft.quantum.libraries.standard.algorithms).</span></span>
<span data-ttu-id="a79ee-216">如果控制項量子位為 $ \ket $，受控制的 $U _a $ 閘道會將 $ \ket{x} $ 對應到 $ \ket{ (ax) \text{mod} N} $ {1} ，否則會將 $ \ket{x} $ 對應到 $ \ket{x} $。</span><span class="sxs-lookup"><span data-stu-id="a79ee-216">The controlled-$U_a$ gate maps $\ket{x}$ to $\ket{(ax)\text{ mod } N}$ if the control qubit is $\ket{1}$, and maps $\ket{x}$ to $\ket{x}$ otherwise.</span></span>

<span data-ttu-id="a79ee-217">為了達到 $ (a ^ nx) \text{mod} N $，我們可以直接套用受控制的 $U _ {a ^ n} $，我們會在其中計算 $a ^ n \text{mod} N $ 傳統方式，以插入量子電路。</span><span class="sxs-lookup"><span data-stu-id="a79ee-217">To achieve $(a^nx)\text{ mod } N$,  we can simply apply controlled-$U_{a^n}$, where we calculate $a^n \text{ mod } N$ classically to plug into the quantum circuit.</span></span>  
<span data-ttu-id="a79ee-218">[量子算術檔](./algorithms.md#arithmetic)中已描述達成這類別模組化算術的線路，尤其我們需要模組乘冪電路來實行受控制的 $U \_ {a ^ i} $ 作業。</span><span class="sxs-lookup"><span data-stu-id="a79ee-218">The circuits to achieve such modular arithmetic have been described in the [quantum arithmetic documentation](./algorithms.md#arithmetic), specifically we require a modular exponentiation circuit to implement the controlled-$U\_{a^i}$ operations.</span></span>

<span data-ttu-id="a79ee-219">雖然上述電路對應至 [量子階段估計](xref:microsoft.quantum.characterization.quantumphaseestimation) ，並明確地啟用訂單尋找，但我們可以減少所需的量子位數目。</span><span class="sxs-lookup"><span data-stu-id="a79ee-219">While the circuit above corresponds to [Quantum Phase Estimation](xref:microsoft.quantum.characterization.quantumphaseestimation) and explicitly enables order finding, we can reduce the number of qubits required.</span></span> <span data-ttu-id="a79ee-220">我們可以依照 [arXiv： quant 的第8頁](https://arxiv.org/pdf/quant-ph/0205095v3.pdf#page=8)所述的順序尋找 Beauregard 的方法，或使用位於 Microsoft 的其中一個階段估計常式。</span><span class="sxs-lookup"><span data-stu-id="a79ee-220">We can either follow Beauregard's method for order finding as described [on Page 8 of arXiv:quant-ph/0205095v3](https://arxiv.org/pdf/quant-ph/0205095v3.pdf#page=8), or use one of the phase estimation routines available in Microsoft.Quantum.Characterization.</span></span> <span data-ttu-id="a79ee-221">例如， [健全的階段估計](xref:microsoft.quantum.characterization.robustphaseestimation) 也會使用一個額外的量子位。</span><span class="sxs-lookup"><span data-stu-id="a79ee-221">For example, [Robust Phase Estimation](xref:microsoft.quantum.characterization.robustphaseestimation) also uses one extra qubit.</span></span>
 
### <a name="factoring"></a><span data-ttu-id="a79ee-222">保 理</span><span class="sxs-lookup"><span data-stu-id="a79ee-222">Factoring</span></span> ###
<span data-ttu-id="a79ee-223">分解的目標是要判斷整數 $N $ 的兩個主要因素，其中 $N $ 是 $n $ 位數位。</span><span class="sxs-lookup"><span data-stu-id="a79ee-223">The goal of factoring is to determine the two prime factors of integer $N$, where $N$ is an $n$-bit number.</span></span>  
<span data-ttu-id="a79ee-224">分解包含以下所述的步驟。</span><span class="sxs-lookup"><span data-stu-id="a79ee-224">Factoring consists of the steps described below.</span></span> <span data-ttu-id="a79ee-225">這些步驟分成三個部分：傳統前置處理常式 (1-4) ;用來找出 $a \text{mod} N $ (5) 的量子運算常式;和傳統的後處理常式，從 order (6-9) 衍生質數。</span><span class="sxs-lookup"><span data-stu-id="a79ee-225">The steps are split into three parts: a classical preprocessing routine (1-4); a quantum computing routine to find the order of $a \text{ mod } N$ (5); and a classical postprocessing routine to derive the prime factors from the order (6-9).</span></span>

<span data-ttu-id="a79ee-226">傳統前置處理常式是由下列步驟所組成：</span><span class="sxs-lookup"><span data-stu-id="a79ee-226">The classical preprocessing routine consists of the following steps:</span></span>
1. <span data-ttu-id="a79ee-227">如果 $N $ 為偶數，則傳回主要因數 $2 $。</span><span class="sxs-lookup"><span data-stu-id="a79ee-227">If $N$ is even, return the prime factor $2$.</span></span>
2. <span data-ttu-id="a79ee-228">如果 $p \geq1 $ $q \geq2 $ $N = p ^ q $，則會傳回 $p $ 的主要因數。</span><span class="sxs-lookup"><span data-stu-id="a79ee-228">If $N=p^q$ for $p\geq1$, $q\geq2$, return the prime factor $p$.</span></span>  <span data-ttu-id="a79ee-229">此步驟會傳統方式執行。</span><span class="sxs-lookup"><span data-stu-id="a79ee-229">This step is performed classically.</span></span>
3. <span data-ttu-id="a79ee-230">選擇 $a $ 的亂數字，$1 以 < < N-$1。</span><span class="sxs-lookup"><span data-stu-id="a79ee-230">Choose a random number $a$ such that $1 < a < N-1$.</span></span>
4. <span data-ttu-id="a79ee-231">如果 $ \text{gcd} (a、N) # B0 $1，則傳回主要因數 $ \text{gcd} (a，N) $。</span><span class="sxs-lookup"><span data-stu-id="a79ee-231">If $\text{gcd}(a,N)>1$, return the prime factor $\text{gcd}(a,N)$.</span></span> <span data-ttu-id="a79ee-232">此步驟是使用 Euclid 的演算法來計算。</span><span class="sxs-lookup"><span data-stu-id="a79ee-232">This step is computed using Euclid's algorithm.</span></span>
<span data-ttu-id="a79ee-233">如果未傳回任何主要因素，我們會繼續進行量副程式：</span><span class="sxs-lookup"><span data-stu-id="a79ee-233">If no prime factor has been returned, we proceed to the quantum routine:</span></span>
5. <span data-ttu-id="a79ee-234">呼叫量子期間尋找演算法來計算 order $r $ of $a \text{mod} N $。</span><span class="sxs-lookup"><span data-stu-id="a79ee-234">Call the quantum period finding algorithm to calculate the order $r$ of $a \text{ mod } N$.</span></span> <span data-ttu-id="a79ee-235">在傳統的後處理常式中使用 $r $ 來判斷主要因素：</span><span class="sxs-lookup"><span data-stu-id="a79ee-235">Use $r$ in the classical postprocessing routine to determine the prime factors:</span></span>
6. <span data-ttu-id="a79ee-236">如果 $r $ 是奇數，請返回前置處理步驟 (3) 。</span><span class="sxs-lookup"><span data-stu-id="a79ee-236">If $r$ is odd, go back to preprocessing step (3).</span></span>
7. <span data-ttu-id="a79ee-237">如果 $r $ 是偶數，$a ^ {r/2} =-1 \ 文字 {mod} N $，請返回前置處理步驟 (3) 。</span><span class="sxs-lookup"><span data-stu-id="a79ee-237">If $r$ is even and $a^{r/2} = -1\text{ mod }N$, go back to preprocessing step (3).</span></span>
8. <span data-ttu-id="a79ee-238">如果 $ \text{gcd} (^ {r/2} + 1，N) $ 是 $N $ 的非一般因素，會傳回 $ \text{gcd} (^ {r/2} + 1，N) $。</span><span class="sxs-lookup"><span data-stu-id="a79ee-238">If $\text{gcd}(a^{r/2}+1, N)$ is a non-trivial factor of $N$, return $\text{gcd}(a^{r/2}+1, N)$.</span></span>
9. <span data-ttu-id="a79ee-239">如果 $ \text{gcd} (^ {r/2}-1，N) $ 是 $N $ 的非一般因素，會傳回 $ \text{gcd} (^ {r/2}-1，N) $。</span><span class="sxs-lookup"><span data-stu-id="a79ee-239">If $\text{gcd}(a^{r/2}-1, N)$ is a non-trivial factor of $N$, return $\text{gcd}(a^{r/2}-1, N)$.</span></span>


<span data-ttu-id="a79ee-240">分解演算法是概率：它可以顯示，機率至少為一半，$r $ 將是偶數，$a ^ {r/2} \neq-1 \text{mod} N $，因此會產生主要因數。</span><span class="sxs-lookup"><span data-stu-id="a79ee-240">The factoring algorithm is probabilistic: it can been shown that with probability at least one half that $r$ will be even and $a^{r/2} \neq -1 \text{ mod }N$, thus producing a prime factor.</span></span>  <span data-ttu-id="a79ee-241"> (如需詳細資訊，請參閱[Shor 的原始](https://doi.org/10.1109/SFCS.1994.365700)檔，[如需詳細資訊](xref:microsoft.quantum.more-information)) ，請參閱中的其中一個*基本的量子*運算文字。</span><span class="sxs-lookup"><span data-stu-id="a79ee-241">(See [Shor's original paper](https://doi.org/10.1109/SFCS.1994.365700) for details, or one of the *Basic quantum computing* texts in [For more information](xref:microsoft.quantum.more-information)).</span></span>
<span data-ttu-id="a79ee-242">如果未傳回主要因素，則只需從步驟 (1) 重複演算法。</span><span class="sxs-lookup"><span data-stu-id="a79ee-242">If a prime factor is not returned, then we simply repeat the algorithm from step (1).</span></span>  <span data-ttu-id="a79ee-243">$N $ 嘗試之後，每次嘗試失敗的機率最多為 $ 2 ^ {-n} $。</span><span class="sxs-lookup"><span data-stu-id="a79ee-243">After $n$ tries, the probability that every attempt has failed is at most $2^{-n}$.</span></span>
<span data-ttu-id="a79ee-244">因此，在重複此演算法之後，幾乎可以確保成功的次數很少。</span><span class="sxs-lookup"><span data-stu-id="a79ee-244">Thus after repeating the algorithm a small number of times success is virtually assured.</span></span>
